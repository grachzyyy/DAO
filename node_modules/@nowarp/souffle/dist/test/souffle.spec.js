"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const src_1 = require("../src");
describe("Souffle.js integration tests", () => {
    it("should generate and execute a simple SoufflÃ© program with correct output", () => {
        const ctx = new src_1.SouffleContext("VarPointsTo");
        // Add relation declarations
        ctx.add((0, src_1.relation)("assign", [
            ["a", "Symbol"],
            ["b", "Symbol"],
        ]));
        ctx.add((0, src_1.relation)("new", [
            ["v", "Symbol"],
            ["o", "Symbol"],
        ]));
        ctx.add((0, src_1.relation)("ld", [
            ["a", "Symbol"],
            ["b", "Symbol"],
            ["f", "Symbol"],
        ]));
        ctx.add((0, src_1.relation)("st", [
            ["a", "Symbol"],
            ["f", "Symbol"],
            ["b", "Symbol"],
        ]));
        // Add facts
        ctx.addFact("assign", ["v1", "v2"]);
        ctx.addFact("new", ["v1", "h1"]);
        ctx.addFact("new", ["v2", "h2"]);
        ctx.addFact("new", ["v3", "h3"]);
        ctx.addFact("st", ["v1", "f", "v3"]);
        ctx.addFact("ld", ["v4", "v1", "f"]);
        // Add rules for alias
        ctx.add((0, src_1.relation)("alias", [
            ["a", "Symbol"],
            ["b", "Symbol"],
        ], "output"));
        ctx.add((0, src_1.rule)([(0, src_1.atom)("alias", ["X", "X"])], [(0, src_1.body)((0, src_1.atom)("assign", ["X", "_"]))]));
        ctx.add((0, src_1.rule)([(0, src_1.atom)("alias", ["X", "X"])], [(0, src_1.body)((0, src_1.atom)("assign", ["_", "X"]))]));
        ctx.add((0, src_1.rule)([(0, src_1.atom)("alias", ["X", "Y"])], [(0, src_1.body)((0, src_1.atom)("assign", ["X", "Y"]))]));
        ctx.add((0, src_1.rule)([(0, src_1.atom)("alias", ["X", "Y"])], [
            (0, src_1.body)((0, src_1.atom)("ld", ["X", "A", "F"])),
            (0, src_1.body)((0, src_1.atom)("alias", ["A", "B"])),
            (0, src_1.body)((0, src_1.atom)("st", ["B", "F", "Y"])),
        ]));
        const executor = new src_1.SouffleSyncExecutor();
        const out = executor.execute(ctx);
        expect(out.kind).toBe("raw");
        if (out.kind !== "raw") {
            throw new Error("impossible");
        }
        expect(out.results).toBeDefined();
        expect(out.results.get("alias")).toEqual([
            ["v1", "v1"],
            ["v1", "v2"],
            ["v2", "v2"],
            ["v4", "v3"],
        ]);
    });
    it("should generate and execute a program with a simple reachability analysis", () => {
        const ctx = new src_1.SouffleContext("Reachability");
        // Add relation declarations
        ctx.add((0, src_1.relation)("edge", [
            ["from", "Symbol"],
            ["to", "Symbol"],
        ]));
        ctx.add((0, src_1.relation)("reachable", [["node", "Symbol"]], "output"));
        // Add facts
        ctx.addFact("edge", ["A", "B"]);
        ctx.addFact("edge", ["B", "C"]);
        ctx.addFact("edge", ["C", "D"]);
        // Add rules
        ctx.add((0, src_1.rule)([(0, src_1.atom)("reachable", ["X"])], [(0, src_1.body)((0, src_1.atom)("edge", ["X", "_"]))]));
        ctx.add((0, src_1.rule)([(0, src_1.atom)("reachable", ["Y"])], [(0, src_1.body)((0, src_1.atom)("reachable", ["X"])), (0, src_1.body)((0, src_1.atom)("edge", ["X", "Y"]))]));
        const executor = new src_1.SouffleSyncExecutor();
        const out = executor.execute(ctx);
        expect(out.kind).toBe("raw");
        if (out.kind !== "raw") {
            throw new Error("impossible");
        }
        expect(out.results).toBeDefined();
        expect(out.results.get("reachable")).toEqual([["A"], ["B"], ["C"], ["D"]]);
    });
    it("should generate and execute a program for simple ancestor relation", () => {
        const ctx = new src_1.SouffleContext("AncestorRelation");
        // Add relation declarations
        ctx.add((0, src_1.relation)("parent", [
            ["child", "Symbol"],
            ["parent", "Symbol"],
        ]));
        ctx.add((0, src_1.relation)("ancestor", [
            ["descendant", "Symbol"],
            ["ancestor", "Symbol"],
        ], "output"));
        // Add facts
        ctx.addFact("parent", ["B", "A"]);
        ctx.addFact("parent", ["C", "A"]);
        ctx.addFact("parent", ["D", "B"]);
        ctx.addFact("parent", ["E", "C"]);
        // Add rules
        ctx.add((0, src_1.rule)([(0, src_1.atom)("ancestor", ["X", "Y"])], [(0, src_1.body)((0, src_1.atom)("parent", ["X", "Y"]))]));
        ctx.add((0, src_1.rule)([(0, src_1.atom)("ancestor", ["X", "Z"])], [(0, src_1.body)((0, src_1.atom)("parent", ["X", "Y"])), (0, src_1.body)((0, src_1.atom)("ancestor", ["Y", "Z"]))]));
        const executor = new src_1.SouffleSyncExecutor();
        const out = executor.execute(ctx);
        expect(out.kind).toBe("raw");
        if (out.kind !== "raw") {
            throw new Error("impossible");
        }
        expect(out.results).toBeDefined();
        expect(out.results.get("ancestor")).toEqual([
            ["B", "A"],
            ["C", "A"],
            ["D", "B"],
            ["D", "A"],
            ["E", "A"],
            ["E", "C"],
        ]);
    });
});
