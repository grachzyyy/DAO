"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SouffleAsyncExecutor = exports.SouffleSyncExecutor = exports.SouffleExecutor = void 0;
const __1 = require("..");
const results_1 = require("./results");
const child_process_1 = require("child_process");
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
/**
 * Manages the process of executing Soufflé and parsing its output.
 */
class SouffleExecutor {
    soufflePath;
    inputDir;
    outputDir;
    constructor({ soufflePath = "souffle", inputDir = "/tmp/souffle-js", outputDir = "/tmp/souffle-js", } = {}) {
        this.soufflePath = soufflePath;
        this.inputDir = inputDir;
        this.outputDir = outputDir;
    }
    /**
     * Produces a Soufflé command that returns output in the CSV format.
     */
    makeSouffleCommand(ctx) {
        const inputDirPath = path_1.default.join(this.inputDir, ctx.filename);
        return `${this.soufflePath} -F${this.inputDir} -D${this.outputDir} ${inputDirPath}`;
    }
}
exports.SouffleExecutor = SouffleExecutor;
class SouffleSyncExecutor extends SouffleExecutor {
    /**
     * Executes the Datalog program using the Soufflé engine synchronously.
     * @returns `SouffleExecutionResult` which contains the status of execution.
     */
    execute(ctx) {
        try {
            fs_1.default.mkdirSync(this.inputDir, { recursive: true });
            __1.SouffleEmitter.make(ctx, {
                addComments: ctx.addComments,
            }).dumpSync(this.inputDir);
            const cmd = this.makeSouffleCommand(ctx);
            (0, child_process_1.execSync)(cmd, { stdio: ["ignore", "ignore", "pipe"] });
            const rawResults = ctx
                .collectOutputNames()
                .reduce((acc, relationName) => {
                const filepath = path_1.default.join(this.outputDir, `${relationName}.csv`);
                acc.set(relationName, (0, results_1.parseResultsSync)(filepath));
                return acc;
            }, new Map());
            const results = results_1.SouffleOutputStructured.fromRaw(ctx, rawResults);
            return results !== undefined
                ? { kind: "structured", results }
                : { kind: "raw", results: rawResults };
        }
        catch (error) {
            return { kind: "error", stderr: `${error}` };
        }
    }
}
exports.SouffleSyncExecutor = SouffleSyncExecutor;
class SouffleAsyncExecutor extends SouffleExecutor {
    /**
     * Executes the Datalog program using the Soufflé engine.
     * @returns `SouffleExecutionResult` which contains the status of execution.
     */
    async execute(ctx) {
        await fs_1.default.promises.mkdir(this.inputDir, { recursive: true });
        await __1.SouffleEmitter.make(ctx, {
            addComments: ctx.addComments,
        }).dump(this.inputDir);
        const cmd = this.makeSouffleCommand(ctx);
        return new Promise((resolve, reject) => {
            (0, child_process_1.exec)(cmd, async (error, _stdout, stderr) => {
                if (error) {
                    reject({
                        kind: "error",
                        stderr: stderr ? `${error}:\n${stderr}` : `${error}`,
                    });
                }
                else {
                    try {
                        const rawResults = await ctx
                            .collectOutputNames()
                            .reduce(async (accPromise, relationName) => {
                            const acc = await accPromise;
                            const filepath = path_1.default.join(this.outputDir, `${relationName}.csv`);
                            const rawResults = await (0, results_1.parseResults)(filepath);
                            acc.set(relationName, rawResults);
                            return acc;
                        }, Promise.resolve(new Map()));
                        const results = results_1.SouffleOutputStructured.fromRaw(ctx, rawResults);
                        resolve(results !== undefined
                            ? { kind: "structured", results }
                            : { kind: "raw", results: rawResults });
                    }
                    catch (parseError) {
                        reject({ kind: "error", stderr: `${parseError}` });
                    }
                }
            });
        });
    }
}
exports.SouffleAsyncExecutor = SouffleAsyncExecutor;
