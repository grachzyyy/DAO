"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseResultsSync = exports.parseResults = exports.SouffleOutputStructured = exports.parseSpaceSeparatedValues = exports.SpaceSeparatedParser = void 0;
const stream_1 = require("stream");
const errors_1 = require("../errors");
const fs_1 = __importDefault(require("fs"));
/**
 * Custom Transform Stream to parse space-separated values.
 */
class SpaceSeparatedParser extends stream_1.Transform {
    constructor(options = {}) {
        super({ ...options, objectMode: true });
    }
    _transform(chunk, _, callback) {
        const data = chunk.toString();
        const lines = data.split("\n").map((line) => line.trim());
        lines.forEach((line) => {
            if (line !== "") {
                const values = line.split(/\s+/);
                this.push(values);
            }
        });
        callback();
    }
}
exports.SpaceSeparatedParser = SpaceSeparatedParser;
/**
 * Parses CSV-like Soufflé output.
 */
function parseSpaceSeparatedValues(input) {
    return input
        .split("\n")
        .filter((line) => line.trim() !== "")
        .map((line) => line.trim())
        .reduce((acc, line) => {
        const strings = line.split(/\s+/);
        acc.push(strings);
        return acc;
    }, []);
}
exports.parseSpaceSeparatedValues = parseSpaceSeparatedValues;
/**
 * Structured Soufflé output that contains information about facts with additional
 * annotations added to the executed `Context`.
 */
class SouffleOutputStructured {
    entries;
    constructor(entries) {
        this.entries = entries;
    }
    /**
     * Generates a structured Soufflé output from raw CSV-like strings.
     * @returns `undefined` if cannot unmarshal output.
     */
    static fromRaw(ctx, rawOut) {
        const entries = new Map();
        for (const [relationName, allFactValues] of rawOut.entries()) {
            const relation = ctx.getRelation(relationName);
            if (relation === undefined) {
                throw errors_1.SouffleUsageError.make(`Cannot find relation: ${relationName}`);
            }
            for (const factValues of allFactValues) {
                const typedFactValues = factValues.map((v) => isNaN(Number(v)) ? v : Number(v));
                const fact = ctx.findFact(typedFactValues);
                if (fact === undefined) {
                    ctx.logger.warn(`Cannot find ${relationName} fact with values: ${typedFactValues}`);
                    return undefined;
                }
                let facts = entries.get(relationName);
                if (facts === undefined) {
                    facts = [];
                }
                facts.push(fact);
                entries.set(relationName, facts);
            }
        }
        return new SouffleOutputStructured(entries);
    }
}
exports.SouffleOutputStructured = SouffleOutputStructured;
/**
 * Asynchronously parses a file into a `RawSouffleOutput`.
 * @param filePath Path to the file to parse.
 * @returns `RawSouffleOutput` containing the parsed data.
 */
async function parseResults(filePath) {
    return new Promise((resolve, reject) => {
        const results = [];
        fs_1.default.createReadStream(filePath)
            .pipe(new SpaceSeparatedParser())
            .on("data", (data) => {
            results.push(data);
        })
            .on("end", () => {
            resolve(results);
        })
            .on("error", (error) => {
            reject(`Error reading CSV file: ${error}`);
        });
    });
}
exports.parseResults = parseResults;
/**
 * Synchronously parses a file into a `SouffleExecutionResult`.
 * @param filePath Path to the file to parse.
 * @returns `RawSouffleOutput` containing the parsed data.
 */
function parseResultsSync(filePath) {
    const data = fs_1.default.readFileSync(filePath, { encoding: "utf8" });
    return parseSpaceSeparatedValues(data);
}
exports.parseResultsSync = parseResultsSync;
