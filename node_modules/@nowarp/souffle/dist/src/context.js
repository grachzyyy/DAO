"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SouffleContext = void 0;
const errors_1 = require("./errors");
const logger_1 = require("./logger");
const syntaxUtils_1 = require("./syntaxUtils");
const syntaxConstructors_1 = require("./syntaxConstructors");
/**
 * Program generation context that maps relations, facts, and rules, and generates
 * a valid AST, suitable for pretty-printing and further processing by `souffle`.
 *
 * `FactData` is an optional annotation of facts that holds some information about
 * their meanings. For example, it could be used to map some program entities with
 * generated Soufflé facts.
 */
class SouffleContext {
    name;
    /**
     * Docstring-like comment introduced to the top level of the generated program.
     */
    programComment;
    /**
     * Add generated comments to the output Soufflé program.
     * Set to `false` to reduce the size of produced code.
     */
    addComments;
    /**
     * Logger used to report library messages.
     */
    logger;
    /**
     * Holds facts mapped to their corresponding relation declarations.
     */
    facts = new Map();
    /**
     * Holds declarations of relations.
     */
    relations = new Map();
    /**
     * Soufflé rules defined in the program.
     */
    rules = [];
    /**
     * @param name Unique name of the generated program.
     * @param comment Docstring-like comment to be added on the top of the generated program.
     * @param addComments Include comments to the generated program.
     */
    constructor(name, { comment = undefined, addComments = false, logger = new logger_1.DefaultLogger(), } = {}) {
        this.name = name;
        this.programComment = comment;
        this.addComments = addComments;
        this.logger = logger;
    }
    /** Filename of the Soufflé file to be used for the generated program. */
    get filename() {
        return `${this.name}.dl`;
    }
    /**
     * Generates Soufflé program based on the relations, rules and facts added to the context.
     */
    generateProgram() {
        const relationsWithFacts = Array.from(this.relations.keys()).reduce((acc, relationName) => {
            const decl = this.relations.get(relationName);
            const facts = this.facts.get(relationName) || new Set();
            return acc.concat([decl, ...facts]);
        }, []);
        const entries = [...relationsWithFacts, ...this.rules];
        return (0, syntaxConstructors_1.program)(this.name, entries, this.programComment);
    }
    /**
     * Finds a rule which has the given name among its heads.
     */
    findRule(name) {
        return this.rules.find((r) => r.heads.find((h) => h.name == name) !== undefined);
    }
    /**
     * Finds a relation defined within the program.
     */
    getRelation(name) {
        return this.relations.get(name);
    }
    /**
     * Finds the fact defined with the given values.
     * @returns FactData if found, `undefined` otherwise.
     */
    findFact(values) {
        for (const [_relationName, facts] of this.facts) {
            const fact = Array.from(facts).find((fact) => (0, syntaxUtils_1.eqFactValues)(fact.values, values));
            if (fact !== undefined) {
                return fact;
            }
        }
        return undefined;
    }
    /**
     * Collects names of relations which produce output on executing.
     */
    collectOutputNames() {
        return Array.from(this.relations.entries()).reduce((outputNames, [_, relation]) => {
            if (relation.io === "output") {
                outputNames.push(relation.name);
            }
            return outputNames;
        }, []);
    }
    /**
     * Adds new entities to the Soufflé program.
     * @throws If an entity is already defined.
     */
    add(entity) {
        if (entity.kind === "relation") {
            this.addRelation(entity);
        }
        else if (entity.kind === "rule") {
            this.addRule(entity);
        }
        else {
            throw errors_1.SouffleUsageError.make(`Cannot add unsupported entity: ${entity}`);
        }
    }
    /**
     * Adds a new relation to the Soufflé program.
     * @throws If a relation with the same name is already defined.
     */
    addRelation(relation) {
        if (this.relations.has(relation.name)) {
            throw errors_1.SouffleUsageError.make(`Relation ${relation.name} is already declared`);
        }
        this.relations.set(relation.name, relation);
    }
    /**
     * Adds a new fact to an existing relation.
     * @param name The name of the relation to which the fact is related.
     * @param fact Fact values to add.
     * @throws Error if the relation does not exist.
     */
    addFact(name, factValues, data) {
        const relation = this.relations.get(name);
        if (!relation) {
            throw errors_1.SouffleUsageError.make(`Unknown relation: ${name}`);
        }
        // Sanity check: compare number of arguments in the declaration and the actual ones.
        if (factValues.length !== relation.args.length) {
            throw errors_1.SouffleUsageError.make(`Incorrect number of arguments for ${this.name}: got ${factValues.length} expected ${relation.args.length}`);
        }
        const newFact = (0, syntaxConstructors_1.fact)(name, factValues, data);
        this.facts.set(name, (this.facts.get(name) || new Set()).add(newFact));
    }
    /**
     * Adds a new rule to the Soufflé program.
     * @param rule The rule to add to the program.
     * @throws Error if any head relation is not defined.
     */
    addRule(rule) {
        const undefinedRelations = rule.heads
            .filter((head) => !this.relations.has(head.name))
            .map((head) => head.name);
        if (undefinedRelations.length > 0) {
            throw errors_1.SouffleUsageError.make(`Undefined relations in the \`${rule}\` rule: ${undefinedRelations.join(", ")}\nPlease add them using \`addRelation\`.`);
        }
        this.rules.push(rule);
    }
}
exports.SouffleContext = SouffleContext;
