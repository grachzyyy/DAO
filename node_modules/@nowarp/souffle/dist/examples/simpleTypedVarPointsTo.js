"use strict";
//
// Implements https://souffle-lang.github.io/examples#simple-typed-symbolpointsto in Souffle.js
//
Object.defineProperty(exports, "__esModule", { value: true });
const src_1 = require("../src");
// Initialize the Souffle context that keeps the created program entries.
const ctx = new src_1.SouffleContext("VarPointsTo");
// Add relation declarations:
// .decl assign( a:symbol , b:symbol )
// .decl new( v:symbol, o:symbol )
// .decl ld( a:symbol, b:symbol, f:symbol  )
// .decl st( a:symbol, f:symbol, b:symbol )
ctx.add((0, src_1.relation)("assign", [
    ["a", "Symbol"],
    ["b", "Symbol"],
]));
ctx.add((0, src_1.relation)("new", [
    ["v", "Symbol"],
    ["o", "Symbol"],
]));
ctx.add((0, src_1.relation)("ld", [
    ["a", "Symbol"],
    ["b", "Symbol"],
    ["f", "Symbol"],
]));
ctx.add((0, src_1.relation)("st", [
    ["a", "Symbol"],
    ["f", "Symbol"],
    ["b", "Symbol"],
]));
// Add facts:
// assign("v1","v2").
// new("v1","h1").
// new("v2","h2").
// new("v3","h3").
// st("v1","f","v3").
// ld("v4","v1","f").
ctx.addFact("assign", ["v1", "v2"]);
ctx.addFact("new", ["v1", "h1"]);
ctx.addFact("new", ["v2", "h2"]);
ctx.addFact("new", ["v3", "h3"]);
ctx.addFact("st", ["v1", "f", "v3"]);
ctx.addFact("ld", ["v4", "v1", "f"]);
// Add rules:
// .decl alias( a:symbol, b:symbol )
// .output alias
// alias(X,X) :- assign(X,_).
// alias(X,X) :- assign(_,X).
// alias(X,Y) :- assign(X,Y).
// alias(X,Y) :- ld(X,A,F), alias(A,B), st(B,F,Y).
ctx.add((0, src_1.relation)("alias", [
    ["a", "Symbol"],
    ["b", "Symbol"],
], "output"));
ctx.add((0, src_1.rule)([(0, src_1.atom)("alias", ["X", "X"])], [(0, src_1.body)((0, src_1.atom)("assign", ["X", "_"]))]));
ctx.add((0, src_1.rule)([(0, src_1.atom)("alias", ["X", "X"])], [(0, src_1.body)((0, src_1.atom)("assign", ["_", "X"]))]));
ctx.add((0, src_1.rule)([(0, src_1.atom)("alias", ["X", "Y"])], [(0, src_1.body)((0, src_1.atom)("assign", ["X", "Y"]))]));
ctx.add((0, src_1.rule)([(0, src_1.atom)("alias", ["X", "Y"])], [
    (0, src_1.body)((0, src_1.atom)("ld", ["X", "A", "F"])),
    (0, src_1.body)((0, src_1.atom)("alias", ["A", "B"])),
    (0, src_1.body)((0, src_1.atom)("st", ["B", "F", "Y"])),
]));
// .decl pointsTo( a:symbol, o:symbol )
// .output pointsTo
// pointsTo(X,Y) :- new(X,Y).
// pointsTo(X,Y) :- alias(X,Z), pointsTo(Z,Y).
ctx.add((0, src_1.relation)("pointsTo", [
    ["a", "Symbol"],
    ["o", "Symbol"],
], "output"));
ctx.add((0, src_1.rule)([(0, src_1.atom)("pointsTo", ["X", "Y"])], [(0, src_1.body)((0, src_1.atom)("new", ["X", "Y"]))]));
ctx.add((0, src_1.rule)([(0, src_1.atom)("pointsTo", ["X", "Y"])], [(0, src_1.body)((0, src_1.atom)("alias", ["X", "Z"])), (0, src_1.body)((0, src_1.atom)("pointsTo", ["Z", "Y"]))]));
// Execute the generated Soufflé program containing all the added entries
const executor = new src_1.SouffleSyncExecutor();
const out = executor.execute(ctx);
if (out.kind !== "raw") {
    throw new Error(`Error executing Soufflé:\n${out.kind === "error" ? out.stderr : "impossible"}`);
}
console.log("Raw Soufflé output:\n", out.results);
