"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DumpCallGraph = void 0;
const tool_1 = require("./tool");
const callGraph_1 = require("../internals/ir/callGraph");
const util_1 = require("../internals/util");
const json_bigint_1 = __importDefault(require("json-bigint"));
const STDLIB_COLOR = "#F0F8FF";
/**
 * Checks if the node represents any information to be shown on graphic dumps.
 */
function shouldBeShown(node) {
    return node.loc
        ? // Hide unused stdlib functions
            node.loc.origin === "user" ||
                node.outEdges.size > 0 ||
                node.inEdges.size > 0
        : true;
}
/**
 * A tool that dumps the Call Graph (CG) of the given compilation unit in the specified format.
 */
class DumpCallGraph extends tool_1.Tool {
    constructor(ctx, options) {
        super(ctx, options);
    }
    get defaultOptions() {
        return {
            format: "dot",
        };
    }
    /**
     * Executes `DumpCallGraph` tool.
     * @param cu `CompilationUnit` representing the code to analyze.
     * @returns A `ToolOutput` containing the generated call graph data.
     */
    runWithCU(cu) {
        const callGraph = cu.callGraph;
        const format = this.options.format;
        switch (format) {
            case "dot":
                return this.makeOutput(cu, GraphvizDumper.dumpCallGraph(cu.ast, callGraph));
            case "mmd":
                return this.makeOutput(cu, MermaidDumper.dumpCallGraph(cu.ast, callGraph));
            case "json":
                return this.makeOutput(cu, JSONDumper.dumpCallGraph(callGraph));
            default:
                throw (0, util_1.unreachable)(format);
        }
    }
    getDescription() {
        return "Dumps the Call Graph (CG) in the selected format: DOT, Mermaid, or JSON.";
    }
    getOptionDescriptions() {
        return {
            format: "The output format for the call graph dump: <dot|json|mmd>.",
        };
    }
}
exports.DumpCallGraph = DumpCallGraph;
/**
 * Utility class to dump the call graph in Mermaid format.
 */
class MermaidDumper {
    static dumpCallGraph(ast, callGraph) {
        if (!callGraph || callGraph.getNodes().size === 0) {
            return 'graph TD\n    empty["Empty Call Graph"]';
        }
        let diagram = "graph TD\n";
        let styles = "";
        callGraph.getNodes().forEach((node) => {
            if (!shouldBeShown(node))
                return;
            const nodeId = `node_${node.idx}`;
            const label = (node.signature(ast) || node.name || "Unknown").replace(/"/g, "'");
            const effects = getEffectsTooltip(node);
            diagram += `    ${nodeId}["${label}${effects}"]\n`;
            if (node.loc?.origin === "stdlib") {
                styles += `    style ${nodeId} fill:${STDLIB_COLOR},stroke:#000,stroke-width:1px;\n`;
            }
        });
        callGraph.getEdges().forEach((edge) => {
            const srcId = `node_${edge.src}`;
            const dstId = `node_${edge.dst}`;
            diagram += `    ${srcId} --> ${dstId}\n`;
        });
        return diagram + styles;
    }
}
/**
 * Utility class to dump the call graph in DOT (Graphviz) format.
 */
class GraphvizDumper {
    static dumpCallGraph(ast, callGraph) {
        if (!callGraph || callGraph.getNodes().size === 0) {
            return 'digraph "CallGraph" {\n    node [shape=box];\n    empty [label="Empty Call Graph"];\n}\n';
        }
        let dot = `digraph "CallGraph" {\n    node [shape=box];\n`;
        callGraph.getNodes().forEach((node) => {
            if (!shouldBeShown(node))
                return;
            const nodeId = `node_${node.idx}`;
            const label = (node.signature(ast) || node.name || "Unknown").replace(/"/g, "'");
            const effects = getEffectsTooltip(node);
            if (node.loc?.origin === "stdlib") {
                dot += `    ${nodeId} [label="${label}${effects}" style=filled fillcolor="${STDLIB_COLOR}"];\n`;
            }
            else {
                dot += `    ${nodeId} [label="${label}${effects}"];\n`;
            }
        });
        callGraph.getEdges().forEach((edge) => {
            const srcId = `node_${edge.src}`;
            const dstId = `node_${edge.dst}`;
            dot += `    ${srcId} -> ${dstId};\n`;
        });
        dot += `}\n`;
        return dot;
    }
}
/**
 * Utility class to dump the call graph in JSON format.
 */
class JSONDumper {
    static dumpCallGraph(callGraph) {
        if (!callGraph) {
            return json_bigint_1.default.stringify({ nodes: [], edges: [] }, null, 2);
        }
        const data = {
            nodes: Array.from(callGraph.getNodes().values()).map((node) => ({
                idx: node.idx,
                name: node.signature || node.name || "Unknown",
                inEdges: Array.from(node.inEdges || []),
                outEdges: Array.from(node.outEdges || []),
            })),
            edges: Array.from(callGraph.getEdges().values()).map((edge) => ({
                idx: edge.idx,
                src: edge.src,
                dst: edge.dst,
            })),
        };
        return json_bigint_1.default.stringify(data, null, 2);
    }
}
function getEffectsTooltip(node) {
    const effects = node.effects;
    if (effects === 0)
        return "";
    const effectsList = [];
    const getFieldsString = (status) => Array.from(node.stateAccess.get(status)).join(",");
    if (effects & callGraph_1.Effect.Send)
        effectsList.push("Send");
    if (effects & callGraph_1.Effect.StateRead) {
        effectsList.push(`StateRead<${getFieldsString("read")}>`);
    }
    if (effects & callGraph_1.Effect.StateWrite) {
        effectsList.push(`StateWrite<${getFieldsString("write")}>`);
    }
    if (effects & callGraph_1.Effect.AccessDatetime)
        effectsList.push("AccessDatetime");
    if (effects & callGraph_1.Effect.PrgUse)
        effectsList.push("PrgUse");
    if (effects & callGraph_1.Effect.PrgSeedInit)
        effectsList.push("PrgSeedInit");
    return effectsList.length > 0 ? `\n[${effectsList.join(",")}]` : "";
}
