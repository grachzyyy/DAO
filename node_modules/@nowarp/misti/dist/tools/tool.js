"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateToolsHelpMessage = exports.hasBuiltInTool = exports.getAllTools = exports.findBuiltInTool = exports.Tool = void 0;
const context_1 = require("../internals/context");
const exceptions_1 = require("../internals/exceptions");
/**
 * A tool that can be used to extend the functionality of Misti.
 */
class Tool {
    ctx;
    /**
     * User-defined options for the tool merged with the default options.
     */
    options;
    constructor(ctx, config) {
        this.ctx = ctx;
        this.options = this.mergeWithDefaults(config);
    }
    /**
     * The unique identifier of the tool.
     */
    get id() {
        return this.constructor.name;
    }
    /**
     * Merges the given config with the default options.
     */
    mergeWithDefaults(config) {
        return {
            ...this.defaultOptions,
            ...config,
        };
    }
    /**
     * Runs the tool on the given compilation unit.
     * @param cu The compilation unit to run the tool on.
     * @returns The result of the tool.
     */
    run(cu) {
        return this.runWithCU(cu);
    }
    /**
     * Runs the tool without any compilation unit.
     * @returns The result of the tool.
     */
    runStandalone() {
        throw exceptions_1.InternalException.make(`Tool ${this.id} does not support running without a compilation unit`);
    }
    /**
     * Implement this method if your tool needs a compilation unit.
     * @param cu The compilation unit to run the tool on.
     */
    runWithCU(_) {
        throw exceptions_1.InternalException.make(`Tool ${this.id} does not support running with a compilation unit`);
    }
    /**
     * Makes a ToolOutput from the given output.
     */
    makeOutput(cu, output) {
        return {
            name: this.id,
            projectName: cu?.projectName,
            output,
        };
    }
    /**
     * Tests if the Tool could be executed without compilation unit using `runStandalone`.
     */
    static canRunStandalone(tool) {
        try {
            const originalMethod = tool.runStandalone;
            return originalMethod !== Tool.prototype.runStandalone;
        }
        catch {
            return false;
        }
    }
}
exports.Tool = Tool;
/**
 * A mapping of tool names to their respective loader functions.
 */
const BuiltInTools = {
    DumpAst: {
        loader: (ctx, options) => Promise.resolve().then(() => __importStar(require("./dumpAst"))).then((module) => new module.DumpAst(ctx, options)),
    },
    DumpCfg: {
        loader: (ctx, options) => Promise.resolve().then(() => __importStar(require("./dumpCfg"))).then((module) => new module.DumpCfg(ctx, options)),
    },
    DumpConfig: {
        loader: (ctx, options) => Promise.resolve().then(() => __importStar(require("./dumpConfig"))).then((module) => new module.DumpConfig(ctx, options)),
    },
    DumpImports: {
        loader: (ctx, options) => Promise.resolve().then(() => __importStar(require("./dumpImports"))).then((module) => new module.DumpImports(ctx, options)),
    },
    DumpCallGraph: {
        loader: (ctx, options) => Promise.resolve().then(() => __importStar(require("./dumpCallgraph"))).then((module) => new module.DumpCallGraph(ctx, options)),
    },
};
/**
 * Asynchronously retrieves a built-in tool by its name.
 * If the tool is found in the BuiltInTools registry, it is loaded and returned;
 * otherwise, a warning is logged and `undefined` is returned.
 *
 * @param ctx Misti context.
 * @param name The name of the tool to retrieve. This name must match a key in the BuiltInTools object.
 * @param options The options to pass to the tool constructor.
 * @returns A Promise that resolves to a Tool instance or `undefined` if the tool cannot be found or fails to load.
 */
async function findBuiltInTool(ctx, name, options) {
    const toolEntry = BuiltInTools[name];
    if (!toolEntry) {
        ctx.logger.warn(`Built-in tool ${name} not found.`);
        return undefined;
    }
    try {
        return await toolEntry.loader(ctx, options);
    }
    catch (error) {
        ctx.logger.error(`Error loading built-in tool ${name}: ${error}`);
        return undefined;
    }
}
exports.findBuiltInTool = findBuiltInTool;
/**
 * Returns a list of all the available built-in tools.
 * @returns An array of strings representing the names of tools.
 */
function getAllTools() {
    return Object.keys(BuiltInTools);
}
exports.getAllTools = getAllTools;
/**
 * @returns True if there is a built-in tool with the given name.
 */
function hasBuiltInTool(name) {
    return name in BuiltInTools;
}
exports.hasBuiltInTool = hasBuiltInTool;
/**
 * Generates a help message for all the available tools.
 * @returns A string containing the help message.
 */
async function generateToolsHelpMessage() {
    let helpMessage = "Available tools:\n\n";
    for (const [toolName, toolEntry] of Object.entries(BuiltInTools)) {
        const tool = await toolEntry.loader(new context_1.MistiContext(undefined), {});
        helpMessage += `* ${toolName}: ${tool.getDescription()}\n`;
        const optionDescriptions = tool.getOptionDescriptions();
        if (Object.keys(optionDescriptions).length > 0)
            helpMessage += "  Options:\n";
        for (const [optionName, description] of Object.entries(optionDescriptions)) {
            helpMessage += `  - ${optionName}: ${description}\n`;
        }
        helpMessage += "\n";
    }
    return helpMessage;
}
exports.generateToolsHelpMessage = generateToolsHelpMessage;
