"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TactConfigManager = void 0;
const imports_1 = require("../../internals/tact/imports");
const exceptions_1 = require("../exceptions");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
/**
 * Manages the logic around the Tact configuration file.
 *
 * Tact config describes the structure of the project, and includes the entry
 * points to run compilation and analysis on.
 */
class TactConfigManager {
    projectRoot;
    config;
    constructor(
    /**
     * An absolute path to the root directory storing the configuration file.
     *
     * If the config is generated for the Tact contract, it should be a directory containing all the imported files.
     */
    projectRoot, 
    /** Tact config parsed with Zod. */
    config) {
        this.projectRoot = projectRoot;
        this.config = config;
    }
    /**
     * Creates a TactConfigManager from a Tact configuration file typically specified by the user.
     *
     * @param ctx Misti context.
     * @param tactConfigPath Path to the Tact configuration file.
     */
    static fromConfig(tactConfigPath) {
        return new TactConfigManager(path_1.default.resolve(path_1.default.dirname(tactConfigPath)), this.readConfig(tactConfigPath));
    }
    /**
     * Creates a TactConfigManager from a single Tact contract.
     *
     * @param ctx Misti context.
     * @param projectName Name of the project.
     * @param contractPath Path to the Tact contract.
     * @param vfs Virtual file system to manage interactions with the project files.
     */
    static fromContract(projectRoot, contractPath, projectName = path_1.default.basename(contractPath, ".tact"), vfs) {
        let vfsContractPath = "";
        if (vfs.type === "local") {
            vfsContractPath = path_1.default.relative(projectRoot, contractPath);
        }
        else {
            const absoluteProjectRoot = vfs.resolve(projectRoot);
            const absoluteContractPath = path_1.default.resolve(projectRoot, contractPath);
            vfsContractPath = path_1.default.relative(absoluteProjectRoot, absoluteContractPath);
        }
        const tactConfig = {
            projects: [
                {
                    name: projectName,
                    path: vfsContractPath,
                    output: "/tmp/misti/output",
                    options: {
                        debug: false,
                        external: true,
                    },
                },
            ],
        };
        return new TactConfigManager(path_1.default.resolve(projectRoot), tactConfig);
    }
    getConfig() {
        return this.config;
    }
    /**
     * Returns absolute path to the project root.
     */
    getProjectRoot() {
        return this.projectRoot;
    }
    /**
     * Gets projects defined within the configuration file.
     */
    getProjects() {
        return this.config.projects;
    }
    /**
     * Find the project config based on the provided name.
     */
    findProjectByName(projectName) {
        return this.config.projects.find((project) => projectName === project.name);
    }
    /**
     * Find the project config based on the provided path.
     */
    findProjectByPath(projectPath) {
        return this.config.projects.find((project) => projectPath === this.resolveProjectPath(project.path));
    }
    /**
     * Returns an absolute path or the project based on the project path.
     */
    resolveProjectPath(projectPath) {
        return path_1.default.resolve(this.projectRoot, projectPath);
    }
    /**
     * Reads the Tact configuration file from the specified path, parses it, and returns
     * the Config object.
     * @throws If the config file does not exist or cannot be parsed.
     * @returns The parsed Config object.
     */
    static readConfig(tactConfigPath) {
        const resolvedPath = path_1.default.resolve(tactConfigPath);
        if (!fs_1.default.existsSync(resolvedPath)) {
            throw exceptions_1.ExecutionException.make(`Unable to find config file at ${resolvedPath}`);
        }
        try {
            return (0, imports_1.parseConfig)(fs_1.default.readFileSync(resolvedPath, "utf8"));
        }
        catch (err) {
            (0, exceptions_1.throwZodError)(err, {
                msg: `Incorrect Tact Project file ${resolvedPath}:`,
                help: [
                    `Ensure ${resolvedPath} is a Tact Project file.`,
                    "See https://docs.tact-lang.org/book/config/ for additional information.",
                ].join(" "),
            });
        }
    }
    /**
     * Returns absolute paths to entry points specified in the Tact configuration file.
     */
    getEntryPoints() {
        return this.config.projects.map((p) => this.resolveProjectPath(p.path));
    }
}
exports.TactConfigManager = TactConfigManager;
