"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseTactProject = void 0;
const imports_1 = require("../../internals/tact/imports");
const imports_2 = require("../../internals/tact/imports");
const exceptions_1 = require("../exceptions");
const stdlib_1 = require("./stdlib");
const createNodeFileSystem_1 = require("../../vfs/createNodeFileSystem");
const compiler_1 = require("@tact-lang/compiler");
/**
 * Parses the project defined in the Tact configuration file, generating its AST.
 *
 * @param mistiCtx Misti context
 * @param projectRoot Absolute path to the root the project
 * @param config The Tact configuration object: contents of the existing file or a generated object
 * @param projectVfs Virtual file system to manage file interactions during parsing
 * @returns A mapping of project names to their corresponding ASTs.
 */
function parseTactProject(mistiCtx, projectConfig, projectRoot, projectVfs) {
    const stdlibPath = mistiCtx.config.tactStdlibPath ?? (0, stdlib_1.getStdlibPath)();
    let stdlibVfs;
    if (projectVfs.type === "local") {
        stdlibVfs = (0, createNodeFileSystem_1.createNodeFileSystem)(stdlibPath);
        projectVfs = (0, createNodeFileSystem_1.createNodeFileSystem)(projectRoot);
    }
    else {
        stdlibVfs = (0, compiler_1.createVirtualFileSystem)("@stdlib", imports_1.stdLibFiles);
    }
    mistiCtx.logger.debug(`Parsing project ${projectConfig.name} ...`);
    try {
        let ctx = new imports_2.CompilerContext();
        ctx = (0, imports_2.enableFeatures)(ctx, mistiCtx.logger, projectConfig);
        const astFactory = (0, imports_2.getAstFactory)();
        ctx = (0, imports_2.precompile)(ctx, projectVfs, stdlibVfs, projectConfig.path, (0, imports_1.getParser)(astFactory, "new"), astFactory);
        return (0, imports_2.getRawAST)(ctx);
    }
    catch (error) {
        throw exceptions_1.TactException.make(error);
    }
}
exports.parseTactProject = parseTactProject;
