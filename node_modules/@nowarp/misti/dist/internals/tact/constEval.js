"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MakeLiteral = exports.evalsToPredicate = exports.evalsToLiteral = exports.evalToType = exports.evalExpr = void 0;
const imports_1 = require("../../internals/tact/imports");
/**
 * Evaluates a constant expression and returns its value.
 *
 * @param expr The AST expression to evaluate.
 * @returns The evaluated constant value, or undefined if evaluation fails.
 */
function evalExpr(expr) {
    try {
        const util = (0, imports_1.getAstUtil)((0, imports_1.getAstFactory)());
        return (0, imports_1.evalConstantExpression)(expr, new imports_1.CompilerContext(), util);
    }
    catch {
        return undefined;
    }
}
exports.evalExpr = evalExpr;
/**
 * Evaluates the given expression to a constant value and checks if it matches
 * the expected type.
 *
 * @param expr The expression to evaluate.
 * @param expectedKind The expected kind of the result.
 * @returns The evaluated value if it matches the expected type, undefined otherwise.
 */
function evalToType(expr, expectedKind) {
    const lit = evalExpr(expr);
    return lit !== undefined && lit.kind === expectedKind ? lit : undefined;
}
exports.evalToType = evalToType;
/**
 * Evaluates the given expression to a literal and checks if it matches
 * the expected type and value.
 *
 * @param expr The expression to evaluate.
 * @param expectedKind The expected kind of the result.
 * @param expected The expected result.
 * @returns True if the expression can be evaluated to a constant value that
 *          matches the expected type and value, false otherwise.
 */
function evalsToLiteral(expr, expected) {
    const result = evalExpr(expr);
    return result !== undefined && (0, imports_1.eqExpressions)(result, expected);
}
exports.evalsToLiteral = evalsToLiteral;
/**
 * Evaluates the given expression to a constant value and checks if it satisfies the predicate.
 *
 * @param expr The expression to evaluate.
 * @param predicate The predicate to check.
 * @returns True if the expression can be evaluated to a constant value that satisfies
 *          the predicate, false otherwise.
 */
function evalsToPredicate(expr, predicate) {
    const lit = evalExpr(expr);
    return lit !== undefined && predicate(lit);
}
exports.evalsToPredicate = evalsToPredicate;
/**
 * Wraps an OOP API into into something a sane developer might actually want to use.
 */
class MakeLiteral {
    static boolean(value) {
        return (0, imports_1.getAstUtil)((0, imports_1.getAstFactory)()).makeBooleanLiteral(value, imports_1.dummySrcInfo);
    }
    static number(value) {
        return (0, imports_1.getAstUtil)((0, imports_1.getAstFactory)()).makeNumberLiteral(value, imports_1.dummySrcInfo);
    }
}
exports.MakeLiteral = MakeLiteral;
