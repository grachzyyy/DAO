"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getExtendsSelfType = exports.functionHasAttribute = exports.isSendCall = exports.SEND_METHODS = exports.SEND_FUNCTIONS = exports.getConstantLoadSize = exports.getConstantStoreSize = exports.ADDRESS_SIZE = exports.isStdlibCall = exports.isMethodCall = exports.isFunctionCall = exports.getMethodCallsChain = exports.collectConditions = exports.funName = exports.collectFields = exports.statementsAreEqual = exports.nodesAreEqual = exports.isPrimitiveLiteral = exports.SrcInfoSet = exports.mutationNames = exports.collectMutations = exports.isStdlibMutationMethod = exports.isSelfAccess = exports.isSelf = exports.removeSelf = exports.formatPosition = void 0;
const iterators_1 = require("./iterators");
const tact_1 = require("../../internals/tact/");
const util_1 = require("../util");
const stdlib_1 = require("./stdlib");
const imports_1 = require("../../internals/tact/imports");
const imports_2 = require("../../internals/tact/imports");
const imports_3 = require("../../internals/tact/imports");
const json_bigint_1 = __importDefault(require("json-bigint"));
const path = __importStar(require("path"));
/**
 * Creates a concise string representation of `SrcInfo`.
 */
function formatPosition(ref) {
    if (!ref || !ref.file) {
        return "";
    }
    const relativeFilePath = path.relative(process.cwd(), ref.file);
    const lc = ref.interval.getLineAndColumn();
    return `${relativeFilePath}: ${lc}\n`;
}
exports.formatPosition = formatPosition;
/**
 * Returns the accessor name without the leading `self.` part.
 *
 * For example:
 * - `self.a` -> AstId(`a`)
 * - `self.a()` -> AstMethodCall(`a`)
 * - `self.object.f1` -> AstFieldAccess(`object.f1`)
 * - `nonSelf.a` -> undefined
 */
function removeSelf(expr) {
    if (expr.kind === "method_call") {
        return removeSelf(expr.self);
    }
    if (expr.kind === "field_access") {
        if (isSelf(expr.aggregate)) {
            return expr.field;
        }
        else {
            const newAggregate = removeSelf(expr.aggregate);
            if (newAggregate !== undefined) {
                return {
                    ...expr,
                    aggregate: newAggregate,
                };
            }
        }
    }
    return undefined;
}
exports.removeSelf = removeSelf;
/**
 * @returns True for self identifiers: `self`.
 */
function isSelf(expr) {
    return expr.kind === "id" && (0, imports_2.isSelfId)(expr);
}
exports.isSelf = isSelf;
/**
 * @returns True for self access expressions: `self.a`, `self.a.b`.
 */
function isSelfAccess(expr) {
    const path = (0, imports_2.tryExtractPath)(expr);
    return path !== null && path.length > 1 && (0, imports_2.isSelfId)(path[0]);
}
exports.isSelfAccess = isSelfAccess;
/**
 * @returns True iff `call` is a stdlib method mutating its receiver.
 */
function isStdlibMutationMethod(call) {
    const methodName = (0, imports_2.idText)(call.method);
    return (
    // Filter out contract calls e.g.: `self.set(/*...*/)`
    !isSelf(call.self) &&
        // TODO: This should be rewritten when we have types in AST
        (stdlib_1.MAP_MUTATING_METHODS.has(methodName) ||
            stdlib_1.BUILDER_MUTATING_METHODS.has(methodName)));
}
exports.isStdlibMutationMethod = isStdlibMutationMethod;
/**
 * Collects mutations local or state mutations within the statements.
 *
 * @param The statement to analyze
 * @param flatStmts If true, only traverse statements at the current level without
 *                  going into nested statements. It should be used when calling this function
 *                  inside one of the iterators.
 * @returns Mutated fields and local identifiers, including nested fields of mutated structure instances
 */
function collectMutations(stmt, { flatStmts = false } = {}) {
    const mutatedFields = [];
    const mutatedLocals = [];
    const handleMethodCallsMutations = () => {
        (0, iterators_1.forEachExpression)(stmt, (expr) => {
            if (expr.kind === "method_call" && isStdlibMutationMethod(expr)) {
                if (isSelfAccess(expr.self)) {
                    // Field mutation
                    const mutated = removeSelf(expr);
                    if (mutated) {
                        mutatedFields.push(mutated);
                    }
                }
                else {
                    // Local mutation
                    if (expr.self.kind === "field_access" || expr.self.kind === "id")
                        mutatedLocals.push(expr.self);
                }
            }
        }, { flatStmts });
    };
    handleMethodCallsMutations();
    const handleAssignmentMutations = () => {
        if (stmt.kind === "statement_assign" ||
            stmt.kind === "statement_augmentedassign") {
            const field = removeSelf(stmt.path);
            if (field) {
                // Field mutations
                mutatedFields.push(field);
            }
            else {
                // Local mutations
                const local = stmt.path;
                if (local.kind === "field_access" || local.kind === "id") {
                    mutatedLocals.push(local);
                }
            }
        }
    };
    handleAssignmentMutations();
    return !mutatedFields.length && !mutatedLocals.length
        ? undefined
        : { mutatedFields, mutatedLocals };
}
exports.collectMutations = collectMutations;
/**
 * Collects names of the mutated elements.
 *
 * For example:
 * - a -> a
 * - self.a -> a
 * - self.object.f1 -> object
 */
function mutationNames(items) {
    return items.flatMap((item) => {
        if (item.kind === "id") {
            return [item.text];
        }
        else if (item.kind === "field_access") {
            const path = (0, imports_2.tryExtractPath)(item);
            return path && path.length >= 2 ? [path[0].text] : [];
        }
        else {
            return [];
        }
    });
}
exports.mutationNames = mutationNames;
/**
 * Set containing information about the locations with some additional information.
 * We need this, since `SrcInfo` objects cannot be trivially compared.
 */
class SrcInfoSet {
    items;
    constructor(pairs) {
        this.items = [];
        if (pairs) {
            pairs.forEach((pair) => this.add(pair));
        }
    }
    add(item) {
        if (!this.has(item)) {
            this.items.push(item);
        }
    }
    has(item) {
        return this.items.some((existingItem) => (0, imports_1.srcInfoEqual)(existingItem[1], item[1]));
    }
    delete(item) {
        const index = this.items.findIndex((existingItem) => (0, imports_1.srcInfoEqual)(existingItem[1], item[1]));
        if (index !== -1) {
            this.items.splice(index, 1);
            return true;
        }
        return false;
    }
    extract() {
        return this.items.slice();
    }
}
exports.SrcInfoSet = SrcInfoSet;
/**
 * Returns true iff the input expression represents a primitive literal.
 */
function isPrimitiveLiteral(expr) {
    return ["null", "boolean", "number", "string"].includes(expr.kind);
}
exports.isPrimitiveLiteral = isPrimitiveLiteral;
/**
 * Checks if the AST of two nodes is equal using the Tact AST comparison API.
 */
function nodesAreEqual(node1, node2) {
    if (node1.kind !== node2.kind)
        return false;
    const clean1 = json_bigint_1.default.parse(json_bigint_1.default.stringify(node1, (key, value) => key === "id" || key === "loc" ? undefined : value));
    const clean2 = json_bigint_1.default.parse(json_bigint_1.default.stringify(node2, (key, value) => key === "id" || key === "loc" ? undefined : value));
    return json_bigint_1.default.stringify(clean1) === json_bigint_1.default.stringify(clean2);
}
exports.nodesAreEqual = nodesAreEqual;
/**
 * Checks if the AST of two lists of statements is equal using the Tact AST comparison API.
 */
function statementsAreEqual(stmts1, stmts2) {
    if (stmts1.length !== stmts2.length)
        return false;
    return stmts1.every((stmt, i) => {
        return nodesAreEqual(stmt, stmts2[i]);
    });
}
exports.statementsAreEqual = statementsAreEqual;
/**
 * Collects declarations of all the contract fields.
 */
function collectFields(contract, { initialized = false } = {}) {
    return contract.declarations.reduce((acc, decl) => {
        if (decl.kind === "field_decl" &&
            (!initialized || decl.initializer !== undefined)) {
            acc.set(decl.name.text, decl);
        }
        return acc;
    }, new Map());
}
exports.collectFields = collectFields;
/**
 * Returns the human-readable name of the function.
 */
function funName(fun) {
    switch (fun.kind) {
        case "contract_init":
            return "init";
        case "receiver":
            return (0, imports_3.prettyPrint)(fun).split("\n")[0].slice(0, -3);
        case "function_def":
            return (0, imports_2.idText)(fun.name);
        default:
            (0, util_1.unreachable)(fun);
    }
}
exports.funName = funName;
/**
 * Collects all the conditions from the conditional, including `if` and `else if` statements.
 */
function collectConditions(node, { nonEmpty = false } = {}) {
    const conditions = nonEmpty
        ? node.trueStatements.length > 0
            ? [node.condition]
            : []
        : [node.condition];
    if (node.falseStatements &&
        node.falseStatements.length === 1 &&
        node.falseStatements[0].kind === "statement_condition") {
        conditions.push(...collectConditions(node.falseStatements[0]));
    }
    return conditions;
}
exports.collectConditions = collectConditions;
/**
 * Collects a chain of method calls.
 *
 * Example:
 *
 * self.field.set(a, b);
 * ^^^^^^^^^^ ^^^^^^^^^
 *    self    calls[0]
 *
 * The return format is the following: `expr.method1().method2()`, where `expr`
 * might be a function call, e.g.:
 *
 * beginCell().loadRef(c).endCell();
 * ^^^^^^^^^^^ ^^^^^^^^^^ ^^^^^^^^^^
 *    self      calls[0]   calls[1]
 *
 * @returns An array of expressions representing the method call chain and the
 *          first receiver that might be an expression creating a callable
 *          object, or undefined if it's not a method call chain.
 */
function getMethodCallsChain(expr) {
    const calls = [];
    let currentExpr = expr;
    while (currentExpr.kind === "method_call") {
        const methodCall = currentExpr;
        calls.push(methodCall);
        currentExpr = methodCall.self;
    }
    return calls.length === 0
        ? undefined
        : { self: currentExpr, calls: calls.reverse() };
}
exports.getMethodCallsChain = getMethodCallsChain;
/**
 * Returns true if the given expression represents a call of the function `name`
 * with `argsNum` arguments.
 */
function isFunctionCall(expr, name, argsNum) {
    return (expr.kind === "static_call" &&
        (0, imports_2.idText)(expr.function) === name &&
        expr.args.length === argsNum);
}
exports.isFunctionCall = isFunctionCall;
/**
 * Returns true if the given expression represents a call of the method `name`
 * with `argsNum` arguments.
 */
function isMethodCall(expr, name, argsNum) {
    return (expr.kind === "method_call" &&
        (0, imports_2.idText)(expr.method) === name &&
        expr.args.length === argsNum);
}
exports.isMethodCall = isMethodCall;
/**
 * Returns true if the given expression is a call of the supported stdlib
 * function or method.
 */
function isStdlibCall(name, expr) {
    const stdlibFunctions = {
        beginCell: 0,
        endCell: 0,
        emptyCell: 0,
        emptySlice: 0,
    };
    const stdlibMethods = {
        storeMaybeRef: 1,
        storeRef: 1,
        loadRef: 0,
    };
    const expectedFunctionArgs = stdlibFunctions[name];
    if (expectedFunctionArgs !== undefined) {
        return isFunctionCall(expr, name, expectedFunctionArgs);
    }
    const expectedMethodArgs = stdlibMethods[name];
    if (expectedMethodArgs !== undefined) {
        return isMethodCall(expr, name, expectedMethodArgs);
    }
    return false;
}
exports.isStdlibCall = isStdlibCall;
/**
 * Size of the Address variable stored in Cell.
 */
exports.ADDRESS_SIZE = 267n;
/**
 * Returns the size of the storage added by the given `.store` method call.
 */
function getConstantStoreSize(call) {
    switch ((0, imports_2.idText)(call.method)) {
        case "storeBool":
        case "storeBit":
            return 1n;
        case "storeCoins": {
            if (call.args.length !== 1)
                return undefined;
            // The serialization size varies from 4 to 124 bits:
            // https://docs.tact-lang.org/book/integers/#serialization-coins
            const value = (0, tact_1.evalToType)(call.args[0], "number");
            if (value !== undefined) {
                const num = (0, imports_1.ensureInt)(value);
                // We use the following logic from ton-core in order to compute the size:
                // https://github.com/ton-org/ton-core/blob/00fa47e03c2a78c6dd9d09e517839685960bc2fd/src/boc/BitBuilder.ts#L212
                const sizeBytes = Math.ceil(num.value.toString(2).length / 8);
                const sizeBits = sizeBytes * 8;
                // 44-bit unsigned big-endian integer storing the byte length of the
                // value provided
                const sizeLength = 4;
                return BigInt(sizeBits + sizeLength);
            }
            // TODO: Return an interval of possible values
            return undefined;
        }
        case "storeAddress":
            return exports.ADDRESS_SIZE;
        case "storeInt":
        case "storeUint": {
            if (call.args.length !== 2)
                return undefined;
            const value = (0, tact_1.evalToType)(call.args[1], "number");
            return value === undefined ? undefined : (0, imports_1.ensureInt)(value).value;
        }
        case "storeBuilder":
        case "storeSlice":
            return undefined;
        default:
            return undefined;
    }
}
exports.getConstantStoreSize = getConstantStoreSize;
/**
 * Returns the size of the storage substrated by the given `.load` method call.
 */
function getConstantLoadSize(call) {
    switch ((0, imports_2.idText)(call.method)) {
        case "loadBool":
        case "loadBit":
            return 1n;
        case "loadCoins": {
            // The size is dynamically loaded from the cell, thus we cannot retrieve it statically:
            // https://github.com/ton-org/ton-core/blob/00fa47e03c2a78c6dd9d09e517839685960bc2fd/src/boc/BitReader.ts#L290
            // TODO: Return an interval of possible values
            return undefined;
        }
        case "loadAddress":
            return exports.ADDRESS_SIZE;
        case "loadInt":
        case "loadUint": {
            if (call.args.length !== 1)
                return undefined;
            const value = (0, tact_1.evalToType)(call.args[0], "number");
            // TODO: Return an interval of possible values
            return value === undefined ? undefined : (0, imports_1.ensureInt)(value).value;
        }
        case "loadBuilder":
        case "loadSlice":
            return undefined;
        default:
            return undefined;
    }
}
exports.getConstantLoadSize = getConstantLoadSize;
exports.SEND_FUNCTIONS = ["send", "nativeSendMessage"];
exports.SEND_METHODS = ["reply", "forward", "notify", "emit"];
/**
 * Determines if the given expression is a 'send' call.
 * @param expr The expression to check.
 * @returns True if the expression is a 'send' call; otherwise, false.
 */
function isSendCall(expr) {
    return ((expr.kind === "static_call" &&
        exports.SEND_FUNCTIONS.includes(expr.function.text)) ||
        (expr.kind === "method_call" &&
            isSelf(expr.self) &&
            exports.SEND_METHODS.includes(expr.method.text)));
}
exports.isSendCall = isSendCall;
/**
 * Checks if a function has the given attribute.
 */
function functionHasAttribute(fun, ...attrs) {
    return fun.attributes.some((attr) => attr.kind === "function_attribute" ? attrs.includes(attr.type) : false);
}
exports.functionHasAttribute = functionHasAttribute;
/**
 * Gets the type name of the self parameter from an `extends` function.
 */
function getExtendsSelfType(fun) {
    if (!functionHasAttribute(fun, "extends"))
        return undefined;
    if (fun.params.length > 0) {
        const firstParam = fun.params[0];
        if (firstParam.name.text === "self" && firstParam.type.kind === "type_id") {
            return firstParam.type.text;
        }
    }
    return undefined;
}
exports.getExtendsSelfType = getExtendsSelfType;
