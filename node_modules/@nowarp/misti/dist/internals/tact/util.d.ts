import { AstExpression, AstId, AstContractInit, AstFieldDecl, AstFunctionDef, AstReceiver, AstContract, AstFieldAccess, AstStatement, AstMethodCall, SrcInfo, AstStatementCondition, AstFunctionAttributeName } from "../../internals/tact/imports";
/**
 * Creates a concise string representation of `SrcInfo`.
 */
export declare function formatPosition(ref?: SrcInfo): string;
/**
 * Returns the accessor name without the leading `self.` part.
 *
 * For example:
 * - `self.a` -> AstId(`a`)
 * - `self.a()` -> AstMethodCall(`a`)
 * - `self.object.f1` -> AstFieldAccess(`object.f1`)
 * - `nonSelf.a` -> undefined
 */
export declare function removeSelf(expr: AstExpression): AstId | AstFieldAccess | undefined;
/**
 * @returns True for self identifiers: `self`.
 */
export declare function isSelf(expr: AstExpression): boolean;
/**
 * @returns True for self access expressions: `self.a`, `self.a.b`.
 */
export declare function isSelfAccess(expr: AstExpression): boolean;
/**
 * @returns True iff `call` is a stdlib method mutating its receiver.
 */
export declare function isStdlibMutationMethod(call: AstMethodCall): boolean;
export type MutatedElement = AstId | AstFieldAccess;
/**
 * Collects mutations local or state mutations within the statements.
 *
 * @param The statement to analyze
 * @param flatStmts If true, only traverse statements at the current level without
 *                  going into nested statements. It should be used when calling this function
 *                  inside one of the iterators.
 * @returns Mutated fields and local identifiers, including nested fields of mutated structure instances
 */
export declare function collectMutations(stmt: AstStatement, { flatStmts }?: Partial<{
    flatStmts: boolean;
}>): {
    mutatedFields: MutatedElement[];
    mutatedLocals: MutatedElement[];
} | undefined;
/**
 * Collects names of the mutated elements.
 *
 * For example:
 * - a -> a
 * - self.a -> a
 * - self.object.f1 -> object
 */
export declare function mutationNames(items: MutatedElement[]): string[];
/**
 * Set containing information about the locations with some additional information.
 * We need this, since `SrcInfo` objects cannot be trivially compared.
 */
export declare class SrcInfoSet<T> {
    private items;
    constructor(pairs?: [T, SrcInfo][]);
    add(item: [T, SrcInfo]): void;
    has(item: [T, SrcInfo]): boolean;
    delete(item: [T, SrcInfo]): boolean;
    extract(): [T, SrcInfo][];
}
/**
 * Returns true iff the input expression represents a primitive literal.
 */
export declare function isPrimitiveLiteral(expr: AstExpression): boolean;
/**
 * Checks if the AST of two nodes is equal using the Tact AST comparison API.
 */
export declare function nodesAreEqual(node1: any, node2: any): boolean;
/**
 * Checks if the AST of two lists of statements is equal using the Tact AST comparison API.
 */
export declare function statementsAreEqual(stmts1: readonly AstStatement[], stmts2: readonly AstStatement[]): boolean;
/**
 * Collects declarations of all the contract fields.
 */
export declare function collectFields(contract: AstContract, { initialized }?: Partial<{
    initialized: boolean;
}>): Map<string, AstFieldDecl>;
/**
 * Returns the human-readable name of the function.
 */
export declare function funName(fun: AstReceiver | AstContractInit | AstFunctionDef): string;
/**
 * Collects all the conditions from the conditional, including `if` and `else if` statements.
 */
export declare function collectConditions(node: AstStatementCondition, { nonEmpty }?: Partial<{
    nonEmpty: boolean;
}>): AstExpression[];
/**
 * Collects a chain of method calls.
 *
 * Example:
 *
 * self.field.set(a, b);
 * ^^^^^^^^^^ ^^^^^^^^^
 *    self    calls[0]
 *
 * The return format is the following: `expr.method1().method2()`, where `expr`
 * might be a function call, e.g.:
 *
 * beginCell().loadRef(c).endCell();
 * ^^^^^^^^^^^ ^^^^^^^^^^ ^^^^^^^^^^
 *    self      calls[0]   calls[1]
 *
 * @returns An array of expressions representing the method call chain and the
 *          first receiver that might be an expression creating a callable
 *          object, or undefined if it's not a method call chain.
 */
export declare function getMethodCallsChain(expr: AstExpression): {
    self: AstExpression;
    calls: AstMethodCall[];
} | undefined;
/**
 * Returns true if the given expression represents a call of the function `name`
 * with `argsNum` arguments.
 */
export declare function isFunctionCall(expr: AstExpression, name: string, argsNum: number): boolean;
/**
 * Returns true if the given expression represents a call of the method `name`
 * with `argsNum` arguments.
 */
export declare function isMethodCall(expr: AstExpression, name: string, argsNum: number): boolean;
/**
 * Returns true if the given expression is a call of the supported stdlib
 * function or method.
 */
export declare function isStdlibCall(name: string, expr: AstExpression): boolean;
/**
 * Size of the Address variable stored in Cell.
 */
export declare const ADDRESS_SIZE = 267n;
/**
 * Returns the size of the storage added by the given `.store` method call.
 */
export declare function getConstantStoreSize(call: AstMethodCall): bigint | undefined;
/**
 * Returns the size of the storage substrated by the given `.load` method call.
 */
export declare function getConstantLoadSize(call: AstMethodCall): bigint | undefined;
export declare const SEND_FUNCTIONS: string[];
export declare const SEND_METHODS: string[];
/**
 * Determines if the given expression is a 'send' call.
 * @param expr The expression to check.
 * @returns True if the expression is a 'send' call; otherwise, false.
 */
export declare function isSendCall(expr: AstExpression): boolean;
/**
 * Checks if a function has the given attribute.
 */
export declare function functionHasAttribute(fun: AstFunctionDef, ...attrs: (AstFunctionAttributeName | "get")[]): boolean;
/**
 * Gets the type name of the self parameter from an `extends` function.
 */
export declare function getExtendsSelfType(fun: AstFunctionDef): string | undefined;
