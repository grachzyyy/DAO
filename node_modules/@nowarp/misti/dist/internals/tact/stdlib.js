"use strict";
/**
 * This module contains definitions from the Tact stdlib  and logic for
 * accessing the stdlib in Misti.
 *
 * It should be reviewed before each Tact update to determine if updates are needed.
 *
 * @packageDocumentation
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.definedInStdlib = exports.getStdlibPath = exports.getDefaultStdlibPathElements = exports.BROWSER_STDLIB_PATH_ELEMENTS = exports.BROWSER_PATH_SEP = exports.STRING_MUTATING_METHODS = exports.BUILDER_MUTATING_METHODS = exports.MAP_MUTATING_METHODS = exports.PRG_SAFE_USE_FUNCTIONS = exports.PRG_NATIVE_USE_FUNCTIONS = exports.PRG_INIT_FUNCTIONS = exports.DATETIME_FUNCTIONS = void 0;
const util_1 = require("../util");
const path_1 = __importDefault(require("path"));
/**
 * Stdlib functions that access datetime functions.
 */
exports.DATETIME_FUNCTIONS = new Set(["now", "timestamp"]);
/**
 * Stdlib functions that initialize PRG seed.
 */
exports.PRG_INIT_FUNCTIONS = new Set([
    "nativePrepareRandom",
    "nativeRandomize",
    "nativeRandomizeLt",
]);
/**
 * Native stdlib functions that use PRG.
 */
exports.PRG_NATIVE_USE_FUNCTIONS = new Set([
    "nativeRandom",
    "nativeRandomInterval",
]);
/**
 * Safe Tact wrapper functions that use PRG.
 */
exports.PRG_SAFE_USE_FUNCTIONS = new Set(["random", "randomInt"]);
/**
 * Map methods that mutate state.
 * See: https://docs.tact-lang.org/book/maps/
 */
exports.MAP_MUTATING_METHODS = new Set([
    "set",
    "del",
    "replace",
    "replaceGet",
]);
/**
 * Builder methods mutating state.
 * https://github.com/tact-lang/tact/blob/08133e8418f3c6dcb49229b45cfeb7dd261bbe1f/stdlib/std/cells.tact#L75
 */
exports.BUILDER_MUTATING_METHODS = new Set([
    "storeRef",
    "storeBits",
    "storeInt",
    "storeUint",
    "storeBool",
    "storeBit",
    "storeCoins",
    "storeAddress",
    "skipBits",
]);
/**
 * String mutating methods.
 * https://github.com/tact-lang/tact/blob/08133e8418f3c6dcb49229b45cfeb7dd261bbe1f/stdlib/std/text.tact#L18
 */
exports.STRING_MUTATING_METHODS = new Set(["append"]);
/**
 * Path separator used in paths in the browser environment.
 */
exports.BROWSER_PATH_SEP = "/";
/**
 * Path to browser starting from the VFS root: `/`.
 */
exports.BROWSER_STDLIB_PATH_ELEMENTS = [
    exports.BROWSER_PATH_SEP,
    "node_modules",
    "@tact-lang",
    "compiler",
    "stdlib",
    "stdlib",
];
/**
 * @returns A mandatory part of the file path to stdlib if using the default path.
 */
function getDefaultStdlibPathElements() {
    return (0, util_1.isBrowser)()
        ? exports.BROWSER_STDLIB_PATH_ELEMENTS
        : [
            ...path_1.default
                .dirname(require.resolve("@tact-lang/compiler/package.json"))
                .split(path_1.default.sep)
                .filter(Boolean)
                .slice(-2),
            "dist",
            "stdlib",
            "stdlib",
        ];
}
exports.getDefaultStdlibPathElements = getDefaultStdlibPathElements;
/**
 * Returns an absolute path to Tact stdlib distributed within the tact compiler
 * package.
 */
function getStdlibPath() {
    return (0, util_1.isBrowser)()
        ? exports.BROWSER_STDLIB_PATH_ELEMENTS.join(exports.BROWSER_PATH_SEP)
        : path_1.default.join(path_1.default.dirname(require.resolve("@tact-lang/compiler/package.json")), "dist", "stdlib", "stdlib");
}
exports.getStdlibPath = getStdlibPath;
/**
 * Checks if a given location or file path is defined in the Tact stdlib.
 * @param ctx MistiContext object
 * @param locOrPath SrcInfo object or string file path
 * @returns boolean indicating if the location is in the stdlib
 */
function definedInStdlib(ctx, locOrPath) {
    const stdlibPath = ctx.config.tactStdlibPath;
    const pathElements = stdlibPath === undefined
        ? getDefaultStdlibPathElements()
        : stdlibPath.split(path_1.default.sep).filter((part) => part !== "");
    const filePath = typeof locOrPath === "string" ? locOrPath : locOrPath.file;
    return (filePath !== null &&
        (filePath.startsWith("@stdlib") || (0, util_1.hasSubdirs)(filePath, pathElements)));
}
exports.definedInStdlib = definedInStdlib;
