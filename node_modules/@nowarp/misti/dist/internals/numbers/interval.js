"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Interval = void 0;
const num_1 = require("./num");
/**
 * Represents a numeric interval [low, high] in abstract interpretation.
 * Supports basic arithmetic operations and comparisons on intervals.
 *
 * Special cases:
 * - FULL: (-∞, +∞) represents the interval containing all numbers
 * - EMPTY: Empty interval (∅) represents an invalid or undefined interval
 *
 * @remarks
 * This class implements interval arithmetic for abstract interpretation,
 * following standard interval arithmetic rules for operations like
 * addition, multiplication, division etc.
 *
 * @throws Error when performing division by an interval containing zero
 */
class Interval {
    low;
    high;
    constructor(low, high) {
        this.low = low;
        this.high = high;
    }
    static FULL = new Interval(num_1.Num.m(), num_1.Num.p());
    static EMPTY = new Interval(num_1.Num.p(), num_1.Num.m());
    /**
     * Creates an interval `[a, a]`.
     */
    static fromNum(a) {
        const n = num_1.Num.int(a);
        return new Interval(n, n);
    }
    /**
     * Creates an interval `[a, b]`.
     */
    static fromNums(a, b) {
        const an = num_1.Num.int(a);
        const bn = num_1.Num.int(b);
        return new Interval(an, bn);
    }
    isFull() {
        return this.low.kind === "MInf" && this.high.kind === "PInf";
    }
    isEmpty() {
        return this.low.kind === "PInf" && this.high.kind === "MInf";
    }
    /**
     * Checks if this interval is less than or equal to other interval.
     */
    leq(other) {
        if (this.isEmpty())
            return true; // empty interval is less than everything
        if (other.isEmpty())
            return false; // nothing is less than empty (except empty)
        if (other.isFull())
            return true; // everything is less than full interval
        if (this.isFull())
            return false; // full interval is not less than anything (except full)
        return (num_1.Num.compare(this.low, other.low) <= 0 &&
            num_1.Num.compare(this.high, other.high) <= 0);
    }
    eq(other) {
        return (num_1.Num.compare(this.low, other.low) == 0n &&
            num_1.Num.compare(this.high, other.high) == 0n);
    }
    plus(other) {
        return new Interval(num_1.Num.add(this.low, other.low), num_1.Num.add(this.high, other.high));
    }
    inv() {
        return new Interval(num_1.Num.negate(this.high), num_1.Num.negate(this.low));
    }
    minus(other) {
        return this.plus(other.inv());
    }
    times(other) {
        const products = [
            num_1.Num.multiply(this.low, other.low),
            num_1.Num.multiply(this.low, other.high),
            num_1.Num.multiply(this.high, other.low),
            num_1.Num.multiply(this.high, other.high),
        ];
        return new Interval(num_1.Num.min(...products), num_1.Num.max(...products));
    }
    /**
     * Abstract division.
     *
     * @returns A division result or a full interval if attempting to divide by zero.
     */
    div(other) {
        if (other.containsZero()) {
            return Interval.FULL;
        }
        const quotients = [
            num_1.Num.divide(this.low, other.low),
            num_1.Num.divide(this.low, other.high),
            num_1.Num.divide(this.high, other.low),
            num_1.Num.divide(this.high, other.high),
        ];
        return new Interval(num_1.Num.min(...quotients), num_1.Num.max(...quotients));
    }
    containsZero() {
        return (num_1.Num.compare(this.low, num_1.Num.int(0)) <= 0 &&
            num_1.Num.compare(this.high, num_1.Num.int(0)) >= 0);
    }
    equals(other) {
        if (this.isFull() || other.isFull()) {
            return Interval.FULL;
        }
        if (this.low.kind === "IntNum" &&
            this.low === this.high &&
            other.low.kind === "IntNum" &&
            other.low === other.high &&
            this.low.value === other.low.value) {
            return Interval.fromNum(1);
        }
        return new Interval(num_1.Num.int(0), num_1.Num.int(1));
    }
    toString() {
        if (this.isFull())
            return "(-∞, +∞)";
        if (this.isEmpty())
            return "∅";
        if (num_1.Num.compare(this.low, this.high) === 0n)
            return this.low.toString();
        return `(${this.low.toString()}, ${this.high.toString()})`;
    }
    clone() {
        return new Interval(this.low, this.high);
    }
}
exports.Interval = Interval;
