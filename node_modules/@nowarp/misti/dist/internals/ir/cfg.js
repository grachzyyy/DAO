"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSuccessors = exports.getPredecessors = exports.Cfg = exports.BasicBlock = exports.Edge = void 0;
const indices_1 = require("./indices");
const exceptions_1 = require("../exceptions");
/**
 * Represents an edge in a Control Flow Graph (CFG), connecting two basic blocks.
 * Each edge signifies a potential flow of control from one statement to another.
 *
 * @param src The index of the source block from which the control flow originates.
 * @param dst The index of the destination block to which the control flow goes.
 */
class Edge {
    src;
    dst;
    idx;
    constructor(src, dst) {
        this.src = src;
        this.dst = dst;
        this.idx = indices_1.IdxGenerator.next("cfg_edge");
    }
}
exports.Edge = Edge;
/**
 * Represents a basic block in a CFG, corresponding to a single
 * statement in the source code.
 * Basic blocks are connected by edges that represent the flow of control between statements.
 *
 * @param stmtID The unique identifier of the statement this block represents.
 * @param kind Kind of the basic block representing ways it behave.
 * @param srcEdges A set of indices for edges incoming to this block, representing control flows leading into this statement.
 * @param dstEdges A set of indices for edges outgoing from this block, representing potential control flows out of this statement.
 */
class BasicBlock {
    stmtID;
    kind;
    srcEdges;
    dstEdges;
    idx;
    constructor(stmtID, kind, srcEdges = new Set(), dstEdges = new Set()) {
        this.stmtID = stmtID;
        this.kind = kind;
        this.srcEdges = srcEdges;
        this.dstEdges = dstEdges;
        this.idx = indices_1.IdxGenerator.next("cfg_bb");
    }
    /**
     * Returns true iff this basic block terminates control flow.
     */
    isExit() {
        return this.kind.kind === "exit";
    }
}
exports.BasicBlock = BasicBlock;
/**
 * Describes the intraprocedural CFG that corresponds to a function or method within the project.
 */
class Cfg {
    name;
    id;
    kind;
    origin;
    nodes;
    edges;
    ref;
    /**
     * The unique identifier of this CFG among the compilation unit it belongs to.
     */
    idx;
    /**
     * Map from unique basic block indices to array indices in the `this.bbs`.
     */
    bbsMap;
    /**
     * Map from unique edge indices to array indices in the `this.edges`.
     */
    edgesMap;
    /**
     * Creates an instance of CFG.
     * @param name The name of the function or method this CFG represents.
     * @param id AST ID.
     * @param kind Indicates whether this CFG represents a standalone function or a method or a receive method belonging to a contract.
     * @param origin Indicates whether the function was defined in users code or in standard library.
     * @param nodes Map of block indices to basic blocks in the CFG that come in the reverse order.
     * @param edges Map of edge indices to edges in the CFG that come in the reverse order.
     * @param ref AST reference that corresponds to the function definition.
     * @param idx An optional unique index. If not set, a new one will be chosen automatically.
     */
    constructor(name, id, kind, origin, nodes, edges, ref, idx = undefined) {
        this.name = name;
        this.id = id;
        this.kind = kind;
        this.origin = origin;
        this.nodes = nodes;
        this.edges = edges;
        this.ref = ref;
        this.idx = idx ? idx : indices_1.IdxGenerator.next("cfg");
        this.bbsMap = new Map();
        this.initializeMapping(this.bbsMap, nodes);
        this.edgesMap = new Map();
        this.initializeMapping(this.edgesMap, edges);
    }
    initializeMapping(mapping, entries) {
        entries.forEach((entry, arrayIdx) => {
            mapping.set(entry.idx, arrayIdx);
        });
    }
    /**
     * Retrieves a basic block from the CFG based on its unique index.
     * @param idx The index of the basic block to retrieve.
     * @returns The basic block if found, otherwise undefined.
     */
    getBasicBlock(idx) {
        const bbsIdx = this.bbsMap.get(idx);
        return bbsIdx === undefined ? undefined : this.nodes[bbsIdx];
    }
    /**
     * Retrieves an Edge from the CFG based on its unique index.
     * @param idx The index of the edge to retrieve.
     * @returns The Edge if found, otherwise undefined.
     */
    getEdge(idx) {
        const edgesIdx = this.edgesMap.get(idx);
        return edgesIdx === undefined ? undefined : this.edges[edgesIdx];
    }
    traverseBasicBlocks(edgeIdxs, isSrc) {
        return Array.from(edgeIdxs).reduce((acc, srcIdx) => {
            if (acc === undefined) {
                return undefined;
            }
            const edge = this.getEdge(srcIdx);
            if (edge === undefined) {
                return undefined;
            }
            const targetBB = this.getBasicBlock(isSrc ? edge.src : edge.dst);
            if (targetBB === undefined) {
                return undefined;
            }
            acc.push(targetBB);
            return acc;
        }, []);
    }
    /**
     * Returns successors for the given block.
     * @returns A list of predecessor blocks or `undefined` if any of the indices cannot be found in this CFG.
     */
    getSuccessors(bbIdx) {
        const bb = this.getBasicBlock(bbIdx);
        return bb === undefined
            ? undefined
            : this.traverseBasicBlocks(bb.dstEdges, false);
    }
    /**
     * Returns predecessors for the given block.
     * @returns A list of predecessor blocks or `undefined` if any of the indices cannot be found in this CFG.
     */
    getPredecessors(bbIdx) {
        const bb = this.getBasicBlock(bbIdx);
        return bb === undefined
            ? undefined
            : this.traverseBasicBlocks(bb.srcEdges, true);
    }
    /**
     * Iterates over all basic blocks in a CFG, applying a callback to each node.
     * The callback can perform any operation, such as analyzing or transforming the basic block.
     * @param astStore The store containing the AST nodes.
     * @param callback The function to apply to each block.
     */
    forEachBasicBlock(astStore, callback) {
        this.nodes.forEach((cfgBB) => {
            const astNode = astStore.getStatement(cfgBB.stmtID);
            if (astNode) {
                callback(astNode, cfgBB);
            }
            else {
                throw exceptions_1.InternalException.make(`Cannot find a statement: #${cfgBB.stmtID}`);
            }
        });
    }
    /**
     * Iterates over all edges in a CFG, applying a callback to each edge.
     * @param callback The function to apply to each edge.
     */
    forEachEdge(callback) {
        this.edges.forEach((cfgEdge) => {
            callback(cfgEdge);
        });
    }
    /**
     * Returns a list of all exit nodes in the CFG.
     * @returns An array of `BasicBlock` that are exit nodes.
     */
    getExitNodes() {
        return this.nodes.filter((bb) => bb.isExit());
    }
}
exports.Cfg = Cfg;
/**
 * An utility function that extracts basic block's predecessors.
 */
function getPredecessors(cfg, bb) {
    const predecessors = cfg.getPredecessors(bb.idx);
    if (predecessors === undefined) {
        throw exceptions_1.InternalException.make(`Incorrect definition in the Cfg: BB #${bb.idx} has an undefined predecessor`);
    }
    return predecessors;
}
exports.getPredecessors = getPredecessors;
/**
 * An utility function that extracts basic blocks's successors.
 */
function getSuccessors(cfg, bb) {
    const successors = cfg.getSuccessors(bb.idx);
    if (successors === undefined) {
        throw exceptions_1.InternalException.make(`Incorrect definition in the Cfg: BB #${bb.idx} has an undefined predecessor`);
    }
    return successors;
}
exports.getSuccessors = getSuccessors;
