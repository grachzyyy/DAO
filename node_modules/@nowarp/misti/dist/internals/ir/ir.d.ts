/**
 * Defined the Intermediate Representation (IR) for Tact used in analysis.
 *
 * @packageDocumentation
 */
import { CfgIdx, ContractName, FunctionName, ProjectName } from ".";
import { AstStore } from "./astStore";
import { CallGraph } from "./callGraph";
import { BasicBlock, Cfg } from "./cfg";
import { ImportGraph } from "./imports";
import { AstStatement, SrcInfo } from "../../internals/tact/imports";
export type TraitContractIdx = number & {
    readonly __brand: unique symbol;
};
/**
 * Represents a Compilation Unit, encapsulating the information necessary for
 * analyzing a single Tact project.
 */
export declare class CompilationUnit {
    readonly projectName: ProjectName;
    readonly ast: AstStore;
    readonly imports: ImportGraph;
    readonly callGraph: CallGraph;
    readonly functions: Map<CfgIdx, Cfg>;
    private readonly contracts;
    private readonly traits;
    /**
     * Creates an instance of CompilationUnit.
     * @param projectName The name of the project this Compilation Unit belongs to.
     * @param ast The AST of the project.
     * @param imports A graph showing the connections between project files.
     * @param functions A mapping from unique IDs of free functions to their CFGs.
     * @param contracts A mapping contract ids to their entries.
     * @param traits A mapping trait ids to their entries.
     */
    constructor(projectName: ProjectName, ast: AstStore, imports: ImportGraph, callGraph: CallGraph, functions: Map<CfgIdx, Cfg>, contracts: Map<TraitContractIdx, Contract>, traits: Map<TraitContractIdx, Trait>);
    getContracts(): Map<TraitContractIdx, Contract>;
    getTraits({ includeStdlib, }?: Partial<{
        includeStdlib: boolean;
    }>): Map<TraitContractIdx, Trait>;
    getContractsTraits({ includeStdlib, }?: Partial<{
        includeStdlib: boolean;
    }>): Map<TraitContractIdx, TraitContract>;
    /**
     * Looks for a CFG with a specific index.
     * @returns Found CFG or `undefined` if not found.
     */
    findCfgByIdx(idx: CfgIdx): Cfg | undefined;
    /**
     * Looks for a Cfg for a function node with a specific name.
     * @returns Found Cfg or `undefined` if not found.
     */
    findFunctionCFGByName(name: FunctionName): Cfg | undefined;
    /**
     * Looks for a Cfg for a method node with a specific name.
     * @returns Found Cfg or `undefined` if not found.
     */
    findMethodCFGByName(contractName: ContractName, methodName: FunctionName): Cfg | undefined;
    /**
     * Iterates over all CFGs in a Compilation Unit, and applies a callback to Cfg.
     *
     * @param callback The function to apply to each Cfg.
     */
    forEachCFG(callback: (cfg: Cfg) => void, { includeStdlib }?: Partial<{
        includeStdlib: boolean;
    }>): void;
    /**
     * Performs a fold operation over all CFGs in the Compilation Unit.
     *
     * @param init The initial value of the accumulator.
     * @param callback A function that takes the current accumulator and a Cfg,
     *                 and returns a new accumulator value.
     * @returns The final accumulated value.
     */
    foldCFGs<T>(init: T, callback: (acc: T, cfg: Cfg) => T, { includeStdlib }?: Partial<{
        includeStdlib: boolean;
    }>): T;
    /**
     * Iterates over all CFGs in a Compilation Unit, and applies a callback to each
     * basic block in every Cfg.
     *
     * @param astStore The store containing the AST nodes.
     * @param callback The function to apply to each BB within each Cfg.
     */
    forEachBasicBlock(astStore: AstStore, callback: (cfg: Cfg, node: BasicBlock, stmt: AstStatement) => void, { includeStdlib }?: Partial<{
        includeStdlib: boolean;
    }>): void;
}
/**
 * Base class representing a common structure for contracts and traits.
 */
export declare abstract class TraitContract {
    name: ContractName;
    methods: Map<CfgIdx, Cfg>;
    loc: SrcInfo;
    /**
     * The unique identifier of this entity among the compilation unit it belongs to.
     */
    idx: TraitContractIdx;
    constructor(name: ContractName, methods: Map<CfgIdx, Cfg>, loc: SrcInfo, idx?: TraitContractIdx | undefined);
    /**
     * Determines if this is a contract or a trait.
     */
    abstract get kind(): "contract" | "trait";
}
/**
 * Represents a smart contract with full implementation capabilities.
 */
export declare class Contract extends TraitContract {
    get kind(): "contract";
}
/**
 * Represents a trait (interface with optional method implementations).
 */
export declare class Trait extends TraitContract {
    get kind(): "trait";
}
