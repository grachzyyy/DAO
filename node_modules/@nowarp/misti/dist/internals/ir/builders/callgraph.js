"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TactCallGraphBuilder = void 0;
const tact_1 = require("../../tact/");
const imports_1 = require("../../tact/imports");
const util_1 = require("../../util");
const callGraph_1 = require("../callGraph");
class TactCallGraphBuilder {
    astStore;
    nodeMap = new Map();
    astIdToNodeId = new Map();
    nameToNodeId = new Map();
    edgesMap = new Map();
    logger;
    constructor(ctx, astStore) {
        this.astStore = astStore;
        this.logger = ctx.logger;
    }
    static make(ctx, astStore) {
        return new TactCallGraphBuilder(ctx, astStore);
    }
    /**
     * Builds the call graph using data from the AST store.
     * @returns The constructed `CallGraph`.
     */
    build() {
        this.astStore
            .getProgramEntries({ includeStdlib: true })
            .forEach((entry) => {
            if (entry.kind === "contract" || entry.kind === "trait") {
                const contract = entry;
                const contractName = contract.name.text;
                contract.declarations.forEach((decl) => {
                    this.addContractDeclarationToGraph(decl, contractName);
                });
            }
            else if (entry.kind === "function_def") {
                const contractName = (0, tact_1.getExtendsSelfType)(entry);
                this.addFunctionToGraph(entry, contractName);
            }
        });
        this.analyzeFunctionCalls();
        return new callGraph_1.CallGraph(this.nodeMap, this.astIdToNodeId, this.nameToNodeId, this.edgesMap);
    }
    /**
     * Adds a contract declaration (function, receiver, or initializer) to the graph.
     * @param declaration The declaration to add.
     * @param contractName The name of the contract the declaration belongs to.
     */
    addContractDeclarationToGraph(declaration, contractName) {
        switch (declaration.kind) {
            case "asm_function_def":
            case "function_def":
            case "contract_init":
            case "receiver":
                this.addFunctionToGraph(declaration, contractName);
            default:
                break; // do nothing
        }
    }
    /**
     * Adds a function node to the graph.
     * @param contractName The optional contract name for namespacing.
     */
    addFunctionToGraph(func, contractName) {
        const funcName = this.getFunctionName(func, contractName);
        const node = new callGraph_1.CGNode(func, funcName, this.logger);
        this.nodeMap.set(node.idx, node);
        this.nameToNodeId.set(funcName, node.idx);
        this.astIdToNodeId.set(func.id, node.idx);
    }
    /**
     * Extracts the function name based on its type and optional contract name.
     * @param contractName The optional contract name.
     * @returns Fully qualified function name.
     */
    getFunctionName(func, contractName) {
        switch (func.kind) {
            case "asm_function_def":
                return contractName
                    ? `asm_${contractName}::${func.name.text}`
                    : `asm_${func.name.text}`;
            case "function_def":
                return contractName
                    ? `${contractName}::${func.name.text}`
                    : func.name.text;
            case "contract_init":
                return contractName
                    ? `${contractName}::contract_init_${func.id}`
                    : `contract_init_${func.id}`;
            case "receiver":
                return contractName
                    ? `${contractName}::receiver_${func.id}`
                    : `receiver_${func.id}`;
            default:
                (0, util_1.unreachable)(func);
        }
    }
    /**
     * Analyzes the AST for function calls and adds edges between caller and callee nodes.
     * Additionally, sets flags on nodes based on their properties (e.g., if they call 'send').
     */
    analyzeFunctionCalls() {
        for (const entry of this.astStore.getProgramEntries()) {
            if (entry.kind === "contract" || entry.kind === "trait") {
                for (const declaration of entry.declarations) {
                    if (declaration.kind === "function_def" ||
                        declaration.kind === "contract_init" ||
                        declaration.kind === "receiver") {
                        const func = declaration;
                        const funcNodeId = this.astIdToNodeId.get(func.id);
                        if (funcNodeId !== undefined) {
                            const funcNode = this.nodeMap.get(funcNodeId);
                            if (!funcNode)
                                continue;
                            func.statements.forEach((stmt) => {
                                this.processStatement(stmt, funcNodeId, (0, imports_1.idText)(entry.name));
                            });
                        }
                    }
                }
            }
            else if (entry.kind === "function_def") {
                const funcNodeId = this.astIdToNodeId.get(entry.id);
                if (funcNodeId !== undefined) {
                    const funcNode = this.nodeMap.get(funcNodeId);
                    if (!funcNode)
                        continue;
                    entry.statements.forEach((stmt) => {
                        this.processStatement(stmt, funcNodeId, (0, tact_1.getExtendsSelfType)(entry));
                    });
                }
            }
        }
    }
    /**
     * Processes a single statement, identifying assignments and other statements.
     * Also detects effects and sets corresponding flags on the function node.
     * @param stmt The statement to process.
     * @param callerId The node ID of the calling function.
     * @param contractName Name of the processed contract, if applicable.
     */
    processStatement(stmt, callerId, contractName) {
        const funcNode = this.nodeMap.get(callerId);
        if (!funcNode)
            return;
        const modifiedFields = findStateWriteNames(stmt);
        if (modifiedFields !== undefined) {
            funcNode.addEffect(callGraph_1.Effect.StateWrite, modifiedFields);
        }
        if (stmt.kind === "statement_assign" ||
            stmt.kind === "statement_augmentedassign") {
            this.processExpression(stmt.expression, callerId, contractName);
        }
        else
            (0, tact_1.forEachExpression)(stmt, (expr) => {
                this.processExpression(expr, callerId, contractName);
            });
    }
    /**
     * Processes calls in expressions building the CG.
     * @param expr The expression to process.
     * @param callerId The node ID of the calling function.
     * @param currentContractName The name of the contract, if applicable.
     */
    processExpression(expr, callerId, currentContractName) {
        // Connect CG nodes
        if (expr.kind === "static_call" || expr.kind === "method_call") {
            const functionName = callGraph_1.CallGraph.getFunctionCallName(expr, currentContractName);
            if (functionName) {
                const calleeId = this.findOrAddFunction(functionName);
                this.addEdge(callerId, calleeId);
            }
        }
        // Add effects to the caller node
        const funcNode = this.nodeMap.get(callerId);
        if (!funcNode)
            return;
        if (expr.kind === "static_call") {
            const functionName = (0, imports_1.idText)(expr.function);
            if (tact_1.DATETIME_FUNCTIONS.has(functionName))
                funcNode.addEffect(callGraph_1.Effect.AccessDatetime);
            else if (tact_1.PRG_NATIVE_USE_FUNCTIONS.has(functionName) ||
                tact_1.PRG_SAFE_USE_FUNCTIONS.has(functionName))
                funcNode.addEffect(callGraph_1.Effect.PrgUse);
            else if (tact_1.PRG_INIT_FUNCTIONS.has(functionName))
                funcNode.addEffect(callGraph_1.Effect.PrgSeedInit);
        }
        if ((0, tact_1.isSendCall)(expr))
            funcNode.addEffect(callGraph_1.Effect.Send);
        const readFieldName = findFieldName(expr);
        if (readFieldName !== undefined) {
            funcNode.addEffect(callGraph_1.Effect.StateRead, [readFieldName]);
        }
    }
    /**
     * Finds or creates a function node in the graph by its name.
     * @param name The name of the function.
     * @returns The node ID of the existing or newly created function.
     */
    findOrAddFunction(name) {
        const nodeId = this.nameToNodeId.get(name);
        if (nodeId !== undefined) {
            return nodeId;
        }
        const newNode = new callGraph_1.CGNode(undefined, name, this.logger);
        this.nodeMap.set(newNode.idx, newNode);
        this.nameToNodeId.set(name, newNode.idx);
        return newNode.idx;
    }
    /**
     * Adds a directed edge between two nodes in the call graph.
     * @param src The source node ID.
     * @param dst The destination node ID.
     */
    addEdge(src, dst) {
        const srcNode = this.nodeMap.get(src);
        const dstNode = this.nodeMap.get(dst);
        if (srcNode && dstNode) {
            const edge = new callGraph_1.CGEdge(src, dst);
            this.edgesMap.set(edge.idx, edge);
            srcNode.outEdges.add(edge.idx);
            dstNode.inEdges.add(edge.idx);
        }
        else {
            this.logger.warn(`Cannot add edge from ${src} to ${dst}: node(s) not found.`);
        }
    }
}
exports.TactCallGraphBuilder = TactCallGraphBuilder;
/**
 * Returns name of the field if `expr` represents its read access e.g.:
 * - `self.<field>`
 * - `self.<field_struct>.<whatever_field_access>`
 *
 * It is called from a recursive AST iterator, thus, we don't have to implement
 * recursion inside.
 */
function findFieldName(expr) {
    if (expr.kind === "field_access") {
        const path = (0, imports_1.tryExtractPath)(expr);
        return path !== null && path.length > 1 && (0, imports_1.isSelfId)(path[0])
            ? (0, imports_1.idText)(path[1])
            : undefined;
    }
    return undefined;
}
function isMutatingMethod(method) {
    return (tact_1.MAP_MUTATING_METHODS.has(method) ||
        tact_1.STRING_MUTATING_METHODS.has(method) ||
        tact_1.BUILDER_MUTATING_METHODS.has(method));
}
/**
 * Returns name of the field from patterns like:
 * - `self.<field>.<mutating_method>()`
 * - `self.<field>.<whatever>.<mutating_method>().<whatever>`
 */
function findFieldMutatingState(expr) {
    const chain = (0, tact_1.getMethodCallsChain)(expr);
    return chain !== undefined &&
        chain.calls.length > 1 &&
        (0, tact_1.isSelf)(chain.self) &&
        chain.calls.some((m) => isMutatingMethod((0, imports_1.idText)(m.method)))
        ? findFieldName(chain.self)
        : undefined;
}
/**
 * Returns names of fields if `expr` represents their modification.
 */
function findStateWriteNames(stmt) {
    if (stmt.kind === "statement_assign" ||
        stmt.kind === "statement_augmentedassign") {
        const name = findFieldName(stmt.path);
        return name ? [name] : undefined;
    }
    const methodAccesses = (0, tact_1.foldExpressions)(stmt, (acc, expr) => {
        if (expr.kind === "method_call") {
            const fieldName = findFieldMutatingState(expr);
            if (fieldName)
                methodAccesses.add(fieldName);
        }
        return acc;
    }, new Set());
    return methodAccesses.size !== 0 ? Array.from(methodAccesses) : undefined;
}
