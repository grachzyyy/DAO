"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AstStoreBuilder = void 0;
const __1 = require("..");
const exceptions_1 = require("../../exceptions");
const imports_1 = require("../../tact/imports");
const stdlib_1 = require("../../tact/stdlib");
const util_1 = require("../../util");
/**
 * Transforms AstStore to AstStore.
 */
class AstStoreBuilder {
    ctx;
    ast;
    programEntries = new Map();
    stdlibIds = new Set();
    /** Items defined within contracts and traits */
    contractEntries = new Map();
    functionNames = new Map();
    functions = new Map();
    constants = new Map();
    contracts = new Map();
    nativeFunctions = new Map();
    asmFunctions = new Map();
    primitives = new Map();
    structs = new Map();
    messages = new Map();
    traits = new Map();
    statements = new Map();
    constructor(ctx, ast) {
        this.ctx = ctx;
        this.ast = ast;
        this.processAstElements(this.ast.functions, this.processFunctionElement);
        this.processAstElements(this.ast.constants, this.processConstantElement);
        this.processAstElements(this.ast.types, this.processType);
    }
    static make(ctx, ast) {
        return new AstStoreBuilder(ctx, ast);
    }
    processAstElements(elements, processor) {
        elements.forEach((element) => {
            const filename = element.loc.file;
            if (filename === null)
                return;
            const elements = this.programEntries.get(filename);
            if (elements) {
                elements.add(element.id);
            }
            else {
                this.programEntries.set(filename, new Set([element.id]));
            }
            if ((0, stdlib_1.definedInStdlib)(this.ctx, element.loc)) {
                this.stdlibIds.add(element.id);
            }
            processor.call(this, element);
        });
    }
    processFunctionElement(func) {
        switch (func.kind) {
            case "function_def":
                this.processFunction(func, undefined);
                break;
            case "asm_function_def":
                this.processAsmFunction(func, undefined);
                break;
            case "native_function_decl":
                this.processNativeFunction(func);
                break;
            default:
                (0, util_1.unreachable)(func);
        }
    }
    processConstantElement(constant) {
        this.constants.set(constant.id, constant);
    }
    build() {
        return new __1.AstStore(this.stdlibIds, this.contractEntries, this.programEntries, this.functionNames, this.functions, this.constants, this.contracts, this.nativeFunctions, this.asmFunctions, this.primitives, this.structs, this.messages, this.traits, this.statements);
    }
    processType(type) {
        switch (type.kind) {
            case "primitive_type_decl":
                this.primitives.set(type.id, type);
                break;
            case "struct_decl":
                this.structs.set(type.id, type);
                break;
            case "message_decl":
                this.messages.set(type.id, type);
                break;
            case "trait":
                this.processTrait(type);
                break;
            case "contract":
                this.processContract(type);
                break;
            default:
                (0, util_1.unreachable)(type);
        }
    }
    processTrait(trait) {
        this.traits.set(trait.id, trait);
        const traitName = (0, imports_1.idText)(trait.name);
        for (const decl of trait.declarations) {
            this.addContractEntry(trait.id, decl.id);
            switch (decl.kind) {
                case "field_decl":
                    // Do nothing, as they are accessible through trait definitions
                    break;
                case "function_def":
                case "receiver":
                    this.processFunction(decl, traitName);
                    break;
                case "asm_function_def":
                    this.processAsmFunction(decl, traitName);
                    break;
                case "constant_def":
                    this.constants.set(decl.id, decl);
                    break;
                case "constant_decl":
                case "function_decl":
                    break;
                default:
                    (0, util_1.unreachable)(decl);
            }
        }
    }
    processContract(contract) {
        this.contracts.set(contract.id, contract);
        const contractName = (0, imports_1.idText)(contract.name);
        for (const decl of contract.declarations) {
            this.addContractEntry(contract.id, decl.id);
            switch (decl.kind) {
                case "field_decl":
                    // Do nothing, as they are accessible through contract definitions
                    break;
                case "function_def":
                case "contract_init":
                case "receiver":
                    this.processFunction(decl, contractName);
                    break;
                case "asm_function_def":
                    this.processAsmFunction(decl, contractName);
                    break;
                case "constant_def":
                    this.constants.set(decl.id, decl);
                    break;
                default:
                    (0, util_1.unreachable)(decl);
            }
        }
    }
    processFunction(func, contract) {
        const name = this.extractFunctionName(func, contract);
        this.functionNames.set(func.id, name);
        this.functions.set(func.id, func);
        func.statements?.forEach((stmt) => this.processStmt(stmt));
    }
    processAsmFunction(func, contract) {
        const name = this.extractFunctionName(func, contract);
        this.functionNames.set(func.id, name);
        this.asmFunctions.set(func.id, func);
    }
    processNativeFunction(func) {
        const name = this.extractFunctionName(func, undefined);
        this.functionNames.set(func.id, name);
        this.nativeFunctions.set(func.id, func);
    }
    processStmt(stmt) {
        this.statements.set(stmt.id, stmt);
        switch (stmt.kind) {
            case "statement_let":
            case "statement_destruct":
            case "statement_return":
            case "statement_expression":
            case "statement_assign":
            case "statement_augmentedassign":
                break;
            case "statement_condition":
                stmt.trueStatements.forEach((s) => this.processStmt(s));
                stmt.falseStatements?.forEach((s) => this.processStmt(s));
                break;
            case "statement_while":
            case "statement_until":
            case "statement_repeat":
            case "statement_foreach":
            case "statement_block":
                stmt.statements.forEach((s) => this.processStmt(s));
                break;
            case "statement_try":
                stmt.statements.forEach((s) => this.processStmt(s));
                if (stmt.catchBlock) {
                    stmt.catchBlock.catchStatements.forEach((s) => this.processStmt(s));
                }
                break;
            default:
                (0, util_1.unreachable)(stmt);
        }
    }
    addContractEntry(contractId, nodeId) {
        this.contractEntries.set(contractId, (this.contractEntries.get(contractId) || new Set()).add(nodeId));
    }
    /**
     * Extracts the function name based on its type and optional contract name.
     * @param func The function definition, receiver, or initializer.
     * @param contract The optional contract name.
     * @returns The function name, or `undefined` if it cannot be determined.
     */
    extractFunctionName(func, contract) {
        const withContract = (base) => `${contract}::${base}`;
        const requireContract = () => {
            if (!contract)
                throw exceptions_1.InternalException.make("");
        };
        switch (func.kind) {
            case "function_def":
                return contract
                    ? withContract((0, imports_1.idText)(func.name))
                    : (0, imports_1.idText)(func.name);
            case "asm_function_def":
                return contract
                    ? withContract(`[asm]${(0, imports_1.idText)(func.name)}`)
                    : `[asm]${(0, imports_1.idText)(func.name)}`;
            case "native_function_decl":
                return contract
                    ? withContract(`[native]${(0, imports_1.idText)(func.name)}`)
                    : `[native]${(0, imports_1.idText)(func.name)}`;
            case "contract_init":
                requireContract();
                return withContract(`contract_init_${func.id}`);
            case "receiver":
                requireContract();
                return withContract(`receiver_${func.id}`);
            default:
                (0, util_1.unreachable)(func);
        }
    }
}
exports.AstStoreBuilder = AstStoreBuilder;
