"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImportGraphBuilder = void 0;
const exceptions_1 = require("../../exceptions");
const imports_1 = require("../../tact/imports");
const stdlib_1 = require("../../tact/stdlib");
const imports_2 = require("../imports");
const path_1 = __importDefault(require("path"));
class ImportGraphBuilder {
    ctx;
    entryPoints;
    constructor(ctx, entryPoints) {
        this.ctx = ctx;
        this.entryPoints = entryPoints;
    }
    /**
     * Creates an ImportGraphBuilder.
     *
     * @param ctx Misti context.
     * @param entryPoints Absolute paths to entry points to build import graph from.
     */
    static make(ctx, entryPoints) {
        return new ImportGraphBuilder(ctx, entryPoints);
    }
    build() {
        const nodes = [];
        const edges = [];
        const visited = new Set();
        this.entryPoints.forEach((e) => this.processFile(e, nodes, edges, visited));
        return new imports_2.ImportGraph(nodes, edges);
    }
    processFile(filePath, nodes, edges, visited) {
        if (visited.has(filePath)) {
            return nodes.find((node) => node.importPath === filePath).idx;
        }
        visited.add(filePath);
        let fileContent = "";
        try {
            fileContent = this.ctx.config.fs.readFile(filePath).toString("utf8");
        }
        catch {
            this.ctx.logger.warn(`Cannot find imported file: ${filePath}. The analysis might not work.`);
        }
        const imports = (0, imports_1.getParser)((0, imports_1.getAstFactory)(), "new").parseImports({
            code: fileContent,
            path: filePath,
            origin: "user",
        });
        const node = new imports_2.ImportNode(this.generateNodeName(filePath), (0, stdlib_1.definedInStdlib)(this.ctx, filePath) ? "stdlib" : "user", filePath, this.determineLanguage(filePath), this.hasContract(fileContent));
        nodes.push(node);
        imports.reduce((acc, importNode) => {
            let importPath = importNode.importPath.type === "stdlib"
                ? this.resolveStdlibPath((0, imports_1.importAsString)(importNode.importPath.path))
                : path_1.default.resolve(path_1.default.dirname(filePath), (0, imports_1.importAsString)(importNode.importPath.path));
            // TODO: We should use a Tact API function call when this is fixed:
            //       https://github.com/tact-lang/tact/issues/982
            importPath =
                importPath.endsWith(".tact") || importPath.endsWith(".fc")
                    ? importPath
                    : importPath + ".tact";
            const targetNodeIdx = this.processFile(importPath, nodes, edges, visited);
            const edge = new imports_2.ImportEdge(node.idx, targetNodeIdx, importNode.loc);
            edges.push(edge);
            node.outEdges.add(edge.idx);
            nodes.find((n) => n.idx === targetNodeIdx)?.inEdges.add(edge.idx);
            return acc;
        }, undefined);
        return node.idx;
    }
    /**
     * Returns the absolute path to the stdlib/libs directory.
     */
    getStdlibLibsPath() {
        const libsDir = "libs"; // Tact sources: src/stdlib/libs/
        return path_1.default.resolve((0, stdlib_1.getStdlibPath)(), libsDir);
    }
    /**
     * Returns the absolute path to the stdlib location if the given path
     * starts with `@stdlib`. Otherwise, returns the path unchanged.
     *
     * Tact API doesn't provide functions to work with paths, so we replicate this:
     * https://github.com/tact-lang/tact/blob/2315d035f5f9a22cad42657561c1a0eaef997b05/src/imports/resolveLibrary.ts#L26
     *
     * TODO: Should be replaced when https://github.com/tact-lang/tact/issues/982 is implemented.
     */
    resolveStdlibPath(importPath) {
        return path_1.default.resolve(this.getStdlibLibsPath(), importPath);
    }
    /**
     * Determines the language of a file based on its extension.
     * @throws ExecutionException if the language cannot be determined.
     */
    determineLanguage(filePath) {
        return filePath.endsWith(".tact")
            ? "tact"
            : filePath.endsWith(".fc")
                ? "func"
                : (() => {
                    throw exceptions_1.ExecutionException.make(`Cannot determine the target language of import: ${filePath}`);
                })();
    }
    /**
     * Generates a node name for the import graph based on the file path.
     */
    generateNodeName(filePath) {
        const basename = path_1.default.basename(filePath);
        const basenameWithoutExtension = basename.replace(/\.(tact|func|fc)$/, "");
        if ((0, stdlib_1.definedInStdlib)(this.ctx, filePath)) {
            const relativePath = path_1.default.relative(this.getStdlibLibsPath(), filePath);
            return `@stdlib/${relativePath}`.replace(/\\/g, "/");
        }
        return basenameWithoutExtension;
    }
    hasContract(fileContent) {
        return /contract[\t\n\r\u2028\u2029 ]/.test(fileContent);
    }
}
exports.ImportGraphBuilder = ImportGraphBuilder;
