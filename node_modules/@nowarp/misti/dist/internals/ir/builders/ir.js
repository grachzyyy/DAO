"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createIR = exports.TactIRBuilder = void 0;
const __1 = require("..");
const astStore_1 = require("./astStore");
const callgraph_1 = require("./callgraph");
const exceptions_1 = require("../../exceptions");
const tact_1 = require("../../tact");
const imports_1 = require("../../tact/imports");
const util_1 = require("../../util");
/**
 * Retrieves trait/contract definition location without typed AST.
 * An alternative might be using `resolveTypes.getType()` to get the definition
 * of the node, but it seems less effective since we don't store CompilerContext.
 * See: https://github.com/tact-lang/tact/issues/1961
 */
function hackOrigin(entry) {
    return entry.kind === "trait" &&
        entry.loc.file &&
        entry.loc.file.includes("stdlib/libs")
        ? "stdlib"
        : entry.loc.origin;
}
/**
 * Generates a unique name used to identify receive functions in CFG.
 */
function generateReceiveName(receive) {
    switch (receive.selector.kind) {
        case "internal":
            if (receive.selector.subKind.kind === "simple") {
                return `receive_internal_simple_${receive.id}`;
            }
            else if (receive.selector.subKind.kind === "fallback") {
                return `receive_internal_fallback_${receive.id}`;
            }
            else if (receive.selector.subKind.kind === "comment") {
                return `receive_internal_comment_${receive.id}_${receive.selector.subKind.comment.value}`;
            }
            (0, util_1.unreachable)(receive.selector.subKind);
        case "external":
            if (receive.selector.subKind.kind === "simple") {
                return `receive_external_simple_${receive.id}`;
            }
            else if (receive.selector.subKind.kind === "fallback") {
                return `receive_external_fallback_${receive.id}`;
            }
            else if (receive.selector.subKind.kind === "comment") {
                return `receive_external_comment_${receive.id}_${receive.selector.subKind.comment.value}`;
            }
            (0, util_1.unreachable)(receive.selector.subKind);
        case "bounce":
            return `receive_bounce_${receive.id}`;
        default:
            (0, util_1.unreachable)(receive.selector);
    }
}
/**
 * Represents a stateful object which is responsible for constructing the IR of a Tact project.
 *
 * It creates a one-statement-per-basic-block CFG.
 */
class TactIRBuilder {
    ctx;
    projectName;
    ast;
    imports;
    /**
     * Keeps unique identifiers registered for building CFG nodes for free functions.
     */
    functionIndexes = new Map();
    /**
     * Keeps unique identifiers registered for building CFG nodes for contract
     * and trait methods.
     */
    methodIndexes = new Map();
    /**
     * @param projectName The name of the project being compiled and analyzed, used for referencing within the compilation environment.
     * @param ast The AST of the project.
     */
    constructor(ctx, projectName, ast, imports) {
        this.ctx = ctx;
        this.projectName = projectName;
        this.ast = ast;
        this.imports = imports;
        this.assignFunctionIndices();
        this.assignMethodIndices();
    }
    static make(ctx, projectName, ast, imports) {
        return new TactIRBuilder(ctx, projectName, ast, imports);
    }
    /**
     * Transforms an AST into a `CompilationUnit` object.
     */
    build() {
        const functions = this.createFunctions();
        const { contracts, traits } = this.createContractsAndTraits();
        const tactASTStore = astStore_1.AstStoreBuilder.make(this.ctx, this.ast).build();
        const callGraph = callgraph_1.TactCallGraphBuilder.make(this.ctx, tactASTStore).build();
        return new __1.CompilationUnit(this.projectName, astStore_1.AstStoreBuilder.make(this.ctx, this.ast).build(), this.imports, callGraph, functions, contracts, traits);
    }
    /**
     * Assign unique CFG indices to free function definitions.
     */
    assignFunctionIndices() {
        this.functionIndexes = this.ast.functions.reduce((acc, fun) => {
            if (fun.kind == "function_def") {
                const funName = fun.name.text;
                const idx = this.registerCFGIdx(funName, fun.id, "function", fun.loc.origin, fun.loc);
                acc.set(funName, idx);
            }
            return acc;
        }, new Map());
    }
    /**
     * Creates CFGs for each free function defined in the AST using their previously registered unique identifiers.
     * @returns A map of Cfg structures keyed by their unique identifiers, representing each free function's Cfg.
     */
    createFunctions() {
        return this.ast.functions.reduce((acc, fun) => {
            if (fun.kind == "function_def") {
                const funName = fun.name.text;
                const idx = this.functionIndexes.get(funName);
                acc.set(idx, this.createCFGFromStatements(idx, funName, fun.id, "function", fun.loc.origin, fun.statements, fun.loc));
            }
            return acc;
        }, new Map());
    }
    /**
     * Extracts information from the contract AST entry if it is a method.
     */
    getMethodInfo(decl, contractId) {
        switch (decl.kind) {
            case "function_def":
                return [
                    decl.name.text,
                    "method",
                    decl.statements,
                ];
            case "contract_init":
                return [
                    `init_${contractId}`,
                    "method",
                    decl.statements,
                ];
            case "receiver":
                return [
                    generateReceiveName(decl),
                    "receive",
                    decl.statements,
                ];
            default:
                return [undefined, undefined, null];
        }
    }
    /**
     * Assign unique CFG indices to contract and trait methods.
     */
    assignMethodIndices() {
        this.methodIndexes = this.ast.types.reduce((acc, entry) => {
            if (entry.kind == "contract" || entry.kind === "trait") {
                const contractName = entry.name.text;
                const methodsMap = entry.declarations.reduce((methodAcc, decl) => {
                    const [name, kind, _] = this.getMethodInfo(decl, entry.id);
                    // NOTE: We don't create Cfg entries for asm functions.
                    if (kind && name) {
                        const idx = this.registerCFGIdx(name, decl.id, kind, entry.loc.origin, decl.loc);
                        methodAcc.set(name, idx);
                    }
                    return methodAcc;
                }, new Map());
                acc.set(contractName, methodsMap);
            }
            return acc;
        }, new Map());
    }
    /**
     * Creates the complete CFGs for contract and trait methods saving them to
     * Contract and Trait objects.
     */
    createContractsAndTraits() {
        return this.ast.types.reduce((acc, entry) => {
            if (entry.kind === "contract" || entry.kind === "trait") {
                const name = (0, imports_1.idText)(entry.name);
                const methodsMap = this.methodIndexes.get(name);
                const methodCFGs = entry.declarations.reduce((methodAcc, decl) => {
                    const [name, kind, stmts] = this.getMethodInfo(decl, entry.id);
                    if (kind && name) {
                        const idx = methodsMap.get(name);
                        methodAcc.set(idx, this.createCFGFromStatements(idx, name, decl.id, "method", hackOrigin(entry), stmts, decl.loc));
                    }
                    return methodAcc;
                }, new Map());
                switch (entry.kind) {
                    case "contract": {
                        const contract = new __1.Contract(name, methodCFGs, entry.loc);
                        acc.contracts.set(contract.idx, contract);
                        break;
                    }
                    case "trait": {
                        const trait = new __1.Trait(name, methodCFGs, {
                            ...entry.loc,
                            origin: hackOrigin(entry),
                        });
                        acc.traits.set(trait.idx, trait);
                        break;
                    }
                    default:
                        (0, util_1.unreachable)(entry);
                }
            }
            return acc;
        }, {
            contracts: new Map(),
            traits: new Map(),
        });
    }
    /**
     * Creates an unique Cfg index for the function with the given name.
     */
    registerCFGIdx(name, id, kind, origin, ref) {
        return new __1.Cfg(name, id, kind, origin, [], [], ref).idx;
    }
    /**
     * Generates basic blocks (BB) and edges for the Cfg based on the statements within a given function or method.
     * Each BB represents a single statement, and edges represent control flow between statements.
     *
     * @param idx Unique Cfg identifier created on the function registration step.
     * @param name The name of the function or method being processed.
     * @param id AST ID.
     * @param kind Indicates whether the input represents a function or a method.
     * @param origin Indicates whether the function was defined in users code or in standard library.
     * @param statements An array of AstStatement from the AST of the function or method.
     * @param ref AST reference to the corresponding function or method.
     * @returns A Cfg instance populated with BBs and edges for the provided statements.
     */
    createCFGFromStatements(idx, name, id, kind, origin, statements, ref) {
        const [bbs, edges] = statements === null ? [[], []] : this.processStatements(statements);
        this.markExitBBs(bbs);
        return new __1.Cfg(name, id, kind, origin, bbs, edges, ref, idx);
    }
    /**
     * Recursively collects function and method calls from the given expression using the registered unique indexes.
     * @param expr The AST expression from which to collect function and method calls.
     * @param parentCalls A set of Cfg indexes to which the indices of found function/method calls will be added.
     * @returns A set containing Cfg indexes of function and method calls within the expression.
     */
    collectFunctionCalls(expr, parentCalls = new Set()) {
        switch (expr.kind) {
            case "method_call":
                if (expr.self.kind === "id" && (0, imports_1.isSelfId)(expr.self)) {
                    const contractMethods = this.methodIndexes.get(expr.self.text);
                    if (contractMethods) {
                        const methodIdx = contractMethods.get(expr.method.text);
                        if (methodIdx !== undefined) {
                            parentCalls.add(methodIdx);
                        }
                        else {
                            this.ctx.logger.warn(`${(0, tact_1.formatPosition)(expr.loc)}Calling an unknown contract method: ${expr.method.text}`);
                        }
                    }
                    else {
                        // TODO: This could be trivially implemented after introducing typed
                        // AST in Tact: https://github.com/tact-lang/tact/issues/289.
                        this.ctx.logger.debug(`${(0, tact_1.formatPosition)(expr.self.loc)}Accessing an unknown contract: ${expr.self.text}`);
                    }
                }
                else {
                    // TODO: This could be trivially implemented after introducing typed
                    // AST in Tact: https://github.com/tact-lang/tact/issues/289.
                    this.ctx.logger.debug(`${(0, tact_1.formatPosition)(expr.self.loc)}Unsupported contract method access: ${expr.self.kind}`);
                }
                expr.args.forEach((arg) => this.collectFunctionCalls(arg, parentCalls));
                this.collectFunctionCalls(expr.self, parentCalls);
                break;
            case "static_call":
                const funcIdx = this.functionIndexes.get(expr.function.text);
                if (funcIdx !== undefined) {
                    parentCalls.add(funcIdx);
                }
                expr.args.forEach((arg) => this.collectFunctionCalls(arg, parentCalls));
                break;
            case "op_binary":
                this.collectFunctionCalls(expr.left, parentCalls);
                this.collectFunctionCalls(expr.right, parentCalls);
                break;
            case "op_unary":
                this.collectFunctionCalls(expr.operand, parentCalls);
                break;
            case "field_access":
                this.collectFunctionCalls(expr.aggregate, parentCalls);
                break;
            case "struct_instance":
                expr.args.forEach((arg) => this.collectFunctionCalls(arg.initializer, parentCalls));
                break;
            case "init_of":
                expr.args.forEach((arg) => this.collectFunctionCalls(arg, parentCalls));
                break;
            case "conditional":
                this.collectFunctionCalls(expr.condition, parentCalls);
                this.collectFunctionCalls(expr.thenBranch, parentCalls);
                this.collectFunctionCalls(expr.elseBranch, parentCalls);
                break;
            case "code_of":
                break;
            case "string":
            case "number":
            case "boolean":
            case "null":
            case "id":
            case "cell":
            case "struct_value":
            case "simplified_string":
            case "address":
            case "slice":
                break;
            default:
                (0, util_1.unreachable)(expr);
        }
        return parentCalls;
    }
    /**
     * Determines kind of the basic block while creating statements.
     */
    getBBKind(stmt) {
        switch (stmt.kind) {
            case "statement_return":
                return { kind: "exit" };
            case "statement_let":
            case "statement_expression":
            case "statement_assign":
            case "statement_augmentedassign": {
                const callees = this.collectFunctionCalls(stmt.expression);
                if (callees.size > 0) {
                    return { kind: "call", callees };
                }
                else {
                    return { kind: "regular" };
                }
            }
            default:
                return { kind: "regular" };
        }
    }
    /**
     * Recursively processes an array of AST statements to generate nodes and edges for a Cfg.
     *
     * @param statements The array of AstStatement objects.
     * @param bbs An optional array of basic blocks to which new nodes will be added.
     * @param edges An optional array of Edge objects to which new edges will be added.
     * @param lastBBIdxes An optional indices representing from which control flow enters the current sequence of statements.
     * @returns A tuple containing the arrays of BasicBlock and Edge objects representing the Cfg derived from the statements.
     */
    processStatements(statements, bbs = [], edges = [], lastBBIdxes = []) {
        statements.forEach((stmt, _index) => {
            const newBB = new __1.BasicBlock(stmt.id, this.getBBKind(stmt));
            bbs.push(newBB);
            // If there's a parent node, connect this node to the parent
            if (lastBBIdxes !== undefined) {
                lastBBIdxes.forEach((idx) => {
                    const src = this.getParent(bbs, idx);
                    edges.push(this.addEdge(src, newBB));
                });
            }
            if (stmt.kind === "statement_let" ||
                stmt.kind === "statement_destruct" ||
                stmt.kind === "statement_expression" ||
                stmt.kind === "statement_assign" ||
                stmt.kind === "statement_augmentedassign") {
                // Update the lastBBIdxes to the current basic block index
                lastBBIdxes = [newBB.idx];
            }
            else if (stmt.kind === "statement_condition") {
                // Branching logic for trueStatements
                const [trueBBs, trueEdges] = this.processStatements(stmt.trueStatements, bbs, edges, [newBB.idx]);
                bbs = trueBBs;
                edges = trueEdges;
                const trueEndBB = trueBBs[trueBBs.length - 1];
                if (stmt.falseStatements !== undefined &&
                    stmt.falseStatements.length > 0) {
                    // Branching logic for falseStatements
                    const [falseBBs, falseEdges] = this.processStatements(stmt.falseStatements, bbs, edges, [newBB.idx]);
                    bbs = falseBBs;
                    edges = falseEdges;
                    const falseEndBB = falseBBs[falseBBs.length - 1];
                    lastBBIdxes = [trueEndBB.idx, falseEndBB.idx];
                }
                else {
                    // Connect the end of the true branch to the next statement
                    lastBBIdxes = [trueEndBB.idx];
                }
            }
            else if (stmt.kind === "statement_while" ||
                stmt.kind === "statement_until" ||
                stmt.kind === "statement_repeat" ||
                stmt.kind === "statement_foreach") {
                // Create an edge from the current BB (loop condition) back to the start of the loop body,
                // and from the end of the loop body back to the current BB to represent the loop's cycle.
                // Also, ensure the loop connects to the next BB after the loop concludes.
                // Process the statements within the loop body.
                const [loopBBs, loopEdges] = this.processStatements(stmt.statements, bbs, edges, [newBB.idx]);
                bbs = loopBBs;
                edges = loopEdges;
                // Create an edge from the last BB in the loop back to the condition to represent the loop's cycle.
                if (loopBBs.length > 0) {
                    const lastBB = loopBBs[loopBBs.length - 1];
                    edges.push(this.addEdge(lastBB, newBB));
                }
                // Connect condition with the statement after loop.
                lastBBIdxes = [newBB.idx];
            }
            else if (stmt.kind === "statement_try") {
                // Process the try branch.
                const [tryBBs, tryEdges] = this.processStatements(stmt.statements, bbs, edges, [newBB.idx]);
                bbs = tryBBs;
                edges = tryEdges;
                // Connect the last try block with statements after this `try` block or
                // with `try` itself if it is empty.
                lastBBIdxes =
                    tryBBs.length > 0 ? [tryBBs[tryBBs.length - 1].idx] : [newBB.idx];
                // Handle the `catch` clause.
                if (stmt.catchBlock) {
                    const [catchBBs, catchEdges] = this.processStatements(stmt.catchBlock.catchStatements, bbs, edges, [newBB.idx]);
                    bbs = catchBBs;
                    edges = catchEdges;
                    // Catch block always terminates execution.
                    if (catchBBs.length > 0) {
                        tryBBs[tryBBs.length - 1].kind = { kind: "exit" };
                    }
                }
            }
            else if (stmt.kind === "statement_return") {
                // No need to connect return statements to subsequent basic blocks
                lastBBIdxes = [];
            }
            else if (stmt.kind === "statement_block") {
                const [catchBBs, catchEdges] = this.processStatements(stmt.statements, bbs, edges, [newBB.idx]);
                bbs = catchBBs;
                edges = catchEdges;
            }
            else {
                (0, util_1.unreachable)(stmt);
            }
        });
        return [bbs, edges];
    }
    /**
     * Marks basic blocks without successors as Exit kind.
     * @param bbs The array of BasicBlock objects.
     * @param edges The array of Edge objects.
     */
    markExitBBs(bbs) {
        const bbHasSuccessors = (bb) => bb.dstEdges.size > 0;
        bbs.forEach((bb) => {
            if (!bbHasSuccessors(bb)) {
                bb.kind = { kind: "exit" };
            }
        });
    }
    getParent(bbs, idx) {
        const bb = bbs.find((bb) => bb.idx === idx);
        if (bb === undefined) {
            throw exceptions_1.InternalException.make(`Cannot find BB #${idx}. Available BBs: ${bbs.map((n) => n.idx)}`);
        }
        return bb;
    }
    addEdge(src, dst) {
        const edge = new __1.Edge(src.idx, dst.idx);
        src.dstEdges.add(edge.idx);
        dst.srcEdges.add(edge.idx);
        return edge;
    }
}
exports.TactIRBuilder = TactIRBuilder;
/**
 * Creates the Intermediate Representation (IR) for the given projects.
 *
 * @param ast AST parsed using the Tact parser.
 * @param imports An optional imports graph for the given projects, if available.
 * @returns A mapping of project names to their corresponding CompilationUnit objects.
 */
function createIR(ctx, projectName, ast, imports) {
    return TactIRBuilder.make(ctx, projectName, ast, imports).build();
}
exports.createIR = createIR;
