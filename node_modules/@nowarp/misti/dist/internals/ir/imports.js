"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImportGraph = exports.ImportEdge = exports.ImportNode = void 0;
const indices_1 = require("./indices");
const path_1 = __importDefault(require("path"));
/**
 * Represents a node in the import graph, corresponding to a file.
 */
class ImportNode {
    name;
    origin;
    importPath;
    language;
    hasContract;
    inEdges;
    outEdges;
    idx;
    constructor(
    /** Displayed name. */
    name, 
    /** Origin of the node. */
    origin, 
    /** Absolute path to the imported file. */
    importPath, 
    /** Language in which the imported file is written. */
    language, 
    /** True if this file has a contract definition. */
    hasContract, inEdges = new Set(), outEdges = new Set()) {
        this.name = name;
        this.origin = origin;
        this.importPath = importPath;
        this.language = language;
        this.hasContract = hasContract;
        this.inEdges = inEdges;
        this.outEdges = outEdges;
        this.idx = indices_1.IdxGenerator.next("import_node");
    }
}
exports.ImportNode = ImportNode;
/**
 * Represents an edge in the import graph, connecting two files.
 */
class ImportEdge {
    src;
    dst;
    loc;
    idx;
    constructor(src, dst, 
    /** Source location of the `import` statement. */
    loc) {
        this.src = src;
        this.dst = dst;
        this.loc = loc;
        this.idx = indices_1.IdxGenerator.next("import_edge");
    }
}
exports.ImportEdge = ImportEdge;
/**
 * Represents the entire import graph of a project.
 */
class ImportGraph {
    nodes;
    edges;
    /** Unique node index to this.nodes index mapping */
    nodesMap;
    /** Unique edge index to this.edges index mapping */
    edgesMap;
    constructor(nodes, edges) {
        this.nodes = nodes;
        this.edges = edges;
        this.nodesMap = new Map();
        this.initializeMapping(this.nodesMap, nodes);
        this.edgesMap = new Map();
        this.initializeMapping(this.edgesMap, edges);
    }
    initializeMapping(mapping, entries) {
        entries.forEach((entry, arrayIdx) => {
            mapping.set(entry.idx, arrayIdx);
        });
    }
    /**
     * Iterates over all nodes in the graph and calls the provided callback for each nodes.
     * @param callback A function to be called for each nodes in the graph.
     */
    forEachNode(callback) {
        this.nodes.forEach(callback);
    }
    /**
     * Iterates over all edges in the graph and calls the provided callback for each edge.
     * @param callback A function to be called for each edge in the graph.
     */
    forEachEdge(callback) {
        this.edges.forEach(callback);
    }
    /**
     * Resolves project root based on the import directives.
     * The project root is a directory including all the imported files.
     *
     * @param fs The virtual file system used to manage and resolve file paths during the operation.
     * @returns Project root directory or undefined if there are no user imports.
     */
    resolveProjectRoot(fs) {
        let projectRoot;
        this.nodes.forEach((node) => {
            if (node.origin === "user") {
                if (!projectRoot) {
                    projectRoot = path_1.default.dirname(node.importPath);
                }
                else {
                    if (!projectRoot.includes(path_1.default.dirname(node.importPath))) {
                        projectRoot = this.findCommonParent(projectRoot, path_1.default.dirname(node.importPath));
                    }
                }
            }
        });
        return projectRoot ? fs.resolve(projectRoot) : undefined;
    }
    /**
     * Finds the common parent directory between two paths.
     */
    findCommonParent(path1, path2) {
        const parts1 = path1.split(path_1.default.sep);
        const parts2 = path2.split(path_1.default.sep);
        let i = 0;
        while (i < parts1.length && i < parts2.length && parts1[i] === parts2[i]) {
            i++;
        }
        return parts1.slice(0, i).join(path_1.default.sep) || path_1.default.sep;
    }
    /**
     * Returns true if `parent` imports `child`, directly or indirectly.
     */
    imports(parent, child) {
        let found = false;
        this.bfs(parent, (node, _) => {
            if (node.idx === child) {
                found = true;
            }
        });
        return found;
    }
    /**
     * Returns a list of nodes that have a contract definition.
     * These nodes could be entry points of the project.
     */
    getContractNodes() {
        return Array.from(this.nodes.values()).filter((node) => node.hasContract);
    }
    /**
     * Performs a BFS on the import graph.
     * @param start The starting node index for the BFS.
     * @param callback A function called for each visited node and the edge through which it was reached.
     */
    bfs(start, callback, { direction = "forward" } = {}) {
        const queue = [[start, null]];
        const visited = new Set();
        while (queue.length > 0) {
            const [currentIdx, incomingEdge] = queue.shift();
            if (visited.has(currentIdx))
                continue;
            const currentNode = this.nodes[this.nodesMap.get(currentIdx)];
            visited.add(currentIdx);
            callback(currentNode, incomingEdge);
            const edges = direction === "backward" ? currentNode.inEdges : currentNode.outEdges;
            edges.forEach((edgeIdx) => {
                const edge = this.edges[this.edgesMap.get(edgeIdx)];
                const nextNodeIdx = direction === "backward" ? edge.src : edge.dst;
                if (!visited.has(nextNodeIdx)) {
                    queue.push([nextNodeIdx, edge]);
                }
            });
        }
    }
    /**
     * Finds a node in the graph by its import path.
     * @param importPath The absolute path of the file to find.
     * @returns The ImportNode if found, or undefined if not found.
     */
    findNodeByPath(importPath) {
        return this.nodes.find((node) => node.importPath === importPath);
    }
    /**
     * Generic method to get all connections in a specified direction.
     * @param nodeIdx The index of the node to start from.
     * @param direction The direction of traversal ('forward' or 'backward').
     * @returns An array of ImportNodes connected to the given node in the specified direction.
     */
    getConnectionsInDirection(nodeIdx, direction) {
        const result = [];
        this.bfs(nodeIdx, (node, edge) => {
            // Skip the starting node
            if (edge !== null)
                result.push(node);
        }, { direction });
        return result;
    }
    /**
     * Returns all direct and indirect import connections for the given node index.
     * @param nodeIdx The index of the node to start from.
     * @returns An array of ImportNodes that are directly or indirectly imported by the given node.
     */
    getAllImportConnections(nodeIdx) {
        return this.getConnectionsInDirection(nodeIdx, "forward");
    }
    /**
     * Returns all nodes that directly or indirectly import the given node.
     * @param nodeIdx The index of the node to start from.
     * @returns An array of ImportNodes that directly or indirectly import the given node.
     */
    getAllImportingNodes(nodeIdx) {
        return this.getConnectionsInDirection(nodeIdx, "backward");
    }
    /**
     * Finds a direct connection (edge) between two nodes.
     * @param sourceIdx The index of the source node.
     * @param targetIdx The index of the target node.
     * @returns The ImportEdge if a direct connection exists, or undefined if not found.
     */
    findConnection(sourceIdx, targetIdx) {
        const sourceNode = this.nodes[this.nodesMap.get(sourceIdx)];
        return Array.from(sourceNode.outEdges)
            .map((edgeIdx) => this.edges[this.edgesMap.get(edgeIdx)])
            .find((edge) => edge.dst === targetIdx);
    }
}
exports.ImportGraph = ImportGraph;
