"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Trait = exports.Contract = exports.TraitContract = exports.CompilationUnit = void 0;
const indices_1 = require("./indices");
/**
 * Represents a Compilation Unit, encapsulating the information necessary for
 * analyzing a single Tact project.
 */
class CompilationUnit {
    projectName;
    ast;
    imports;
    callGraph;
    functions;
    contracts;
    traits;
    /**
     * Creates an instance of CompilationUnit.
     * @param projectName The name of the project this Compilation Unit belongs to.
     * @param ast The AST of the project.
     * @param imports A graph showing the connections between project files.
     * @param functions A mapping from unique IDs of free functions to their CFGs.
     * @param contracts A mapping contract ids to their entries.
     * @param traits A mapping trait ids to their entries.
     */
    constructor(projectName, ast, imports, callGraph, functions, contracts, traits) {
        this.projectName = projectName;
        this.ast = ast;
        this.imports = imports;
        this.callGraph = callGraph;
        this.functions = functions;
        this.contracts = contracts;
        this.traits = traits;
    }
    getContracts() {
        return this.contracts;
    }
    getTraits({ includeStdlib = true, } = {}) {
        if (includeStdlib)
            return this.traits;
        return new Map([...this.traits].filter(([_, t]) => t.loc.origin !== "stdlib"));
    }
    getContractsTraits({ includeStdlib = true, } = {}) {
        const contracts = this.getContracts();
        const traits = this.getTraits({ includeStdlib });
        const merged = new Map();
        for (const [key, contract] of contracts)
            merged.set(key, contract);
        for (const [key, trait] of traits)
            merged.set(key, trait);
        return merged;
    }
    /**
     * Looks for a CFG with a specific index.
     * @returns Found CFG or `undefined` if not found.
     */
    findCfgByIdx(idx) {
        const funCfg = this.functions.get(idx);
        if (funCfg)
            return funCfg;
        return Array.from(this.getContractsTraits().values())
            .map((contract) => contract.methods.get(idx))
            .find((cfg) => cfg !== undefined);
    }
    /**
     * Looks for a Cfg for a function node with a specific name.
     * @returns Found Cfg or `undefined` if not found.
     */
    findFunctionCFGByName(name) {
        return Array.from(this.functions.values()).find((cfg) => cfg.name === name);
    }
    /**
     * Looks for a Cfg for a method node with a specific name.
     * @returns Found Cfg or `undefined` if not found.
     */
    findMethodCFGByName(contractName, methodName) {
        const contract = Array.from(this.getContractsTraits().values()).find((contract) => contract.name === contractName);
        if (!contract) {
            return undefined;
        }
        const cfg = Array.from(contract.methods.values()).find((cfg) => cfg.name === methodName);
        return cfg;
    }
    /**
     * Iterates over all CFGs in a Compilation Unit, and applies a callback to Cfg.
     *
     * @param callback The function to apply to each Cfg.
     */
    forEachCFG(callback, { includeStdlib = true } = {}) {
        this.functions.forEach((cfg, _) => {
            if (!includeStdlib && cfg.origin === "stdlib") {
                return;
            }
            callback(cfg);
        });
        this.getContractsTraits({ includeStdlib }).forEach((contract) => {
            contract.methods.forEach((cfg, _) => {
                callback(cfg);
            });
        });
    }
    /**
     * Performs a fold operation over all CFGs in the Compilation Unit.
     *
     * @param init The initial value of the accumulator.
     * @param callback A function that takes the current accumulator and a Cfg,
     *                 and returns a new accumulator value.
     * @returns The final accumulated value.
     */
    foldCFGs(init, callback, { includeStdlib = true } = {}) {
        let acc = init;
        this.functions.forEach((cfg) => {
            acc = callback(acc, cfg);
        });
        this.getContractsTraits({ includeStdlib }).forEach((contract) => {
            contract.methods.forEach((cfg) => {
                acc = callback(acc, cfg);
            });
        });
        return acc;
    }
    /**
     * Iterates over all CFGs in a Compilation Unit, and applies a callback to each
     * basic block in every Cfg.
     *
     * @param astStore The store containing the AST nodes.
     * @param callback The function to apply to each BB within each Cfg.
     */
    forEachBasicBlock(astStore, callback, { includeStdlib = true } = {}) {
        // Iterate over all functions' CFGs
        this.functions.forEach((cfg, _) => {
            cfg.forEachBasicBlock(astStore, (stmt, node) => {
                callback(cfg, node, stmt);
            });
        });
        // Iterate over all contracts and their methods' CFGs
        this.getContractsTraits({ includeStdlib }).forEach((contract) => {
            contract.methods.forEach((cfg, _) => {
                cfg.forEachBasicBlock(astStore, (stmt, node) => {
                    callback(cfg, node, stmt);
                });
            });
        });
    }
}
exports.CompilationUnit = CompilationUnit;
/**
 * Base class representing a common structure for contracts and traits.
 */
class TraitContract {
    name;
    methods;
    loc;
    /**
     * The unique identifier of this entity among the compilation unit it belongs to.
     */
    idx;
    constructor(name, methods, loc, idx = undefined) {
        this.name = name;
        this.methods = methods;
        this.loc = loc;
        this.idx = idx
            ? idx
            : indices_1.IdxGenerator.next("ir_trait_contract");
    }
}
exports.TraitContract = TraitContract;
/**
 * Represents a smart contract with full implementation capabilities.
 */
class Contract extends TraitContract {
    get kind() {
        return "contract";
    }
}
exports.Contract = Contract;
/**
 * Represents a trait (interface with optional method implementations).
 */
class Trait extends TraitContract {
    get kind() {
        return "trait";
    }
}
exports.Trait = Trait;
