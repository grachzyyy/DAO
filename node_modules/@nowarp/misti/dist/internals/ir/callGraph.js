"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CallGraph = exports.CGNode = exports.CGEdge = exports.Effect = void 0;
const indices_1 = require("./indices");
const __1 = require("../../");
const imports_1 = require("../../internals/tact/imports");
/** Effects flags for callgraph nodes. */
var Effect;
(function (Effect) {
    /** Uses functions that send funds. */
    Effect[Effect["Send"] = 1] = "Send";
    /** Reads contract's state. */
    Effect[Effect["StateRead"] = 2] = "StateRead";
    /** Writes contract's state. */
    Effect[Effect["StateWrite"] = 4] = "StateWrite";
    /** Accesses datetime functions. */
    Effect[Effect["AccessDatetime"] = 8] = "AccessDatetime";
    /** Uses PRG. */
    Effect[Effect["PrgUse"] = 16] = "PrgUse";
    /** Inits PRG seed. */
    Effect[Effect["PrgSeedInit"] = 32] = "PrgSeedInit";
})(Effect = exports.Effect || (exports.Effect = {}));
/**
 * Represents an edge in the call graph, indicating a call from one function to another.
 */
class CGEdge {
    src;
    dst;
    idx;
    /**
     * @param src The source node ID representing the calling function
     * @param dst The destination node ID representing the called function
     */
    constructor(src, dst) {
        this.src = src;
        this.dst = dst;
        this.idx = indices_1.IdxGenerator.next("cg_edge");
    }
}
exports.CGEdge = CGEdge;
/**
 * Represents a node in the call graph, corresponding to a function or method.
 */
class CGNode {
    name;
    logger;
    idx;
    inEdges = new Set();
    outEdges = new Set();
    astId;
    loc;
    effects = 0;
    stateAccess = new Map();
    /**
     * @param node The AST node of the function. Can be `undefined` for call nodes.
     * @param name The name of the function or method
     * @param logger A logger instance for logging messages
     */
    constructor(node, name, logger) {
        this.name = name;
        this.logger = logger;
        this.stateAccess.set("read", new Set());
        this.stateAccess.set("write", new Set());
        this.idx = indices_1.IdxGenerator.next("cg_node");
        if (node === undefined) {
            this.logger.debug(`CGNode created without AST ID for function "${name}"`);
        }
        else {
            if ("id" in node) {
                this.astId = node.id;
            }
            else {
                throw __1.InternalException.make(`Node without id: ${node.kind}`);
            }
            if ("loc" in node) {
                this.loc = node.loc;
            }
            else {
                throw __1.InternalException.make(`Node without loc: ${node.kind}`);
            }
        }
    }
    /**
     * @param fields Names of contract fields accessed or modified by the effect.
     */
    addEffect(effect, fields) {
        this.effects |= effect;
        if (fields !== undefined) {
            const status = effect === Effect.StateRead
                ? "read"
                : effect === Effect.StateWrite
                    ? "write"
                    : undefined;
            if (status === undefined) {
                throw __1.InternalException.make(`Unknown effect: ${effect}`);
            }
            fields.forEach((f) => this.stateAccess.get(status).add(f));
        }
    }
    hasEffect(effect) {
        return (this.effects & effect) !== 0;
    }
    hasAnyEffect(...effects) {
        return effects.some((effect) => this.hasEffect(effect));
    }
    /**
     * Pretty-prints a signature of the function is available
     */
    signature(ast) {
        if (!this.astId)
            return undefined;
        const fun = ast.getFunction(this.astId);
        if (!fun)
            return undefined;
        let signature = (0, imports_1.prettyPrint)(fun).split("{")[0].replace(/\s+/g, " ").trim();
        const parts = this.name.split("::");
        if (parts.length > 1 && !signature.includes("::")) {
            const contractName = parts[0];
            if (signature.includes(" fun ")) {
                const lastFunIndex = signature.lastIndexOf(" fun ") + 5;
                signature =
                    signature.substring(0, lastFunIndex) +
                        contractName +
                        "::" +
                        signature.substring(lastFunIndex);
            }
            else if (signature.startsWith("fun ")) {
                signature = "fun " + contractName + "::" + signature.substring(4);
            }
            else {
                signature = contractName + "::" + signature;
            }
        }
        return signature;
    }
}
exports.CGNode = CGNode;
/**
 * Represents the call graph, a directed graph where nodes represent functions or methods,
 * and edges indicate calls between them.
 */
class CallGraph {
    nodeMap;
    astIdToNodeId;
    nameToNodeId;
    edgesMap;
    constructor(nodeMap, astIdToNodeId, nameToNodeId, edgesMap) {
        this.nodeMap = nodeMap;
        this.astIdToNodeId = astIdToNodeId;
        this.nameToNodeId = nameToNodeId;
        this.edgesMap = edgesMap;
    }
    /**
     * Retrieves all nodes in the call graph.
     * @returns A map of all nodes by their unique IDs.
     */
    getNodes() {
        return this.nodeMap;
    }
    /**
     * Retrieves all edges in the call graph.
     * @returns A map of all edges by their unique IDs.
     */
    getEdges() {
        return this.edgesMap;
    }
    /**
     * Retrieves a node's ID by its name.
     * @param name The name of the function or method.
     * @returns The corresponding node ID, or `undefined` if not found.
     */
    getNodeIdByName(name) {
        return this.nameToNodeId.get(name);
    }
    /**
     * Retrieves a node's ID by the AST ID of its definition.
     * @param astId The AST ID of the function definition.
     * @returns The corresponding node ID, or `undefined` if not found.
     */
    getNodeIdByAstId(astId) {
        return this.astIdToNodeId.get(astId);
    }
    /**
     * Retrieves a node by its ID.
     * @param nodeId The unique ID of the node.
     * @returns The corresponding node, or `undefined` if not found.
     */
    getNode(nodeId) {
        return this.nodeMap.get(nodeId);
    }
    /**
     * Determines if there exists a path from the source node to the destination node.
     * This is achieved via a breadth-first search.
     *
     * @param src The ID of the source node.
     * @param dst The ID of the destination node.
     * @returns `true` if a path exists; `false` otherwise.
     */
    areConnected(src, dst) {
        const srcNode = this.nodeMap.get(src);
        const dstNode = this.nodeMap.get(dst);
        if (!srcNode || !dstNode) {
            return false;
        }
        const queue = [src];
        const visited = new Set([src]);
        while (queue.length > 0) {
            const current = queue.shift();
            if (current === dst) {
                return true;
            }
            const currentNode = this.nodeMap.get(current);
            if (currentNode) {
                for (const edgeId of currentNode.outEdges) {
                    const edge = this.edgesMap.get(edgeId);
                    if (edge && !visited.has(edge.dst)) {
                        visited.add(edge.dst);
                        queue.push(edge.dst);
                    }
                }
            }
        }
        return false;
    }
    /**
     * Derives the function call name from a static or method call expression.
     * @param expr The call expression.
     * @param currentContractName The name of the current contract, if available.
     * @returns The fully qualified function name, or `undefined` if it is irrelevant.
     */
    static getFunctionCallName(expr, currentContractName) {
        if (expr.kind === "static_call") {
            return expr.function.text;
        }
        else if (expr.kind === "method_call") {
            const methodName = (0, imports_1.idText)(expr.method);
            // self.<method>()
            if ((0, __1.isSelf)(expr.self)) {
                if (!currentContractName) {
                    throw __1.InternalException.make(`Cannot process ${(0, imports_1.prettyPrint)(expr)} without current contract name`);
                }
                return `${currentContractName}::${methodName}`;
            }
            // <struct/contract>.<method>()
            if (expr.self.kind === "id") {
                // TODO: Replace with actual contract name when #136 is resolved
                return `${(0, imports_1.idText)(expr.self)}::${methodName}`;
            }
            // TODO: Support method call chains: #242
        }
        return undefined; // e.g. self.<map_field>.set()
    }
}
exports.CallGraph = CallGraph;
