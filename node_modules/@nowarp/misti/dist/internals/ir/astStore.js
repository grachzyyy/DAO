"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AstStore = void 0;
const exceptions_1 = require("../exceptions");
const util_1 = require("../util");
const imports_1 = require("../../internals/tact/imports");
/**
 * Provides access to AST elements using their unique IDs.
 *
 * The generated AST entries includes all the dependent elements, including imported
 * code which is included in the project AST in C/C++ style.
 */
class AstStore {
    stdlibIds;
    contractEntries;
    programEntries;
    functionNames;
    functions;
    constants;
    contracts;
    nativeFunctions;
    asmFunctions;
    primitives;
    structs;
    messages;
    traits;
    statements;
    /**
     * Constructs a AstStore with mappings to all major AST components accessible
     * by their unique AST identifiers.
     *
     * @param stdlibIds Identifiers of AST elements defined in stdlib.
     * @param contractEntries Items defined within contracts and traits.
     * @param programEntries Identifiers of AST elements defined on the top-level of each file.
     * @param functionNames Unique names for each function definition.
     * @param functions Functions and methods including user-defined and special methods.
     * @param constants Constants defined across the compilation unit.
     * @param contracts Contracts defined within the project.
     * @param nativeFunctions Functions defined natively (not in user's source code).
     * @param asmFunctions Tact asm functions.
     * @param primitives Primitive types defined in the project.
     * @param structs Structs defined in the project.
     * @param messages Messages defined in the project.
     * @param traits Traits defined in the project.
     * @param statements All executable statements within all functions of the project.
     */
    constructor(stdlibIds = new Set(), contractEntries = new Map(), programEntries, functionNames, functions, constants, contracts, nativeFunctions, asmFunctions, primitives, structs, messages, traits, statements) {
        this.stdlibIds = stdlibIds;
        this.contractEntries = contractEntries;
        this.programEntries = programEntries;
        this.functionNames = functionNames;
        this.functions = functions;
        this.constants = constants;
        this.contracts = contracts;
        this.nativeFunctions = nativeFunctions;
        this.asmFunctions = asmFunctions;
        this.primitives = primitives;
        this.structs = structs;
        this.messages = messages;
        this.traits = traits;
        this.statements = statements;
    }
    getFunctionName(defId) {
        return this.functionNames.get(defId);
    }
    /**
     * Returns top-level program entries in order as they defined in each file.
     */
    getProgramEntries({ includeStdlib = false, filename = undefined, } = {}) {
        return Array.from(this.programEntries.values()).flatMap((idSet) => Array.from(idSet).reduce((acc, id) => {
            if (!includeStdlib && this.stdlibIds.has(id)) {
                return acc;
            }
            let astNode;
            if (this.functions.has(id)) {
                astNode = this.functions.get(id);
            }
            else if (this.constants.has(id)) {
                astNode = this.constants.get(id);
            }
            else if (this.contracts.has(id)) {
                astNode = this.contracts.get(id);
            }
            else if (this.nativeFunctions.has(id)) {
                astNode = this.nativeFunctions.get(id);
            }
            else if (this.asmFunctions.has(id)) {
                astNode = this.asmFunctions.get(id);
            }
            else if (this.primitives.has(id)) {
                astNode = this.primitives.get(id);
            }
            else if (this.structs.has(id)) {
                astNode = this.structs.get(id);
            }
            else if (this.messages.has(id)) {
                astNode = this.messages.get(id);
            }
            else if (this.traits.has(id)) {
                astNode = this.traits.get(id);
            }
            else {
                throw exceptions_1.InternalException.make(`No entry found for ID: ${id}`);
            }
            if (astNode &&
                (filename === undefined || this.fileMatches(astNode, filename))) {
                acc.push(astNode);
            }
            return acc;
        }, []));
    }
    /**
     * Returns all the items defined within the program.
     * @param items The collection of items (functions or constants).
     * @param params Additional parameters:
     * - includeStdlib: If true, includes items defined in stdlib.
     * - filename: Filters out nodes defined in the given file.
     * @returns An iterator for the items.
     */
    getItems(items, { includeStdlib = false, filename } = {}) {
        const filteredStdout = includeStdlib
            ? items.values()
            : Array.from(items.values())
                .filter((c) => !this.stdlibIds.has(c.id))
                .values();
        return filename === undefined
            ? filteredStdout
            : Array.from(filteredStdout)
                .filter((item) => this.fileMatches(item, filename))[Symbol.iterator]();
    }
    /**
     * Returns all the functions and methods defined within the program.
     */
    getFunctions(params = {}) {
        return this.getItems(this.functions, params);
    }
    /**
     * Returns all the constants defined within the program, including top-level constants
     * and contract constants.
     * @param params Additional parameters:
     * - includeContract: If true, includes constants defined within a contract.
     */
    getConstants(params = {}) {
        const { includeContract = false, ...restParams } = params;
        const constants = this.getItems(this.constants, restParams);
        return includeContract
            ? constants
            : this.filterIterator(constants, (c) => !this.isContractItem(c.id));
    }
    getContracts(params = {}) {
        return this.getItems(this.contracts, params);
    }
    getNativeFunctions(params = {}) {
        return this.getItems(this.nativeFunctions, params);
    }
    getAsmFunctions(params = {}) {
        return this.getItems(this.asmFunctions, params);
    }
    getPrimitives(params = {}) {
        return this.getItems(this.primitives, params);
    }
    getStructs(params = {}) {
        return this.getItems(this.structs, params);
    }
    getMessages(params = {}) {
        return this.getItems(this.messages, params);
    }
    getTraits(params = {}) {
        return this.getItems(this.traits, params);
    }
    /**
     * Returns all the statements defined within the program.
     */
    getStatements() {
        return this.statements.values();
    }
    /**
     * Retrieves a function or method by its ID.
     * @param id The unique identifier of the function or method.
     * @returns The function or method if found, otherwise undefined.
     */
    getFunction(id) {
        return this.functions.get(id);
    }
    hasFunction(id) {
        return this.getFunction(id) !== undefined;
    }
    /**
     * Retrieves a constant by its ID.
     * @param id The unique identifier of the constant.
     * @returns The constant if found, otherwise undefined.
     */
    getConstant(id) {
        return this.constants.get(id);
    }
    hasConstant(id) {
        return this.getConstant(id) !== undefined;
    }
    /**
     * Retrieves a contract by its ID.
     * @param id The unique identifier of the contract.
     * @returns The contract if found, otherwise undefined.
     */
    getContract(id) {
        return this.contracts.get(id);
    }
    hasContract(id) {
        return this.getContract(id) !== undefined;
    }
    /**
     * Retrieves a native function by its ID.
     * @param id The unique identifier of the native function.
     * @returns The native function if found, otherwise undefined.
     */
    getNativeFunction(id) {
        return this.nativeFunctions.get(id);
    }
    hasNativeFunction(id) {
        return this.getNativeFunction(id) !== undefined;
    }
    /**
     * Retrieves an asm function by its ID.
     * @param id The unique identifier of the asm function.
     * @returns The asm function if found, otherwise undefined.
     */
    getAsmFunction(id) {
        return this.asmFunctions.get(id);
    }
    hasAsmFunction(id) {
        return this.getAsmFunction(id) !== undefined;
    }
    /**
     * Retrieves a primitive type by its ID.
     * @param id The unique identifier of the primitive type.
     * @returns The primitive type if found, otherwise undefined.
     */
    getPrimitive(id) {
        return this.primitives.get(id);
    }
    hasPrimitive(id) {
        return this.getPrimitive(id) !== undefined;
    }
    /**
     * Retrieves a struct by its ID.
     * @param id The unique identifier of the struct.
     * @returns The struct if found, otherwise undefined.
     */
    getStruct(id) {
        return this.structs.get(id);
    }
    hasStruct(id) {
        return this.getStruct(id) !== undefined;
    }
    /**
     * Retrieves a message by its ID.
     * @param id The unique identifier of the message.
     * @returns The message if found, otherwise undefined.
     */
    getMessage(id) {
        return this.messages.get(id);
    }
    hasMessage(id) {
        return this.getMessage(id) !== undefined;
    }
    /**
     * Retrieves a trait by its ID.
     * @param id The unique identifier of the trait.
     * @returns The trait if found, otherwise undefined.
     */
    getTrait(id) {
        return this.traits.get(id);
    }
    hasTrait(id) {
        return this.getTrait(id) !== undefined;
    }
    findTrait(name) {
        return Array.from(this.traits.values()).find((t) => t.name.text === name);
    }
    /**
     * Retrieves a statement by its ID.
     * @param id The unique identifier of the statement.
     * @returns The statement if found, otherwise undefined.
     */
    getStatement(id) {
        return this.statements.get(id);
    }
    hasStatement(id) {
        return this.getStatement(id) !== undefined;
    }
    /**
     * Retrieves the IDs of methods for a specified contract which have one of the following types: AstFunctionDef, AstReceiver, AstContractInit.
     * @param contractId The ID of the contract.
     * @returns An array of method IDs or undefined if no contract is found.
     */
    getMethods(contractId) {
        const contract = this.getContract(contractId);
        if (!contract) {
            return undefined;
        }
        return contract.declarations.reduce((result, decl) => {
            if (decl.kind === "function_def" ||
                decl.kind === "contract_init" ||
                decl.kind === "receiver") {
                result.push(decl.id);
            }
            return result;
        }, []);
    }
    /**
     * Retrieves the ID of the initialization function for a specified contract.
     * @param contractId The ID of the contract.
     * @returns The ID of the init function or undefined if the contract does not exist.
     */
    getInitId(contractId) {
        const contract = this.getContract(contractId);
        if (!contract) {
            return undefined;
        }
        const initFunction = contract.declarations.find((decl) => decl.kind === "contract_init");
        return initFunction ? initFunction.id : undefined;
    }
    /**
     * Retrieves the IDs of constants associated with a specified contract.
     * @param contractId The ID of the contract.
     * @returns An array of constant IDs or undefined if no contract is found.
     */
    getContractConstants(contractId) {
        const contract = this.getContract(contractId);
        if (!contract) {
            return undefined;
        }
        return contract.declarations.reduce((result, decl) => {
            if (decl.kind === "constant_def") {
                result.push(decl.id);
            }
            return result;
        }, []);
    }
    /**
     * Retrieves fields defined within a specified contract.
     * @param contractId The ID of the contract.
     * @returns An array of AstFieldDecl or undefined if no contract is found.
     */
    getContractFields(contractId) {
        const contract = this.getContract(contractId);
        if (!contract) {
            return undefined;
        }
        return contract.declarations.reduce((result, decl) => {
            if (decl.kind === "field_decl") {
                result.push(decl);
            }
            return result;
        }, []);
    }
    /**
     * Retrieves fields defined in the traits the contract inherited.
     * @param contractId The ID of the contract.
     * @returns An array of AstFieldDecl or undefined if no contract or one its trait are found.
     */
    getInheritedFields(contractId) {
        const contract = this.getContract(contractId);
        if (!contract) {
            return undefined;
        }
        const fields = [];
        contract.traits.forEach((traitId) => {
            const trait = this.findTrait(traitId.text);
            if (trait === undefined) {
                return undefined;
            }
            trait.declarations.forEach((decl) => {
                if (decl.kind === "field_decl") {
                    fields.push(decl);
                }
            });
        });
        return fields;
    }
    /**
     * Retrieves items of specified kinds defined within a given file.
     * @param kinds An array of kinds to filter the items.
     * @param params Additional parameters:
     * - includeStdlib: If true, includes items defined in stdlib.
     * - filename: The filename to filter items by (required).
     * @returns An array of matching AstNode items.
     */
    getItemsByKinds(kinds, params) {
        const result = [];
        // TODO: Should be rewritten: https://github.com/nowarp/misti/issues/186
        for (const kind of kinds) {
            switch (kind) {
                case "function_def":
                case "receiver":
                case "contract_init":
                    result.push(...Array.from(this.getFunctions(params)));
                    break;
                case "constant_def":
                case "constant_decl":
                    result.push(...Array.from(this.getConstants({ ...params, includeContract: true })));
                    break;
                case "contract":
                    result.push(...Array.from(this.getContracts(params)));
                    break;
                case "native_function_decl":
                    result.push(...Array.from(this.getNativeFunctions(params)));
                    break;
                case "asm_function_def":
                    result.push(...Array.from(this.getAsmFunctions(params)));
                    break;
                case "primitive_type_decl":
                    result.push(...Array.from(this.getPrimitives(params)));
                    break;
                case "struct_decl":
                    result.push(...Array.from(this.getStructs(params)));
                    break;
                case "message_decl":
                    result.push(...Array.from(this.getMessages(params)));
                    break;
                case "trait":
                    result.push(...Array.from(this.getTraits(params)));
                    break;
                default:
                    break;
            }
        }
        return params.filename
            ? result.filter((item) => "loc" in item && item.loc.file === params.filename)
            : result;
    }
    /**
     * Retrieves return types from the callable functions available within CompilationUnit.
     */
    getReturnTypes() {
        const result = new Map();
        this.asmFunctions.forEach((f) => result.set((0, imports_1.idText)(f.name), f.return));
        this.functions.forEach((f) => {
            if (!this.isContractItem(f.id))
                result.set(
                // Other kinds of functions cannot be present on the top-level
                (0, imports_1.idText)(f.name), f.return);
        });
        return result;
    }
    /**
     * Retrieves return types from the callable methods defined in the given contract/trait.
     * @param entryId AST identifier of the contract or trait to analyze.
     * @param withTraits Include methods from directly or indirectly inherited traits.
     */
    getMethodReturnTypes(entryId, withTraits = true, visited = new Set()) {
        let result = new Map();
        // Avoid recursion if used on AST before typechecking
        if (visited.has(entryId))
            return result;
        visited.add(entryId);
        // Check the current contract or trait
        const contractEntries = this.contractEntries.get(entryId);
        if (contractEntries) {
            this.functions.forEach((f) => {
                // Don't consider receivers/inits since we cannot call them from the contract
                if (f.kind === "function_def" && contractEntries.has(f.id))
                    result.set((0, imports_1.idText)(f.name), f.return);
            });
        }
        // Recursively process inherited traits
        if (withTraits) {
            const contractOrTrait = this.hasContract(entryId)
                ? this.getContract(entryId)
                : this.getTrait(entryId);
            if (!contractOrTrait) {
                return result;
            }
            contractOrTrait.traits.forEach((traitName) => {
                const trait = this.findTrait((0, imports_1.idText)(traitName));
                if (trait) {
                    result = (0, util_1.mergeMaps)(result, this.getMethodReturnTypes(trait.id, true, visited));
                }
            });
        }
        return result;
    }
    /**
     * Returns true iff `itemId` present in any of the contract/trait items.
     */
    isContractItem(itemId) {
        if (this.isContractItemCache.has(itemId))
            return this.isContractItemCache.get(itemId);
        const result = [...this.contractEntries.values()].some((set) => set.has(itemId));
        this.isContractItemCache.set(itemId, result);
        return result;
    }
    isContractItemCache = new Map();
    fileMatches = (node, filename) => node.loc.file !== null && node.loc.file === filename;
    *filterIterator(iterator, condition) {
        for (const item of iterator) {
            if (condition(item)) {
                yield item;
            }
        }
    }
}
exports.AstStore = AstStore;
