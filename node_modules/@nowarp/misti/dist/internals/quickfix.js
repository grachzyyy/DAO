"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.quickFixToString = exports.makeDelete = exports.makeInsert = exports.makeReplace = exports.makeReplacement = exports.makeRange = exports.makeEndPos = exports.makeStartPos = void 0;
const exceptions_1 = require("./exceptions");
const util_1 = require("./util");
/**
 * Creates a Position object from a SrcInfo location.
 *
 * @param loc - Source information containing interval data
 * @returns Position object with line and column numbers
 */
function makeStartPos(loc) {
    const lineAndColumn = loc.interval.getLineAndColumn();
    return {
        line: lineAndColumn.lineNum,
        column: lineAndColumn.colNum,
    };
}
exports.makeStartPos = makeStartPos;
/**
 * Creates an end Position object from a SrcInfo location.
 *
 * @param loc - Source information containing interval data
 * @returns Position object representing the end position
 */
function makeEndPos(loc) {
    const endLineAndColumn = loc.interval.contents
        .substring(0, loc.interval.endIdx)
        .split("\n");
    const lastLine = endLineAndColumn.length;
    const lastColumn = endLineAndColumn[endLineAndColumn.length - 1].length + 1;
    return {
        line: lastLine,
        column: lastColumn,
    };
}
exports.makeEndPos = makeEndPos;
/**
 * Creates a Range object from start and optional end SrcInfo.
 * If end is not provided, uses start for both positions.
 *
 * @param start - Source information for the start position
 * @param end - Optional source information for the end position
 * @returns Range object with start and end positions
 */
function makeRange(start, end) {
    return {
        start: makeStartPos(start),
        end: makeEndPos(end || start),
    };
}
exports.makeRange = makeRange;
/**
 * Creates a Replacement object.
 *
 * @param range - Range of positions of the replacement
 * @param value - Text to replace the content between start and end
 * @returns A Replacement object
 */
function makeReplacement(range, value) {
    return { range, value };
}
exports.makeReplacement = makeReplacement;
/**
 * Creates a 'replace' QuickFix.
 *
 * @param description - Human-readable description of the quick fix
 * @param shown - Whether Misti should display this warning in CLI or it is just for the LSP.
 * @param replacements - Array of Replacement objects
 * @returns A QuickFix of kind 'replace'
 */
function makeReplace(description, shown, ...replacements) {
    if (replacements.length === 0) {
        throw exceptions_1.InternalException.make("QuickFix: Replacements list cannot be empty");
    }
    return {
        kind: "replace",
        shown,
        description,
        replacements,
    };
}
exports.makeReplace = makeReplace;
/**
 * Creates an 'insert' QuickFix.
 *
 * @param description - Human-readable description of the quick fix
 * @param shown - Whether Misti should display this warning in CLI or it is just for the LSP.
 * @param insertion - Replacement object representing the insertion
 * @returns A QuickFix of kind 'insert'
 */
function makeInsert(description, shown, insertion) {
    return {
        kind: "insert",
        shown,
        description,
        insertion,
    };
}
exports.makeInsert = makeInsert;
/**
 * Creates a 'delete' QuickFix.
 *
 * @param description - Human-readable description of the quick fix
 * @param shown - Whether Misti should display this warning in CLI or it is just for the LSP.
 * @param range - Range position of the text to delete
 * @returns A QuickFix of kind 'delete'
 */
function makeDelete(description, shown, range) {
    return {
        kind: "delete",
        description,
        shown,
        range,
    };
}
exports.makeDelete = makeDelete;
/**
 * Returns a human-readable string representation of a QuickFix.
 *
 * @param qf - The QuickFix to convert to string
 * @returns A string representation of the QuickFix
 */
function quickFixToString(qf) {
    switch (qf.kind) {
        case "replace":
            return `Replace with: ${qf.replacements.map((r) => r.value).join(", ")}`;
        case "insert":
            return `Insert: ${qf.insertion.value}`;
        case "delete":
            return qf.description || `Delete selected code`;
        default:
            (0, util_1.unreachable)(qf);
    }
}
exports.quickFixToString = quickFixToString;
