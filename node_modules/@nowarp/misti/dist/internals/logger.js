"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TraceLogger = exports.DebugLogger = exports.QuietLogger = exports.Logger = exports.LogLevel = void 0;
const exceptions_1 = require("./exceptions");
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["DEBUG"] = 0] = "DEBUG";
    LogLevel[LogLevel["INFO"] = 1] = "INFO";
    LogLevel[LogLevel["WARN"] = 2] = "WARN";
    LogLevel[LogLevel["ERROR"] = 3] = "ERROR";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
/**
 * Provides a customizable logging mechanism across different levels of verbosity.
 */
class Logger {
    saveJson;
    logFunctions;
    jsonLogs;
    contextMap = new Map();
    static asyncLocalStorage = new Map();
    showTimestamps;
    constructor(logMapping, saveJson = false, showTimestamps = false) {
        this.saveJson = saveJson;
        this.showTimestamps = showTimestamps;
        this.jsonLogs = new Map([
            [LogLevel.DEBUG, []],
            [LogLevel.INFO, []],
            [LogLevel.WARN, []],
            [LogLevel.ERROR, []],
        ]);
        const defaultLogFunctions = new Map([
            [LogLevel.DEBUG, undefined],
            [LogLevel.INFO, this.createLogFunction(console.log, LogLevel.INFO)],
            [LogLevel.WARN, this.createLogFunction(console.warn, LogLevel.WARN)],
            [LogLevel.ERROR, this.createLogFunction(console.error, LogLevel.ERROR)],
        ]);
        this.logFunctions = defaultLogFunctions;
        if (logMapping) {
            Object.entries(logMapping).forEach(([level, func]) => {
                const logLevel = Number(level);
                this.logFunctions.set(logLevel, func ? this.createLogFunction(func, logLevel) : func);
            });
        }
    }
    createLogFunction(baseFunc, level) {
        return (msg) => {
            if (this.saveJson)
                this.jsonLogs.get(level)?.push(msg);
            else
                baseFunc(msg);
        };
    }
    getJsonLogs() {
        if (!this.saveJson) {
            throw exceptions_1.ExecutionException.make("JSON logging not enabled for this logger instance");
        }
        return {
            debug: this.jsonLogs.get(LogLevel.DEBUG) ?? [],
            info: this.jsonLogs.get(LogLevel.INFO) ?? [],
            warn: this.jsonLogs.get(LogLevel.WARN) ?? [],
            error: this.jsonLogs.get(LogLevel.ERROR) ?? [],
        };
    }
    /**
     * Gets the current task ID from the async context
     */
    getCurrentTaskId() {
        const threadId = Logger.asyncLocalStorage.get(
        // Use a simple approximation of thread ID in single-threaded JS
        Math.floor(Date.now() / 1000) % 1000000);
        return threadId;
    }
    /**
     * Creates a new execution context and returns a function to run code within it.
     * @param contextName The name of the context to use in logs
     * @returns A function that executes the provided callback in the context
     */
    withContext(contextName) {
        return async (fn) => {
            const taskId = `task-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
            const threadId = Math.floor(Date.now() / 1000) % 1000000;
            // Set context and task ID
            this.setContext(taskId, contextName);
            Logger.asyncLocalStorage.set(threadId, taskId);
            try {
                return await fn();
            }
            finally {
                this.clearContext(taskId);
                Logger.asyncLocalStorage.delete(threadId);
            }
        };
    }
    /**
     * Sets the context for a specific task ID.
     * @param taskId Unique identifier for the current task/thread
     * @param context The context string to prepend to log messages.
     */
    setContext(taskId, context) {
        this.contextMap.set(taskId, context);
    }
    /**
     * Clears the context for a specific task ID.
     * @param taskId Unique identifier for the current task/thread
     */
    clearContext(taskId) {
        this.contextMap.delete(taskId);
    }
    /**
     * Formats the current time as [HH:MM:SS.ms]
     * @returns Formatted timestamp string
     */
    getTimestamp() {
        const now = new Date();
        const hours = now.getHours().toString().padStart(2, "0");
        const minutes = now.getMinutes().toString().padStart(2, "0");
        const seconds = now.getSeconds().toString().padStart(2, "0");
        const milliseconds = now.getMilliseconds().toString().padStart(3, "0");
        return `[${hours}:${minutes}:${seconds}.${milliseconds}]`;
    }
    /**
     * Logs a message at the specified log level if a corresponding log function is defined.
     * @param level The severity level of the log entry.
     * @param msg The content of the log message.
     * @param taskId Optional task identifier to retrieve the correct context
     */
    log(level, msg, taskId) {
        const logFunction = this.logFunctions.get(level);
        if (logFunction) {
            // Try to get task ID from parameter or current context
            const effectiveTaskId = taskId || this.getCurrentTaskId();
            let contextPrefix = "";
            if (effectiveTaskId && this.contextMap.has(effectiveTaskId)) {
                contextPrefix = `[${this.contextMap.get(effectiveTaskId)}] `;
            }
            const timestampPrefix = this.showTimestamps
                ? `${this.getTimestamp()} `
                : "";
            logFunction(`${timestampPrefix}${contextPrefix}${msg}`);
        }
    }
    /**
     * Logs a debug message.
     * @param msg The debug message to log.
     * @param taskId Optional task identifier to retrieve the correct context
     */
    debug(msg, taskId) {
        this.log(LogLevel.DEBUG, msg, taskId);
        if (this.saveJson) {
            this.jsonLogs.get(LogLevel.DEBUG).push(msg.toString());
        }
    }
    /**
     * Logs an info message.
     * @param msg The info message to log.
     * @param taskId Optional task identifier to retrieve the correct context
     */
    info(msg, taskId) {
        this.log(LogLevel.INFO, msg, taskId);
        if (this.saveJson) {
            this.jsonLogs.get(LogLevel.INFO).push(msg.toString());
        }
    }
    /**
     * Logs a warning message.
     * @param msg The warning message to log.
     * @param taskId Optional task identifier to retrieve the correct context
     */
    warn(msg, taskId) {
        this.log(LogLevel.WARN, msg, taskId);
        if (this.saveJson) {
            this.jsonLogs.get(LogLevel.WARN).push(msg.toString());
        }
    }
    /**
     * Logs an error message.
     * @param msg The error message to log.
     * @param taskId Optional task identifier to retrieve the correct context
     */
    error(msg, taskId) {
        this.log(LogLevel.ERROR, msg, taskId);
        if (this.saveJson) {
            this.jsonLogs.get(LogLevel.ERROR).push(msg.toString());
        }
    }
}
exports.Logger = Logger;
/**
 * Logger that silences all logs.
 */
class QuietLogger extends Logger {
    constructor(saveJson = false, showTimestamps = false) {
        super({
            [LogLevel.INFO]: undefined,
            [LogLevel.WARN]: undefined,
            [LogLevel.ERROR]: undefined,
        }, saveJson, showTimestamps);
    }
}
exports.QuietLogger = QuietLogger;
/**
 * Logger that enables debug level logging to stdin.
 */
class DebugLogger extends Logger {
    constructor(saveJson = false, showTimestamps = false) {
        super({
            [LogLevel.DEBUG]: console.log,
        }, saveJson, showTimestamps);
    }
}
exports.DebugLogger = DebugLogger;
function trace(...args) {
    console.log(...args);
    console.trace();
}
/**
 * Logger that adds backtraces to each log function.
 */
class TraceLogger extends Logger {
    constructor(saveJson = false, showTimestamps = false) {
        super({
            [LogLevel.DEBUG]: trace,
            [LogLevel.INFO]: trace,
            [LogLevel.WARN]: trace,
            [LogLevel.ERROR]: trace,
        }, saveJson, showTimestamps);
    }
}
exports.TraceLogger = TraceLogger;
