"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MistiEnv = exports.MistiConfig = void 0;
const exceptions_1 = require("./exceptions");
const detector_1 = require("../detectors/detector");
const createNodeFileSystem_1 = require("../vfs/createNodeFileSystem");
const zod_1 = require("zod");
const DetectorConfigSchema = zod_1.z.object({
    modulePath: zod_1.z.string().optional(),
    className: zod_1.z.string(),
});
const ToolConfigSchema = zod_1.z.object({
    className: zod_1.z.string(),
    options: zod_1.z.record(zod_1.z.unknown()).optional(),
});
const WarningSuppressionSchema = zod_1.z.object({
    detector: zod_1.z.string(),
    position: zod_1.z.string(),
});
const VerbositySchema = zod_1.z.enum(["quiet", "debug", "default"]);
const ConfigSchema = zod_1.z.object({
    detectors: zod_1.z.array(DetectorConfigSchema).optional(),
    tools: zod_1.z.array(ToolConfigSchema).optional(),
    suppressions: zod_1.z.array(WarningSuppressionSchema).optional(),
    ignoredProjects: zod_1.z.array(zod_1.z.string()).optional(),
    soufflePath: zod_1.z.string().optional(),
    souffleVerbose: zod_1.z.boolean().optional(),
    tactStdlibPath: zod_1.z.string().optional(),
    unusedPrefix: zod_1.z.string().optional().default("_"),
    verbosity: VerbositySchema.optional().default("default"),
});
/**
 * Represents content of the Misti configuration file (misti.config.json).
 */
class MistiConfig {
    detectors;
    tools;
    suppressions;
    ignoredProjects;
    soufflePath = "/tmp/misti/souffle";
    souffleVerbose;
    tactStdlibPath;
    unusedPrefix;
    verbosity;
    fs;
    constructor({ configPath = undefined, detectors = undefined, tools = undefined, allDetectors = false, fs = (0, createNodeFileSystem_1.createNodeFileSystem)(process.cwd()), } = {}) {
        let configData;
        this.fs = fs;
        if (configPath) {
            try {
                const configFileContents = fs.readFile(configPath).toString("utf8");
                configData = JSON.parse(configFileContents);
            }
            catch (err) {
                if (err instanceof Error) {
                    throw exceptions_1.ExecutionException.make(`Could not load or parse config file (${configPath}): ${err.message}`);
                }
                else {
                    throw err;
                }
            }
            // Override detectors if `--enabled-detectors` is set
            if (detectors !== undefined) {
                configData = {
                    ...configData,
                    detectors: this.createDetectorConfigs(detectors, allDetectors),
                };
            }
            // Override tools if `--tools` is set
            if (tools !== undefined) {
                configData = {
                    ...configData,
                    tools: tools || [],
                };
            }
        }
        else {
            // Use default detectors and tools if no config file is provided
            configData = {
                detectors: this.createDetectorConfigs(detectors, allDetectors),
                tools: tools || [],
                ignoredProjects: [],
                soufflePath: "/tmp/misti/souffle",
                souffleVerbose: false,
                tactStdlibPath: undefined,
                unusedPrefix: "_",
                verbosity: "default",
            };
        }
        try {
            const parsedConfig = ConfigSchema.parse(configData);
            this.detectors = parsedConfig.detectors || [];
            this.tools = parsedConfig.tools || [];
            this.suppressions = this.parseSuppressions(parsedConfig.suppressions);
            this.ignoredProjects = parsedConfig.ignoredProjects || [];
            this.tactStdlibPath = parsedConfig.tactStdlibPath;
            this.unusedPrefix = parsedConfig.unusedPrefix;
            this.verbosity = parsedConfig.verbosity;
        }
        catch (err) {
            if (err instanceof zod_1.z.ZodError) {
                throw exceptions_1.ExecutionException.make(`Configuration error: ${err.message}`);
            }
            else {
                throw err;
            }
        }
    }
    createDetectorConfigs(detectors, allDetectors) {
        if (detectors !== undefined) {
            const builtinDetectors = new Set((0, detector_1.getAllDetectors)());
            return detectors.reduce((acc, detector) => {
                if (detector === "") {
                    // The user has specified the empty value in the config.
                    return acc;
                }
                if (builtinDetectors.has(detector)) {
                    acc.push({ className: detector });
                }
                else {
                    const parts = detector.split(":");
                    if (parts.length !== 2) {
                        throw exceptions_1.ExecutionException.make(`Cannot find built-in or custom detector: ${detector}`);
                    }
                    const [modulePath, className] = parts;
                    acc.push({ className, modulePath });
                }
                return acc;
            }, []);
        }
        return (allDetectors ? detector_1.getAllDetectors : detector_1.getEnabledDetectors)().map((name) => ({ className: name }));
    }
    /**
     * Parses the suppressions from the configuration file.
     */
    parseSuppressions(suppressions) {
        if (!suppressions)
            return [];
        return suppressions.map(({ detector, position }) => {
            const parts = position.split(":");
            if (parts.length !== 3) {
                throw exceptions_1.ExecutionException.make(`Invalid suppression position format: ${position}. Expected format: fileName:line:column`);
            }
            const [file, lineStr, colStr] = parts;
            const line = parseInt(lineStr, 10);
            const col = parseInt(colStr, 10);
            if (isNaN(line) || isNaN(col)) {
                throw exceptions_1.ExecutionException.make(`Invalid line or column number in suppression position: ${position}`);
            }
            return {
                detector: detector,
                file,
                line,
                col,
            };
        });
    }
}
exports.MistiConfig = MistiConfig;
/**
 * Environment variables to configure advanced Misti options.
 */
class MistiEnv {
    /**
     * Timeout for the detector execution in milliseconds.
     */
    static MISTI_TIMEOUT = parseInt(process.env.MISTI_TIMEOUT || "15000", 10);
    /**
     * Whether to trace the execution.
     */
    static MISTI_TRACE = process.env.MISTI_TRACE
        ? process.env.MISTI_TRACE === "1"
        : false;
}
exports.MistiEnv = MistiEnv;
