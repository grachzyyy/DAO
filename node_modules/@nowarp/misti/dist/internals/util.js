"use strict";
/**
 * Additional generic TypeScript functions used in the project.
 *
 * @packageDocumentation
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isTest = exports.isBrowser = exports.hasSubdirs = exports.unreachable = exports.intersectMaps = exports.isMapSubsetOf = exports.mergeMaps = exports.intersectLists = exports.isListSubsetOf = exports.mergeLists = exports.intersectSets = exports.isSetSubsetOf = exports.mergeSets = void 0;
const exceptions_1 = require("./exceptions");
const path_1 = __importDefault(require("path"));
const mergeSets = (lhs, rhs) => new Set([...lhs, ...rhs]);
exports.mergeSets = mergeSets;
const isSetSubsetOf = (lhs, rhs, eq = (a, b) => a === b) => [...lhs].every((elem) => [...rhs].some((rElem) => eq(elem, rElem)));
exports.isSetSubsetOf = isSetSubsetOf;
const intersectSets = (setA, setB) => new Set([...setA].filter((item) => setB.has(item)));
exports.intersectSets = intersectSets;
const mergeLists = (lhs, rhs) => [...lhs, ...rhs];
exports.mergeLists = mergeLists;
const isListSubsetOf = (lhs, rhs, eq = (a, b) => a === b) => lhs.every((elem) => rhs.some((rElem) => eq(elem, rElem)));
exports.isListSubsetOf = isListSubsetOf;
const intersectLists = (l1, l2) => l1.filter((element) => l2.includes(element));
exports.intersectLists = intersectLists;
const mergeMaps = (lhs, rhs) => new Map([...lhs, ...rhs]);
exports.mergeMaps = mergeMaps;
const isMapSubsetOf = (lhs, rhs, eq = (a, b) => a === b) => [...lhs].every(([key, value]) => rhs.has(key) && eq(value, rhs.get(key)));
exports.isMapSubsetOf = isMapSubsetOf;
const intersectMaps = (mapA, mapB) => new Map([...mapA].filter(([key, value]) => mapB.has(key) && mapB.get(key) === value));
exports.intersectMaps = intersectMaps;
/**
 * Unreachable case for exhaustive checking.
 */
function unreachable(value) {
    throw exceptions_1.InternalException.make(`Reached impossible case`, { node: value });
}
exports.unreachable = unreachable;
/**
 * Checks if there are subdirectories present in the absolute path.
 */
function hasSubdirs(filePath, subdirs) {
    const splitPath = filePath.split(path_1.default.sep);
    return subdirs.every((dir) => splitPath.includes(dir));
}
exports.hasSubdirs = hasSubdirs;
/**
 * Determines if code is running in a browser environment.
 * @returns true if in browser, false otherwise
 */
function isBrowser() {
    return (typeof document !== "undefined" &&
        document !== null &&
        document.createElement !== undefined);
}
exports.isBrowser = isBrowser;
/**
 * Determines if code is running from Jest test.
 * @returns true if in test environment, false otherwise
 */
function isTest() {
    return process.env.JEST_WORKER_ID !== undefined;
}
exports.isTest = isTest;
