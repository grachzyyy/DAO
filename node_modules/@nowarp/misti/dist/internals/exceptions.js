"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.throwZodError = exports.tryMsg = exports.ExecutionException = exports.InternalException = exports.TactException = void 0;
const version_1 = require("../version");
const imports_1 = require("./tact/imports");
const fs = __importStar(require("fs"));
const json_bigint_1 = __importDefault(require("json-bigint"));
const path = __importStar(require("path"));
const zod_1 = require("zod");
const REPORTS_DIR = "/tmp/misti/reports";
const SEPARATOR = "============================================================";
function generateReportText(reportFilePath) {
    return `The error report was saved to the file: ${reportFilePath}. Please help us publishing it and the input sources at: https://github.com/nowarp/misti/issues/new.`;
}
/**
 * Represents all the errors coming from the Tact compiler API.
 */
class TactException {
    constructor() { }
    static make(error) {
        if (!(error instanceof Error)) {
            throw error;
        }
        const tactStack = error.stack;
        // Display errors that should not be reported as issues.
        if (this.isParserError(tactStack)) {
            return new Error(`Syntax error: ${error.message}`);
        }
        if (this.isCompilationError(tactStack)) {
            return new Error(`Compilation error: ${error.message}`);
        }
        // Display an error that should be reported to issues.
        const errorKind = "Internal Tact Compiler Error:";
        const fullMsg = [
            errorKind,
            SEPARATOR,
            error.message,
            tactStack,
            SEPARATOR,
            getCmd(),
            getVersions(),
        ].join("\n");
        const shortMsg = [errorKind, error.message].join("\n");
        // Dump full message to the file.
        const reportFilePath = dumpReportFile(fullMsg, shortMsg);
        const reportText = generateReportText(reportFilePath);
        // Display short message to the user.
        return new Error([shortMsg, reportText].join("\n"));
    }
    /**
     * Returns true if `stack` represents a syntax error.
     */
    static isParserError(stack) {
        return (stack !== undefined &&
            (stack.includes("at throwParseError") ||
                stack.includes("parser-error.js")));
    }
    /**
     * Returns true if `stack` represents a compilation error.
     */
    static isCompilationError(stack) {
        return stack !== undefined && stack.includes("at throwCompilationError");
    }
}
exports.TactException = TactException;
/**
 * Attempts to pretty-print the input, falling back to JSON stringification if it fails.
 * @param input The object to pretty-print or stringify.
 * @returns A string representation of the input.
 */
function prettyPrintOrStringify(input) {
    try {
        return `AST:\n${(0, imports_1.prettyPrint)(input)}`;
    }
    catch (error) {
        try {
            return json_bigint_1.default.stringify(input, null, 2);
        }
        catch (jsonError) {
            return `[Unable to stringify object: ${jsonError}]`;
        }
    }
}
/**
 * Internal error, typically caused by a bug in Misti or incorrect API usage.
 */
class InternalException {
    constructor() { }
    static make(msg, { loc = undefined, node = undefined, generateReport = true, } = {}) {
        const locStr = makeLocationString(loc);
        const errorKind = `Internal Misti Error${locStr}:`;
        const fullMsg = [
            errorKind,
            msg,
            ...(node === undefined
                ? []
                : [`${SEPARATOR}${prettyPrintOrStringify(node)}`]),
            SEPARATOR,
            getCurrentStackTrace(),
            SEPARATOR,
            getCmd(),
            getVersions(),
        ].join("\n");
        const shortMsg = [errorKind, msg, getVersions()].join("\n");
        if (!generateReport) {
            return new Error(shortMsg);
        }
        const reportFilePath = dumpReportFile(fullMsg, shortMsg);
        const reportText = generateReportText(reportFilePath);
        // Display short message to the user.
        return new Error([shortMsg, reportText].join("\n"));
    }
}
exports.InternalException = InternalException;
/**
 * An error caused by incorrect actions of the user, such as wrong configuration,
 * problems in the environment, wrong CLI options.
 */
class ExecutionException {
    constructor() { }
    static make(msg, { loc = undefined, } = {}) {
        const locStr = makeLocationString(loc);
        const errorKind = `Execution Error${locStr}:`;
        const shortMsg = [errorKind, msg].join("\n");
        return new Error(shortMsg);
    }
}
exports.ExecutionException = ExecutionException;
function makeLocationString(loc) {
    return loc
        ? (() => {
            const { lineNum, colNum } = loc.interval.getLineAndColumn();
            return lineNum !== 0 && colNum !== 0 ? ` at ${lineNum}:${colNum}` : "";
        })()
        : "";
}
/**
 * Returns backtrace of the JS script upon execution.
 */
function getCurrentStackTrace() {
    try {
        throw new Error();
    }
    catch (error) {
        if (error instanceof Error) {
            return `Misti Backtrace: ${error.stack}` || "No stack trace available";
        }
        else {
            return "Unable to get stack trace";
        }
    }
}
/**
 * @returns Command used to execute code, like: "$0 $@".
 */
function getCmd() {
    return `Command: ${process.argv.join(" ")}`;
}
/**
 * @returns Tact and Misti versions string.
 */
function getVersions() {
    return `Using Tact ${version_1.TACT_VERSION}; Misti ${version_1.MISTI_VERSION}`;
}
/**
 * Saves the comprehensive information on this error to the text file that is supposed to be published in the issue.
 * @param fullMsg A error message to save to file.
 * @param shortMsg A error message to display to the user if it is not possible to create a file.
 * @returns Path to the created file.
 */
function dumpReportFile(fullMsg, shortMsg, reportsDir = REPORTS_DIR) {
    try {
        fs.mkdirSync(reportsDir, { recursive: true });
        const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
        const reportFile = path.join(reportsDir, `${timestamp}.txt`);
        fs.writeFileSync(reportFile, fullMsg);
        return reportFile;
    }
    catch (error) {
        throw new Error(shortMsg);
    }
}
/**
 * Wraps the `try` clause adding an extra context to the exception text.
 */
function tryMsg(callback, message) {
    try {
        callback();
    }
    catch (err) {
        if (!(err instanceof Error)) {
            throw err;
        }
        throw new Error(`${message}: ${err.message}`);
    }
}
exports.tryMsg = tryMsg;
/**
 * Throws an ExecutionException with a human-readable ZodError message.
 * @param err The ZodError to throw.
 */
function throwZodError(err, { msg = undefined, help = undefined, } = {}) {
    if (err instanceof zod_1.ZodError) {
        const formattedErrors = err.errors
            .map((e) => {
            const path = e.path.length ? e.path.join(" > ") : "root";
            return `- ${e.message} at ${path}`;
        })
            .join("\n");
        throw ExecutionException.make(`${msg ? msg + "\n" : ""}${formattedErrors}${help ? "\n\n" + help : ""}`);
    }
    else {
        throw err;
    }
}
exports.throwZodError = throwZodError;
