"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SouffleSolver = void 0;
const exceptions_1 = require("../exceptions");
const souffle_1 = require("@nowarp/souffle");
const json_bigint_1 = __importDefault(require("json-bigint"));
/**
 * Basic block definition added in all the Souffle programs.
 */
const BB_FACT = (idx) => `bb_${idx}`;
/**
 * Provides a framework for solving dataflow analysis problems using the Soufflé solver.
 */
class SouffleSolver {
    detectorId;
    ctx;
    cu;
    cfg;
    mapper;
    /**
     * @param detectorId An unique identifier of the detector using this solver.
     * @param cu Compilation unit under the analysis.
     * @param cfg CFG under the analysis.
     * @param mapper An object that defines the transfer operation for a node and its state.
     */
    constructor(detectorId, ctx, cu, cfg, mapper) {
        this.detectorId = detectorId;
        this.ctx = ctx;
        this.cu = cu;
        this.cfg = cfg;
        this.mapper = mapper;
    }
    /**
     * Adds common declarations to represent the dataflow problem.
     * @param ctx The Souffle program where the relations are to be added.
     */
    addDataflowDecls(ctx) {
        // Basic block declaration
        ctx.add((0, souffle_1.relation)("bb", [["bb", "Symbol"]], undefined));
        // Predecessor declaration
        ctx.add((0, souffle_1.relation)("pred", [
            ["bb_src", "Symbol"],
            ["bb_dst", "Symbol"],
        ], undefined));
    }
    /**
     * Adds common facts to represent the dataflow problem.
     * @param ctx The Souffle program where the relations are to be added.
     */
    addDataflowFacts(ctx) {
        this.cfg.forEachBasicBlock(this.cu.ast, (_stmt, node) => {
            ctx.addFact("bb", [BB_FACT(node.idx)]);
        });
        this.cfg.forEachEdge((edge) => {
            ctx.addFact("edge", [BB_FACT(edge.src), BB_FACT(edge.dst)]);
        });
    }
    /**
     * Executes the Souffle program generated within the solver.
     */
    execute(ctx) {
        const executor = new souffle_1.SouffleSyncExecutor({
            inputDir: this.ctx.config.soufflePath,
            outputDir: this.ctx.config.soufflePath,
        });
        return executor.execute(ctx);
    }
    /**
     * Converts the souffle execution results to the solver results as required by the class interface.
     */
    createSouffleResults(_souffleResults) {
        throw new Error("NYI");
    }
    solve() {
        const ctx = new souffle_1.SouffleContext(this.detectorId);
        this.addDataflowDecls(ctx);
        this.mapper.addDecls(ctx);
        this.mapper.addRules(ctx);
        this.addDataflowFacts(ctx);
        this.mapper.addConstraints(ctx);
        const result = this.execute(ctx);
        if (result.kind !== "structured") {
            throw exceptions_1.InternalException.make(`Error executing Soufflé:\n${result.kind === "error" ? result.stderr : "Cannot unmarshal raw output:\n" + json_bigint_1.default.stringify(result.results, null, 2)}`);
        }
        return this.createSouffleResults(Array.from(result.results.entries.values()));
    }
}
exports.SouffleSolver = SouffleSolver;
