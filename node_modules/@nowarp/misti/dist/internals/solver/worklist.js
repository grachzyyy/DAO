"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WideningWorklistSolver = exports.WorklistSolver = exports.AbstractWorklistSolver = void 0;
const results_1 = require("./results");
const exceptions_1 = require("../exceptions");
const ir_1 = require("../ir");
/**
 * Provides a framework for solving dataflow analysis problems by employing a worklist-based algorithm.
 *
 * This class encapsulates the CFG, node state transformations, and lattice
 * properties necessary for the computation of fixpoints in dataflow equations.
 */
class AbstractWorklistSolver {
    cu;
    cfg;
    transfer;
    lattice;
    kind;
    /**
     * @param transfer An object that defines the transfer operation for a node and its state.
     * @param lattice An instance of a semilattice that defines the necessary operations.
     * @param kind The kind of analysis ("forward" or "backward").
     */
    constructor(cu, cfg, transfer, lattice, kind) {
        this.cu = cu;
        this.cfg = cfg;
        this.transfer = transfer;
        this.lattice = lattice;
        this.kind = kind;
    }
    /**
     * Finds a fixpoint using the worklist algorithm.
     * @returns The results of solving the dataflow problem.
     */
    findFixpoint() {
        // Track results and how many times we've visited each node
        const results = new results_1.SolverResults();
        const iterationCounts = new Map();
        // Initialize each block with lattice extremal value (⊥ for join, ⊤ for meet)
        const worklist = [...this.cfg.nodes];
        worklist.forEach((bb) => {
            if (this.isJoinSemilattice(this.lattice)) {
                results.setState(bb.idx, this.lattice.bottom());
            }
            else if (this.isMeetSemilattice(this.lattice)) {
                results.setState(bb.idx, this.lattice.top());
            }
            else {
                throw exceptions_1.InternalException.make("Unsupported semilattice type");
            }
            iterationCounts.set(bb.idx, 0);
        });
        while (worklist.length > 0) {
            const bb = worklist.shift();
            // Compute input state by combining states from predecessors/successors
            // depending on analysis direction (forward/backward)
            let inState;
            const neighborStates = (this.kind === "forward"
                ? (0, ir_1.getPredecessors)(this.cfg, bb)
                : (0, ir_1.getSuccessors)(this.cfg, bb)).map((neighbor) => results.getState(neighbor.idx));
            // Apply lattice operation (join/meet) to combine neighbor states
            if (this.isJoinSemilattice(this.lattice)) {
                const joinLattice = this.lattice;
                inState = neighborStates.reduce((acc, state) => {
                    return joinLattice.join(acc, state);
                }, joinLattice.bottom());
            }
            else if (this.isMeetSemilattice(this.lattice)) {
                const meetLattice = this.lattice;
                inState = neighborStates.reduce((acc, state) => {
                    return meetLattice.meet(acc, state);
                }, meetLattice.top());
            }
            else {
                throw exceptions_1.InternalException.make("Unsupported semilattice type");
            }
            // Fetch and validate the AST statement for this basic block
            const stmt = this.cu.ast.getStatement(bb.stmtID);
            if (stmt === undefined) {
                throw exceptions_1.InternalException.make(`Cannot find statement #${bb.stmtID} defined within node #${bb.idx}`);
            }
            // Apply transfer function and get previous state for comparison
            let currentOut = this.transfer.transfer(inState, bb, stmt);
            const previousOut = results.getState(bb.idx);
            // Track visits to handle widening/narrowing in derived classes
            const iterations = iterationCounts.get(bb.idx) + 1;
            iterationCounts.set(bb.idx, iterations);
            // Let derived solver classes apply their state update strategy
            currentOut = this.updateState(previousOut, currentOut, iterations);
            // If state changed (not less than or equal), update and propagate
            if (!this.lattice.leq(currentOut, previousOut)) {
                results.setState(bb.idx, currentOut);
                worklist.push(...(this.kind === "forward"
                    ? (0, ir_1.getSuccessors)(this.cfg, bb)
                    : (0, ir_1.getPredecessors)(this.cfg, bb)));
            }
        }
        return results;
    }
    solve() {
        return this.findFixpoint();
    }
    isJoinSemilattice(lattice) {
        return "join" in lattice && typeof lattice.join === "function";
    }
    isMeetSemilattice(lattice) {
        return "meet" in lattice && typeof lattice.meet === "function";
    }
}
exports.AbstractWorklistSolver = AbstractWorklistSolver;
/**
 * WorklistSolver performs a standard worklist-based iterative analysis relying
 * solely on the lattice's join or meet operation to update states.
 *
 * @template State The type representing the state in the analysis.
 */
class WorklistSolver extends AbstractWorklistSolver {
    updateState(_oldState, newState, _iterations) {
        return newState;
    }
}
exports.WorklistSolver = WorklistSolver;
/**
 * WideningWorklistSolver performs a worklist-based iterative analysis using
 * widening to accelerate convergence when a specified iteration threshold is
 * reached.
 *
 * @template State The type representing the state in the analysis.
 */
class WideningWorklistSolver extends AbstractWorklistSolver {
    maxIterations;
    /**
     * @param maxIterations Number of iterations after which widening is applied.
     */
    constructor(cu, cfg, transfer, lattice, kind, maxIterations = 5) {
        super(cu, cfg, transfer, lattice, kind);
        this.maxIterations = maxIterations;
    }
    updateState(oldState, newState, iterations) {
        if (iterations >= this.maxIterations) {
            // Apply widening
            return this.lattice.widen(oldState, newState);
        }
        else {
            // Use standard join or meet
            if (this.isJoinSemilattice(this.lattice)) {
                const joinLattice = this.lattice;
                return joinLattice.join(oldState, newState);
            }
            else if (this.isMeetSemilattice(this.lattice)) {
                const meetLattice = this.lattice;
                return meetLattice.meet(oldState, newState);
            }
            else {
                throw exceptions_1.InternalException.make("Unsupported semilattice type");
            }
        }
    }
}
exports.WideningWorklistSolver = WideningWorklistSolver;
