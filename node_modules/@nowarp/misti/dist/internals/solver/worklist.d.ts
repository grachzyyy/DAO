import { SolverResults } from "./results";
import { Solver } from "./solver";
import { Cfg, CompilationUnit } from "../ir";
import { Semilattice, JoinSemilattice, MeetSemilattice, WideningLattice } from "../lattice";
import { Transfer } from "../transfer";
/**
 * Determines the kind of the dataflow analysis.
 *
 * This type is used to specify the direction of the dataflow analysis being performed.
 * - `forward`: Represents a forward dataflow analysis, where information flows from the entry point of a program towards the exit.
 * - `backward`: Represents a backward dataflow analysis, where information flows from the exit point of a program towards the entry.
 */
export type AnalysisKind = "forward" | "backward";
/**
 * Provides a framework for solving dataflow analysis problems by employing a worklist-based algorithm.
 *
 * This class encapsulates the CFG, node state transformations, and lattice
 * properties necessary for the computation of fixpoints in dataflow equations.
 */
export declare abstract class AbstractWorklistSolver<State> implements Solver<State> {
    protected readonly cu: CompilationUnit;
    protected readonly cfg: Cfg;
    protected transfer: Transfer<State>;
    protected readonly lattice: Semilattice<State>;
    protected readonly kind: AnalysisKind;
    /**
     * @param transfer An object that defines the transfer operation for a node and its state.
     * @param lattice An instance of a semilattice that defines the necessary operations.
     * @param kind The kind of analysis ("forward" or "backward").
     */
    constructor(cu: CompilationUnit, cfg: Cfg, transfer: Transfer<State>, lattice: Semilattice<State>, kind: AnalysisKind);
    /**
     * Abstract method to update the state of a node.
     *
     * @param oldState The previous state of the node.
     * @param newState The newly computed state of the node.
     * @param iterations The number of times the node has been processed.
     * @returns The updated state after applying join/meet/widening/narrowing.
     */
    protected abstract updateState(oldState: State, newState: State, iterations: number): State;
    /**
     * Finds a fixpoint using the worklist algorithm.
     * @returns The results of solving the dataflow problem.
     */
    findFixpoint(): SolverResults<State>;
    solve(): SolverResults<State>;
    protected isJoinSemilattice(lattice: Semilattice<State>): lattice is JoinSemilattice<State>;
    protected isMeetSemilattice(lattice: Semilattice<State>): lattice is MeetSemilattice<State>;
}
/**
 * WorklistSolver performs a standard worklist-based iterative analysis relying
 * solely on the lattice's join or meet operation to update states.
 *
 * @template State The type representing the state in the analysis.
 */
export declare class WorklistSolver<State> extends AbstractWorklistSolver<State> {
    protected updateState(_oldState: State, newState: State, _iterations: number): State;
}
/**
 * WideningWorklistSolver performs a worklist-based iterative analysis using
 * widening to accelerate convergence when a specified iteration threshold is
 * reached.
 *
 * @template State The type representing the state in the analysis.
 */
export declare class WideningWorklistSolver<State> extends AbstractWorklistSolver<State> {
    private readonly maxIterations;
    /**
     * @param maxIterations Number of iterations after which widening is applied.
     */
    constructor(cu: CompilationUnit, cfg: Cfg, transfer: Transfer<State>, lattice: WideningLattice<State>, kind: AnalysisKind, maxIterations?: number);
    protected updateState(oldState: State, newState: State, iterations: number): State;
}
