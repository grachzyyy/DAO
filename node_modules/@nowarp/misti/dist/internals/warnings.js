"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeDocURL = exports.warningIsSuppressed = exports.formatWarning = exports.hashWarning = exports.makeWarning = exports.warningLocationToString = exports.makeWarningLocation = exports.BASE_DOC_URL = exports.categoryToString = exports.severityToString = exports.parseSeverity = exports.Category = exports.Severity = void 0;
const annotation_1 = require("./annotation");
const exceptions_1 = require("./exceptions");
const quickfix_1 = require("./quickfix");
const util_1 = require("./util");
const path_1 = __importDefault(require("path"));
/**
 * Enumerates the levels of severity that can be assigned to detected findings.
 */
var Severity;
(function (Severity) {
    Severity[Severity["INFO"] = 1] = "INFO";
    Severity[Severity["LOW"] = 2] = "LOW";
    Severity[Severity["MEDIUM"] = 3] = "MEDIUM";
    Severity[Severity["HIGH"] = 4] = "HIGH";
    Severity[Severity["CRITICAL"] = 5] = "CRITICAL";
})(Severity = exports.Severity || (exports.Severity = {}));
/**
 * Warning category.
 */
var Category;
(function (Category) {
    /** Any possible unintended behavior leading to bugs or vulnerabilities. */
    Category[Category["SECURITY"] = 1] = "SECURITY";
    /** Code improvements for gas-optimizations. */
    Category[Category["OPTIMIZATION"] = 2] = "OPTIMIZATION";
    /** General code quality advices. */
    Category[Category["BEST_PRACTICES"] = 3] = "BEST_PRACTICES";
})(Category = exports.Category || (exports.Category = {}));
/**
 * Parses string input to corresponding Severity enum value.
 */
function parseSeverity(value) {
    return Severity[value.toUpperCase()];
}
exports.parseSeverity = parseSeverity;
/**
 * Returns string representation of `Severity` optionally wrapped in ANSI escape
 * sequences making it colorful for visual emphasis.
 */
function severityToString(s, { colorize = false, brackets = true, } = {}) {
    const colors = {
        reset: "\x1b[0m",
        bold: "\x1b[1m",
        low: "\x1b[32m",
        medium: "\x1b[33m",
        high: "\x1b[31m",
        critical: "\x1b[35m", // Magenta
    };
    const severityString = (text, color) => {
        let result = text;
        if (brackets) {
            result = `[${result}]`;
        }
        if (colorize && color) {
            result = `${colors.bold}${color}${result}${colors.reset}`;
        }
        return result;
    };
    switch (s) {
        case Severity.INFO:
            return severityString("INFO");
        case Severity.LOW:
            return severityString("LOW", colors.low);
        case Severity.MEDIUM:
            return severityString("MEDIUM", colors.medium);
        case Severity.HIGH:
            return severityString("HIGH", colors.high);
        case Severity.CRITICAL:
            return severityString("CRITICAL", colors.critical);
    }
}
exports.severityToString = severityToString;
function categoryToString(c) {
    switch (c) {
        case Category.OPTIMIZATION:
            return "Optimization";
        case Category.BEST_PRACTICES:
            return "Best Practices";
        case Category.SECURITY:
            return "Security";
        default:
            (0, util_1.unreachable)(c);
    }
}
exports.categoryToString = categoryToString;
/**
 * Base URL to detectors documentation.
 */
exports.BASE_DOC_URL = "https://nowarp.io/tools/misti/docs/detectors";
/**
 * Converts SrcInfo to WarningLocation.
 */
function makeWarningLocation(loc) {
    const lc = loc.interval.getLineAndColumn();
    const code = loc.interval.getLineAndColumnMessage();
    const file = loc.file
        ? (0, util_1.isTest)()
            ? path_1.default.normalize(path_1.default.relative(process.cwd(), loc.file))
            : path_1.default.normalize(loc.file)
        : "<no file>";
    return { file, line: lc.lineNum, column: lc.colNum, code };
}
exports.makeWarningLocation = makeWarningLocation;
/**
 * Converts SrcInfo to the string representation shown to the user.
 */
function warningLocationToString(wl) {
    return `${wl.file}:${wl.line}:${wl.column}:\n${wl.code}`;
}
exports.warningLocationToString = warningLocationToString;
function makeWarning(detectorId, description, severity, category, loc, data = {
    extraDescription: undefined,
    docURL: undefined,
    suggestion: undefined,
    quickfixes: [],
}) {
    if (description.length === 0) {
        throw exceptions_1.InternalException.make("description cannot be empty");
    }
    const wl = makeWarningLocation(loc);
    return {
        detectorId,
        description,
        location: wl,
        suppressed: warningIsSuppressed(wl, detectorId),
        severity,
        category,
        extraDescription: data.extraDescription,
        docURL: data.docURL,
        suggestion: data.suggestion,
        quickfixes: data.quickfixes ? data.quickfixes : [],
    };
}
exports.makeWarning = makeWarning;
/**
 * A braindead-simple hash to check if the warning has already been reported.
 */
function hashWarning(warn) {
    return [
        warn.detectorId,
        warn.location.file,
        warn.location.line,
        warn.location.column,
        warn.location.code,
        warn.description,
    ].join("%");
}
exports.hashWarning = hashWarning;
/**
 * Returns string representation of the warning according to the configuration.
 */
function formatWarning(warn, colorize, addNewline) {
    const extraDescriptionStr = warn.extraDescription === undefined ? "" : `${warn.extraDescription}\n`;
    const suggestedChange = (() => {
        const quickfixStr = warn.quickfixes
            .filter((qf) => qf.shown)
            .map((qf) => (0, quickfix_1.quickFixToString)(qf))
            .join("\n");
        if (quickfixStr) {
            return `Help: ${quickfixStr}`;
        }
        else if (warn.suggestion !== undefined) {
            return `Help: ${warn.suggestion}`;
        }
        else {
            return "";
        }
    })();
    const docURLStr = warn.docURL === undefined ? "" : `\nSee: ${warn.docURL}`;
    const msg = [
        warn.description,
        "\n",
        warningLocationToString(warn.location),
        extraDescriptionStr,
        suggestedChange,
        docURLStr,
    ].join("");
    const severity = severityToString(warn.severity, {
        colorize,
    });
    return `${severity} ${warn.detectorId}: ${msg}${addNewline && !msg.endsWith("\n") ? "\n" : ""}`;
}
exports.formatWarning = formatWarning;
/**
 * Checks whether the warning is suppressing using a Misti annotation.
 */
function warningIsSuppressed(wl, detectorId) {
    const annotation = (0, annotation_1.getMistiAnnotation)(wl.code);
    if (annotation && annotation.kind === "suppress") {
        return annotation.detectors.find((d) => d === detectorId) !== undefined;
    }
    return false;
}
exports.warningIsSuppressed = warningIsSuppressed;
/**
 * Creates a link to the documentation for built-in detectors.
 */
function makeDocURL(detectorName) {
    return `${exports.BASE_DOC_URL}/${detectorName}`;
}
exports.makeDocURL = makeDocURL;
