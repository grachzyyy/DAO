import { CLIOptions } from "./options";
import { Result } from "./result";
import { OutputFormat } from "./types";
import { Detector } from "../detectors/detector";
import { MistiContext } from "../internals/context";
import { CompilationUnit, ProjectName } from "../internals/ir";
import { Severity } from "../internals/warnings";
import { Tool } from "../tools/tool";
import { VirtualFileSystem } from "../vfs/virtualFileSystem";
/**
 * Manages the initialization and execution of detectors for analyzing compilation units.
 */
export declare class Driver {
    ctx: MistiContext;
    detectors: Detector[];
    tools: Tool<any>[];
    outputPath: string;
    /** List of detectors explicitly disabled by the user. */
    disabledDetectors: Set<string>;
    colorizeOutput: boolean;
    fs: VirtualFileSystem;
    /**
     * Compilation units representing the actual entrypoints of the analysis targets
     * based on user's input. Might be empty if no paths are specified.
     */
    cus: Map<ProjectName, CompilationUnit>;
    /** Minimum severity level to report warnings. */
    minSeverity: Severity;
    outputFormat: OutputFormat;
    private constructor();
    /**
     * Asynchronously creates a driver initializing all detectors.
     * @param tactPath Path to the Tact project configuration of to a single Tact contract.
     */
    static create(tactPaths: string[], options?: Partial<CLIOptions>): Promise<Driver>;
    /**
     * Resolves the filepaths provided as an input to Misti to initialize the
     * compilation units which are IR entries to target analysis on.
     *
     * @param tactPaths Paths received from the user.
     * @returns Created compilation units.
     */
    private createCUs;
    /**
     * Collects all the .tact files in the given directory with respect to ignore heuristics.
     * @param dir The directory to search in.
     * @returns The list of .tact files.
     */
    private collectTactFiles;
    /**
     * Check CLI options for ambiguities.
     * @throws If Misti cannot be executed with the given options
     */
    private static checkCLIOptions;
    /**
     * Warns the user about the Soufflé detectors that were disabled due to missing Soufflé installation.
     */
    private static warnOnDisabledDetectors;
    /**
     * Initializes all detectors specified in the configuration including external and built-in detectors.
     * @throws Error if a detector class cannot be found in the specified module or as a built-in.
     */
    initializeDetectors(): Promise<void>;
    /**
     * Initializes all built-in tools specified in the configuration.
     * @throws Error if a tool cannot be found or initialized.
     */
    initializeTools(): Promise<void>;
    /**
     * Actual implementation of the entry point.
     */
    executeImpl(): Promise<Result>;
    /**
     * Wraps the entry point of execution with extra logging handling logic.
     */
    execute(): Promise<Result>;
    /**
     * Executes all the initialized detectors on the compilation units.
     * @param cus Map of compilation units
     * @returns MistiResult containing detectors output
     */
    private executeAnalysis;
    /**
     * Executes all the initialized tools on the compilation units.
     * @returns MistiResult containing tool outputs
     */
    private executeTools;
    /**
     * Finds detector with a given name among the detectors available within the project.
     * @throws If not found
     */
    private findDetector;
    /**
     * Filters warnings from multi-file projects detectors with respect to `WarningsBehavior`.
     */
    private filterImportedWarnings;
    /**
     * Filters out the suppressed warnings.
     * Mutates the input map removing suppressed warnings.
     */
    private filterSuppressedWarnings;
    /**
     * Filters out the warnings suppressed in the code annotations.
     * Mutates the input map removing suppressed warnings.
     */
    private filterSuppressedInAnnotations;
    /**
     * Compares suppressionFile and warningFile.
     * If suppressionFile is an absolute path, returns true if the files are the same after normalization.
     * If suppressionFile is relative, returns true if warningFile ends with the normalized relative path.
     */
    private pathsAreEqual;
    /**
     * Checks if a warning matches suppression.
     */
    private suppressionMatchesWarning;
    /**
     * Filters warnings suppressed in the config file.
     * Mutates the input map, removing suppressed warnings.
     */
    private filterSuppressedInConfig;
    /**
     * Executes all detectors on a given compilation unit and collects any warnings found.
     * @param cu The compilation unit to check.
     * @returns Warnings generated by each of detectors.
     */
    private checkCU;
}
