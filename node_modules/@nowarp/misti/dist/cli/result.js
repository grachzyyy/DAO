"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.saveResultToFiles = exports.resultToExitCode = exports.resultToString = void 0;
const options_1 = require("./options");
const types_1 = require("../cli/types");
const exceptions_1 = require("../internals/exceptions");
const util_1 = require("../internals/util");
const warnings_1 = require("../internals/warnings");
const fs_1 = __importDefault(require("fs"));
const json_bigint_1 = __importDefault(require("json-bigint"));
const path_1 = __importDefault(require("path"));
/**
 * Converts a MistiResult object to a readable string based on its kind.
 */
function resultToString(result, outputFormat) {
    if (outputFormat === "json") {
        return json_bigint_1.default.stringify(result, null, 2);
    }
    switch (result.kind) {
        case "ok":
            return "No errors found";
        case "error":
            return `Misti execution failed:\n${result.error}`;
        case "warnings":
            const formattedWarnings = [];
            result.warnings.forEach((warn, index) => {
                const isLastWarning = index === result.warnings.length - 1;
                formattedWarnings.push((0, warnings_1.formatWarning)(warn, false, !isLastWarning));
            });
            return formattedWarnings.join("\n").trim();
        case "tool":
            return result.output.length === 1
                ? result.output[0].output.trim()
                : result.output
                    .map((tool) => `${tool.name}:\n${tool.output}`)
                    .join("\n\n")
                    .trim();
        default:
            (0, util_1.unreachable)(result);
    }
}
exports.resultToString = resultToString;
function resultToExitCode(result) {
    switch (result.kind) {
        case "ok":
        case "tool":
            return types_1.ExitCode.SUCCESS;
        case "warnings":
            return types_1.ExitCode.WARNINGS;
        case "error":
            return types_1.ExitCode.EXECUTION_FAILURE;
        default:
            (0, util_1.unreachable)(result);
    }
}
exports.resultToExitCode = resultToExitCode;
/**
 * Saves the result of a Misti operation to files.
 *
 * The names of the files follow the following format:
 * - <project-name>.warnings.out
 * - <project-name>.<tool-name>.out
 *
 * @param result The result of a Misti operation.
 * @param outputPath The path to save the result to.
 * @returns The report of the result.
 */
function saveResultToFiles(result, outputPath) {
    if (outputPath === options_1.STDOUT_PATH) {
        throw exceptions_1.InternalException.make(`Incorrect output path: ${outputPath}`);
    }
    switch (result.kind) {
        case "ok":
            return { kind: "ok" };
        case "error":
            return {
                kind: "error",
                message: result.error,
            };
        case "warnings":
            fs_1.default.writeFileSync(path_1.default.join(outputPath, `warnings.out`), result.warnings
                .map((warning) => (0, warnings_1.formatWarning)(warning, false, false))
                .join("\n"));
            return null;
        case "tool":
            result.output.forEach((tool) => {
                fs_1.default.writeFileSync(path_1.default.join(outputPath, `${tool.projectName}.${tool.name}.out`), tool.output);
            });
            return null;
        default:
            (0, util_1.unreachable)(result);
    }
}
exports.saveResultToFiles = saveResultToFiles;
