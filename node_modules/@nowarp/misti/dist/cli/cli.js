"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleMistiResult = exports.executeMisti = exports.runMistiCommand = exports.createMistiCommand = void 0;
const driver_1 = require("./driver");
const options_1 = require("./options");
const detector_1 = require("../detectors/detector");
const util_1 = require("../internals/util");
const tool_1 = require("../tools/tool");
const version_1 = require("../version");
const result_1 = require("./result");
const logger_1 = require("../internals/logger");
const createNodeFileSystem_1 = require("../vfs/createNodeFileSystem");
const commander_1 = require("commander");
/**
 * Creates and configures the Misti CLI command.
 * @returns The configured commander Command instance.
 */
function createMistiCommand() {
    const command = new commander_1.Command()
        .name("misti")
        .description("TON Static Analyzer")
        .version(`Misti ${version_1.MISTI_VERSION}\nSupported Tact version: ${version_1.TACT_VERSION}`)
        .arguments("[paths...]");
    options_1.cliOptions.forEach((option) => command.addOption(option));
    command.action(async (_tactPath, options) => {
        const logger = new logger_1.Logger();
        if (options.listTools) {
            const toolsHelpMessage = await (0, tool_1.generateToolsHelpMessage)();
            logger.info(toolsHelpMessage);
            process.exit(0);
        }
        if (options.listDetectors) {
            const detectorNames = Object.keys(detector_1.BuiltInDetectors);
            detectorNames.forEach((name) => logger.info(`- ${name}`));
            process.exit(0);
        }
    });
    return command;
}
exports.createMistiCommand = createMistiCommand;
/**
 * Runs the Misti CLI command with the provided arguments.
 * @param args The list of arguments to pass to the CLI command.
 * @returns The created Driver instance and the result of execution.
 */
async function runMistiCommand(args, command = createMistiCommand()) {
    await command.parseAsync(args, { from: "user" });
    const driver = await driver_1.Driver.create(command.args, {
        ...command.opts(),
        fs: (0, createNodeFileSystem_1.createNodeFileSystem)(process.cwd()),
    });
    const result = await driver.execute();
    return [driver, result];
}
exports.runMistiCommand = runMistiCommand;
/**
 * Executes Misti capturing the output and returning it as a string.
 * @param args The list of arguments to pass to the CLI command.
 * @returns The output of the Misti command as a string.
 */
async function executeMisti(args) {
    const result = await runMistiCommand(args);
    if (!result)
        return "";
    const [driver, mistiResult] = result;
    return mistiResult ? (0, result_1.resultToString)(mistiResult, driver.outputFormat) : "";
}
exports.executeMisti = executeMisti;
/**
 * Handles Misti execution result by either logging to console or saving to file.
 */
function handleMistiResult(driver, result) {
    const logger = driver.ctx.logger;
    driver.outputPath && driver.outputPath !== options_1.STDOUT_PATH
        ? handleOutputToFile(result, driver.outputPath, logger)
        : handleOutputToConsole(result, driver.outputFormat, logger);
}
exports.handleMistiResult = handleMistiResult;
/**
 * Handles saving the result to a file and logging the outcome.
 */
function handleOutputToFile(result, outputPath, logger) {
    const report = (0, result_1.saveResultToFiles)(result, outputPath);
    if (report) {
        switch (report.kind) {
            case "error":
                logger.error("Misti execution error:");
                logger.error(report.message);
                break;
            case "ok":
                logger.info("No errors found");
                break;
            default:
                (0, util_1.unreachable)(report);
        }
    }
}
/**
 * Handles logging the result to the console.
 */
function handleOutputToConsole(result, outputFormat, logger) {
    const text = (0, result_1.resultToString)(result, outputFormat);
    switch (result.kind) {
        case "warnings":
            outputFormat === "json" ? console.warn(text) : logger.warn(text);
            break;
        case "error":
            outputFormat === "json" ? console.error(text) : logger.error(text);
            break;
        case "tool":
        case "ok":
            outputFormat === "json" ? console.log(text) : logger.error(text);
            logger.info(text);
            break;
        default:
            (0, util_1.unreachable)(result);
    }
}
