/**
 * Defines the base structure for Misti static analysis detectors, including AST,
 * dataflow, and Soufflé-based detectors.
 *
 * Supports dynamic loading of built-in detectors, warning generation, and configurable
 * behavior for multi-project setups.
 *
 * ### Adding a new built-in detector
 * To add a new built-in detector, create its implementation in the `./builtin`
 * directory and add information about it to `BuiltInDetectors`. No other changes
 * in the project are needed.
 *
 * @packageDocumentation
 */
import { MistiContext } from "../internals/context";
import { CompilationUnit } from "../internals/ir";
import { QuickFix } from "../internals/quickfix";
import { SrcInfo } from "../internals/tact/imports";
import { Warning, Severity, Category } from "../internals/warnings";
import { SouffleContext, SouffleFact } from "@nowarp/souffle";
export type WarningsBehavior = "union" | "intersect";
export type DetectorName = string;
export type DetectorKind = "ast" | "dataflow" | "souffle";
/**
 * Abstract base class for a detector module, providing an interface for defining various types of detectors.
 */
export declare abstract class Detector {
    readonly ctx: MistiContext;
    protected abstract readonly severity: Severity | {
        min: Severity;
        max: Severity;
    };
    protected readonly category: Category | Category[] | undefined;
    constructor(ctx: MistiContext);
    /**
     * Gets the short identifier of the detector, used in analyzer warnings.
     * @returns The unique identifier of the detector.
     */
    get id(): DetectorName;
    /**
     * Gets the kind of the detector.
     */
    abstract get kind(): DetectorKind;
    /**
     * Returns minimum and maximum severities of generated warnings.
     */
    getSeverity(): {
        min: Severity;
        max: Severity;
    };
    /**
     * Returns the category of generated warnings if specified.
     */
    getCategory(): Category[] | undefined;
    /**
     * Defines the behavior of warnings generated by this detector when working with
     * multiple projects within a single Tact configuration.
     *
     * Here are the available options:
     * 1. `"union"`
     * Leave this value if you don't care about warnings generated in other projects.
     * 2. `"intersect"`
     * If the warning is generated for some source location of the imported file,
     * it should be generated by each of the projects. Example: Constants from an
     * imported file should not be reported iff they are unused in all the projects,
     * so you need "intersect".
     */
    get shareImportedWarnings(): WarningsBehavior;
    /**
     * Checks whether this detector needs the Soufflé binary to be executed.
     */
    get usesSouffle(): boolean;
    /**
     * Executes the detector's logic to check for issues within the provided compilation unit.
     * @param cu The compilation unit to be analyzed.
     * @returns List of warnings has highlighted by this detector.
     */
    abstract check(cu: CompilationUnit): Promise<Warning[]>;
    /**
     * Returns `true` if the identifier with the given name should not be reported
     * by unused variables detectors.
     */
    protected skipUnused(name: string): boolean;
    /**
     * A wrapper method that creates Misti warnings with additional context about
     * the detector generated it.
     */
    protected makeWarning(description: string, loc: SrcInfo, data?: Partial<{
        severity: Severity;
        category: Category;
        extraDescription: string;
        suggestion: string;
        quickfixes: QuickFix[];
    }>): Warning;
}
/**
 * Abstract class for detectors that identify specific patterns in the AST.
 */
export declare abstract class AstDetector extends Detector {
    get kind(): DetectorKind;
}
/**
 * Abstract class for dataflow detectors that leverage the Monotone framework and a worklist solver.
 */
export declare abstract class DataflowDetector extends Detector {
    get kind(): DetectorKind;
}
/**
 * Abstract class for Souffle-based detectors that implement Datalog-based analyses.
 */
export declare abstract class SouffleDetector extends Detector {
    get kind(): DetectorKind;
    /**
     * Creates a Soufflé context with unique name.
     * @param docstring A comment introduced on the top of the generated program if `ctx.config.souffleVerbose` is set.
     *
     * It should be used to avoid name clashes in the Soufflé directory when working with multiple projects.
     */
    protected createSouffleContext(cu: CompilationUnit, docstring?: string | string[] | undefined): SouffleContext<SrcInfo>;
    /**
     * Executes Souffle program for this detector converting output facts to warnings.
     * @param ctx Souffle context with all the declarations, rules and facts added.
     * @param callback A function that creates warnings from output facts.
     */
    protected executeSouffle(ctx: SouffleContext<SrcInfo>, callback: (fact: SouffleFact<SrcInfo>) => Warning | undefined): Promise<Warning[]>;
}
interface DetectorEntry {
    loader: (ctx: MistiContext) => Promise<Detector>;
    enabledByDefault: boolean;
}
/**
 * A mapping of detector names to their respective loader functions and default enablement status.
 */
export declare const BuiltInDetectors: Record<string, DetectorEntry>;
/**
 * Asynchronously retrieves a built-in detector by its name.
 * If the detector is found in the BuiltInDetectors registry, it is loaded and returned;
 * otherwise, a warning is logged and `undefined` is returned.
 *
 * @param ctx Misti context.
 * @param name The name of the detector to retrieve. This name must match a key in the BuiltInDetectors object.
 * @returns A Promise that resolves to a Detector instance or `undefined` if the detector cannot be found or fails to load.
 */
export declare function findBuiltInDetector(ctx: MistiContext, name: string): Promise<Detector | undefined>;
/**
 * Returns a list of all the available built-in detectors.
 * @returns An array of strings representing the names of detectors.
 */
export declare function getAllDetectors(): string[];
/**
 * Returns a list of detector names that are enabled by default.
 * @returns An array of strings representing the names of enabled detectors.
 */
export declare function getEnabledDetectors(): string[];
/**
 * @returns True if there is a built-in detector with the given name.
 */
export declare function hasBuiltInDetector(name: string): boolean;
export {};
