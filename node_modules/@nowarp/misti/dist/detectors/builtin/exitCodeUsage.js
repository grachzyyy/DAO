"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExitCodeUsage = void 0;
const exceptions_1 = require("../../internals/exceptions");
const lattice_1 = require("../../internals/lattice");
const numbers_1 = require("../../internals/numbers");
const solver_1 = require("../../internals/solver");
const tact_1 = require("../../internals/tact");
const imports_1 = require("../../internals/tact/imports");
const iterators_1 = require("../../internals/tact/iterators");
const warnings_1 = require("../../internals/warnings");
const detector_1 = require("../detector");
/**
 * The minimum allowed value for user-defined exit codes.
 * @remarks Values below 256 are reserved:
 * - 1-127: Reserved for TVM/FunC
 * - 128-255: Reserved for Tact
 */
const LOWER_BOUND = 256n;
/**
 * The maximum allowed value for user-defined exit codes.
 * @remarks Values above 65535 are invalid in TON smart contracts
 */
const UPPER_BOUND = 65535n;
class ExitCodeLattice {
    intervalLattice;
    widenCount = new Map();
    WIDENING_THRESHOLD = 3;
    constructor() {
        this.intervalLattice = new lattice_1.IntervalJoinSemiLattice();
    }
    bottom() {
        return new Map();
    }
    join(a, b) {
        const result = new Map();
        const variables = new Set([...a.keys(), ...b.keys()]);
        for (const variable of variables) {
            const intervalA = a.get(variable) || this.intervalLattice.bottom();
            const intervalB = b.get(variable) || this.intervalLattice.bottom();
            const joinedInterval = this.intervalLattice.join(intervalA, intervalB);
            result.set(variable, joinedInterval);
        }
        return result;
    }
    leq(a, b) {
        for (const [variable, intervalA] of a.entries()) {
            const intervalB = b.get(variable) || this.intervalLattice.bottom();
            if (!this.intervalLattice.leq(intervalA, intervalB)) {
                return false;
            }
        }
        return true;
    }
    widen(oldState, newState) {
        const result = new Map();
        const variables = new Set([...oldState.keys(), ...newState.keys()]);
        for (const variable of variables) {
            // Track widening iterations per variable
            const count = (this.widenCount.get(variable) || 0) + 1;
            this.widenCount.set(variable, count);
            const intervalOld = oldState.get(variable) || this.intervalLattice.bottom();
            const intervalNew = newState.get(variable) || this.intervalLattice.bottom();
            // If we've widened too many times, jump straight to ±∞
            let widenedInterval;
            if (count > this.WIDENING_THRESHOLD) {
                widenedInterval = lattice_1.IntervalJoinSemiLattice.topValue;
            }
            else {
                widenedInterval = this.intervalLattice.widen(intervalOld, intervalNew);
            }
            result.set(variable, widenedInterval);
        }
        return result;
    }
}
class ExitCodeTransfer {
    transfer(inState, _bb, stmt) {
        const outState = new Map(inState);
        if (stmt.kind === "statement_assign") {
            const assignStmt = stmt;
            const varName = this.extractVariableName(assignStmt.path);
            if (varName) {
                const exprInterval = this.evaluateExpression(assignStmt.expression, inState);
                outState.set(varName, exprInterval);
            }
        }
        else if (stmt.kind === "statement_let") {
            const letStmt = stmt;
            const varName = (0, imports_1.idText)(letStmt.name);
            const exprInterval = this.evaluateExpression(letStmt.expression, inState);
            outState.set(varName, exprInterval);
        }
        return outState;
    }
    extractVariableName(expr) {
        return expr.kind === "id" ? (0, imports_1.idText)(expr) : null;
    }
    evaluateExpression(expr, state) {
        if (expr.kind === "number") {
            const exprNum = expr;
            const value = BigInt(exprNum.value);
            return numbers_1.Interval.fromNum(value);
        }
        else if (expr.kind === "id") {
            const varName = (0, imports_1.idText)(expr);
            return state.get(varName) || lattice_1.IntervalJoinSemiLattice.topValue;
        }
        else if (expr.kind === "op_binary") {
            const leftInterval = this.evaluateExpression(expr.left, state);
            const rightInterval = this.evaluateExpression(expr.right, state);
            switch (expr.op) {
                case "+":
                    return leftInterval.plus(rightInterval);
                case "-":
                    return leftInterval.minus(rightInterval);
                case "*":
                    return leftInterval.times(rightInterval);
                case "/":
                    return leftInterval.div(rightInterval);
                default:
                    return lattice_1.IntervalJoinSemiLattice.topValue;
            }
        }
        return lattice_1.IntervalJoinSemiLattice.topValue;
    }
}
/**
 * A detector that identifies improper use of exit codes outside the developer-allowed range.
 *
 * ## Why is it bad?
 * In the TON blockchain, exit codes are divided into specific ranges: 1 to 127
 * are reserved for the TVM or FunC, and 128 to 255 are reserved for Tact. This
 * structure leaves the range from 256 to 65535 for developers to define custom
 * exit codes.
 *
 * When exit codes are defined outside this allowed range, it may lead to
 * conflicts with existing reserved codes, causing unintended behavior or
 * errors in the contract.
 *
 * ## Example
 * ```tact
 * contract Foo {
 *     receive("foobar") {
 *         // Bad: exit code defined in the reserved range for Tact
 *         let code: Int = 128;
 *         nativeThrowUnless(code, sender() == self.owner);
 *     }
 * }
 * ```
 *
 * Use instead:
 * ```tact
 * contract Foo {
 *     receive("foobar") {
 *         // OK: using exit code from the allowed range
 *         let code: Int = 256;
 *         nativeThrowUnless(code, sender() == self.owner);
 *     }
 * }
 * ```
 *
 * ## Resources
 * 1. [Exit Codes | Tact Docs](https://docs.tact-lang.org/book/exit-codes)
 */
class ExitCodeUsage extends detector_1.DataflowDetector {
    severity = warnings_1.Severity.HIGH;
    category = warnings_1.Category.SECURITY;
    async check(cu) {
        const warnings = [];
        cu.forEachCFG((cfg) => {
            const node = cu.ast.getFunction(cfg.id);
            if (node === undefined) {
                return;
            }
            const lattice = new ExitCodeLattice();
            const transfer = new ExitCodeTransfer();
            const solver = new solver_1.WideningWorklistSolver(cu, cfg, transfer, lattice, "forward", 5);
            const results = solver.solve();
            for (const bb of cfg.nodes) {
                const state = results.getState(bb.idx);
                if (state) {
                    this.checkStateForWarnings(cu, state, bb, warnings);
                }
            }
        }, { includeStdlib: false });
        return warnings;
    }
    checkStateForWarnings(cu, state, bb, warnings) {
        const stmt = cu.ast.getStatement(bb.stmtID);
        if (!stmt) {
            throw exceptions_1.InternalException.make(`Cannot find a statement for BB #${bb.idx}`);
        }
        const arg = this.getThrowFunctionArg(stmt);
        if (!arg)
            return;
        this.checkDirectExitCode(arg, warnings);
        this.checkVariableExitCode(arg, state, warnings);
    }
    /**
     * Checks for invalid exit codes specified directly as numbers (e.g., throw(128))
     * @param arg The argument passed to the throw function
     * @param warnings Array to collect any warnings found
     */
    checkDirectExitCode(arg, warnings) {
        const num = (0, tact_1.evalToType)(arg, "number");
        if (num !== undefined &&
            num !== null &&
            num.kind === "number" &&
            ((num.value !== 0n && num.value < LOWER_BOUND) || num.value > UPPER_BOUND)) {
            warnings.push(this.makeWarning(`Value is outside allowed range`, arg.loc, {
                extraDescription: `Exit codes 0-255 are reserved. Used value: ${num.value}`,
                suggestion: `Use a value between ${Number(LOWER_BOUND)} and ${Number(UPPER_BOUND)}`,
            }));
        }
    }
    /**
     * Checks for invalid exit codes stored in variables
     * @param arg The argument passed to the throw function
     * @param state Current state containing variable intervals
     * @param warnings Array to collect any warnings found
     */
    checkVariableExitCode(arg, state, warnings) {
        if (arg.kind === "id") {
            const exitVariableName = (0, imports_1.idText)(arg);
            for (const [varName, interval] of state.entries()) {
                if (exitVariableName === varName &&
                    this.isOutsideAllowedRange(interval)) {
                    warnings.push(this.makeWarning(`Exit code variable "${varName}" has value outside allowed range`, arg.loc, {
                        extraDescription: `Exit codes 0-255 are reserved. Variable value: ${interval.toString()}`,
                        suggestion: `Use a value between ${Number(LOWER_BOUND)} and ${Number(UPPER_BOUND)}`,
                    }));
                }
            }
        }
    }
    isOutsideAllowedRange(interval) {
        const lowerBound = interval.low;
        const upperBound = interval.high;
        // Developer-allowed range is 256 to 65535 excluding 0
        const belowMin = numbers_1.Num.compare(upperBound, numbers_1.Num.int(LOWER_BOUND)) < 0;
        const aboveMax = numbers_1.Num.compare(lowerBound, numbers_1.Num.int(UPPER_BOUND)) > 0;
        return belowMin || aboveMax;
    }
    /**
     * Returns first argument of throw functions or null if it's not a throw call
     */
    getThrowFunctionArg(stmt) {
        let result = null;
        // The first argument of these functions is an exit code:
        // https://docs.tact-lang.org/ref/core-debug/#throw
        const throwFunctions = new Set([
            "throw",
            "nativeThrow",
            "nativeThrowIf",
            "nativeThrowUnless",
        ]);
        (0, iterators_1.findInExpressions)(stmt, (expr) => {
            if (expr.kind === "static_call" &&
                expr.args.length > 0 &&
                throwFunctions.has((0, imports_1.idText)(expr.function))) {
                result = expr.args[0];
                return true;
            }
            return false;
        });
        return result;
    }
}
exports.ExitCodeUsage = ExitCodeUsage;
