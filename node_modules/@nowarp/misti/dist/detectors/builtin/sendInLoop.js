"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SendInLoop = void 0;
const callGraph_1 = require("../../internals/ir/callGraph");
const tact_1 = require("../../internals/tact");
const util_1 = require("../../internals/tact/util");
const warnings_1 = require("../../internals/warnings");
const detector_1 = require("../detector");
/**
 * An optional detector that identifies send functions being called inside loops,
 * including indirect calls via other functions.
 *
 * ## Why is it bad?
 * Calling send functions inside loops can lead to unintended consequences, such as
 * excessive message sending, increased gas consumption, and potential race conditions.
 * Loops with send calls should be refactored to avoid these issues. This detector helps
 * flag such code, prompting the developer to reconsider the design.
 *
 * ## Example
 * ```tact
 * fun exampleWhileLoop(limit: Int, owner: Address) {
 *   let i = 0;
 *   while (i < limit) {
 *       send(SendParameters{ // Highlighted: An auditor should review the loop
 *           to: owner,
 *           value: 0,
 *           bounce: false,
 *           body: Msg{ a: i }.toCell()
 *       });
 *       i += 1;
 *   }
 * }
 * ```
 */
class SendInLoop extends detector_1.AstDetector {
    severity = warnings_1.Severity.MEDIUM;
    category = warnings_1.Category.SECURITY;
    async check(cu) {
        const processedLoopIds = new Set();
        const allWarnings = [];
        // Analyze loops and check if any function called within leads to a send
        for (const entry of cu.ast.getProgramEntries()) {
            if (entry.kind === "contract") {
                const contract = entry;
                const contractName = contract.name.text;
                (0, tact_1.forEachStatement)(entry, (stmt) => {
                    const warnings = this.analyzeStatement(stmt, processedLoopIds, cu.callGraph, contractName);
                    allWarnings.push(...warnings);
                });
            }
            else {
                (0, tact_1.forEachStatement)(entry, (stmt) => {
                    const warnings = this.analyzeStatement(stmt, processedLoopIds, cu.callGraph, entry.kind === "function_def"
                        ? (0, util_1.getExtendsSelfType)(entry)
                        : undefined);
                    allWarnings.push(...warnings);
                });
            }
        }
        return allWarnings;
    }
    analyzeStatement(stmt, processedLoopIds, callGraph, currentContractName) {
        if (processedLoopIds.has(stmt.id)) {
            return [];
        }
        processedLoopIds.add(stmt.id);
        if (!this.isLoop(stmt)) {
            return [];
        }
        const warnings = [];
        // Check direct send calls within the loop
        (0, tact_1.foldExpressions)(stmt, (acc, expr) => {
            if ((0, util_1.isSendCall)(expr)) {
                acc.push(this.warn("Send function called inside a loop", expr.loc));
            }
            return acc;
        }, warnings);
        // Check function calls within the loop that lead to a send
        (0, tact_1.foldExpressions)(stmt, (acc, expr) => {
            if (expr.kind === "static_call" || expr.kind === "method_call") {
                const calleeName = callGraph_1.CallGraph.getFunctionCallName(expr, currentContractName);
                if (calleeName === undefined) {
                    return acc; // irrelevant, e.g. self.<map_field>.set()
                }
                const calleeNodeId = callGraph.getNodeIdByName(calleeName);
                if (calleeNodeId !== undefined) {
                    const calleeNode = callGraph.getNode(calleeNodeId);
                    if (calleeNode && calleeNode.hasEffect(callGraph_1.Effect.Send)) {
                        const isMethod = calleeNode.name.includes("::");
                        const functionName = isMethod
                            ? calleeNode.name.split("::").pop()
                            : calleeNode.name;
                        acc.push(this.warn(`${isMethod ? "Method" : "Function"} "${functionName}" called inside a loop leads to calling a send function`, expr.loc));
                    }
                }
                else {
                    const lc = expr.loc.interval.getLineAndColumn();
                    this.ctx.logger.error(`Cannot retrieve CG node: ${calleeName} (${lc.lineNum}:${lc.colNum})`);
                    return acc;
                }
            }
            return acc;
        }, warnings);
        return warnings;
    }
    warn(msg, loc) {
        return this.makeWarning(msg, loc, {
            suggestion: "Consider refactoring to avoid calling send functions inside loops",
        });
    }
    isLoop(stmt) {
        return (stmt.kind === "statement_while" ||
            stmt.kind === "statement_repeat" ||
            stmt.kind === "statement_until" ||
            stmt.kind === "statement_foreach");
    }
}
exports.SendInLoop = SendInLoop;
