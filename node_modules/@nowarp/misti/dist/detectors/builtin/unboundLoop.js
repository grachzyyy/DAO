"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnboundLoop = void 0;
const exceptions_1 = require("../../internals/exceptions");
const tact_1 = require("../../internals/tact");
const imports_1 = require("../../internals/tact/imports");
const warnings_1 = require("../../internals/warnings");
const detector_1 = require("../detector");
const souffle_1 = require("@nowarp/souffle");
/**
 * A detector that analyzes loop conditions and control flow to ensure loops have proper termination criteria.
 *
 * ## Why is it bad?
 * An unbounded loop can be problematic for several reasons:
 * * **Unexpected Behavior:** Without a defined termination, loops can lead to unpredictable contract behavior and make debugging difficult.
 * * **Out-of-gas Attacks:** Continuous looping without termination can lead to out-of-gas attacks.
 * * **DoS Attacks:** Malicious actors can exploit unbounded loops to create denial-of-service attacks, impacting contract's availability.
 *
 * ## Example
 * ```tact
 * let x: Int = 10;
 * while (x > 0) {
 *   // Bad: x is not changed due looping
 *   send(SendParameters{ to: sender(), ... });
 * }
 * ```
 *
 * Use instead:
 * ```tact
 * let x: Int = 10;
 * while (x > 0) {
 *   send(SendParameters{ to: sender(), ... });
 *   x = x - 1;
 * }
 * ```
 */
class UnboundLoop extends detector_1.SouffleDetector {
    severity = warnings_1.Severity.HIGH;
    category = warnings_1.Category.SECURITY;
    async check(cu) {
        const program = this.createSouffleContext(cu);
        this.addDecls(program);
        this.addRules(program);
        this.addConstantConstraints(cu, program);
        this.addConstraints(cu, program);
        return await this.executeSouffle(program, (fact) => {
            if (fact.data === undefined) {
                throw exceptions_1.InternalException.make(`AST position for fact ${fact} is not available`);
            }
            return this.makeWarning("Found unbounded loop", fact.data, {
                suggestion: "Consider changing the variable inside the loop to ensure it terminates",
                extraDescription: "The condition variable doesn't change inside the loop",
            });
        });
    }
    addDecls(ctx) {
        ctx.add((0, souffle_1.relation)("constDef", [["var", "Symbol"]], undefined));
        ctx.add((0, souffle_1.relation)("varDef", [
            ["var", "Symbol"],
            ["func", "Symbol"],
        ], undefined));
        ctx.add((0, souffle_1.relation)("loopDef", [
            ["loopId", "Number"],
            ["func", "Symbol"],
        ], undefined));
        ctx.add((0, souffle_1.relation)("loopCondDef", [
            ["var", "Symbol"],
            ["loopId", "Number"],
            ["func", "Symbol"],
        ], undefined));
        ctx.add((0, souffle_1.relation)("loopVarUse", [
            ["var", "Symbol"],
            ["loopId", "Number"],
            ["func", "Symbol"],
        ], undefined));
        ctx.add((0, souffle_1.relation)("unbound", [
            ["var", "Symbol"],
            ["loopId", "Number"],
            ["func", "Symbol"],
        ], "output"));
    }
    addRules(ctx) {
        // unbound(var, loopId, func) :-
        //   varDef(var, func),
        //   loopDef(loopId, func),
        //   loopCondDef(var, loopId, func),
        //   !constDef(var)
        //   !loopVarUse(var, loopId, func).
        ctx.add((0, souffle_1.rule)([(0, souffle_1.atom)("unbound", ["var", "loopId", "func"])], [
            (0, souffle_1.body)((0, souffle_1.atom)("varDef", ["var", "func"])),
            (0, souffle_1.body)((0, souffle_1.atom)("loopDef", ["loopId", "func"])),
            (0, souffle_1.body)((0, souffle_1.atom)("loopCondDef", ["var", "loopId", "func"])),
            (0, souffle_1.body)((0, souffle_1.atom)("constDef", ["var"]), {
                negated: true,
            }),
            (0, souffle_1.body)((0, souffle_1.atom)("loopVarUse", ["var", "loopId", "func"]), {
                negated: true,
            }),
        ]));
    }
    /**
     * Generates Souffle facts for constant definitions which should not be reported if used in the loop.
     */
    addConstantConstraints(cu, ctx) {
        for (const c of cu.ast.getConstants({ includeStdlib: true })) {
            ctx.addFact("constDef", [c.name.text], c.loc);
        }
    }
    /**
     * Collects facts based on the IR to populate the Souffle program.
     * @param cu The compilation unit containing the CFGs and AST information.
     * @param ctx The Souffle program to which the facts are added.
     */
    addConstraints(cu, ctx) {
        cu.forEachBasicBlock(cu.ast, (cfg, _, stmt) => {
            if (cfg.origin === "stdlib") {
                return;
            }
            const funName = cfg.name;
            if (stmt.kind === "statement_let") {
                ctx.addFact("varDef", [stmt.name.text, funName], stmt.loc);
                return;
            }
            if (stmt.kind === "statement_while" ||
                stmt.kind === "statement_until") {
                const loopId = stmt.id;
                const usedInCond = new Set(); // variables used in the condition
                ctx.addFact("loopDef", [loopId, funName], stmt.loc);
                const add = (id) => {
                    usedInCond.add(id.text);
                    ctx.addFact("loopCondDef", [id.text, loopId, funName], id.loc);
                };
                const cond = stmt.condition;
                // TODO: This could be improved using the constant evaluator when
                // available in the compiler API: #71
                if (cond.kind === "id") {
                    // e.g.: while(a)
                    add(cond);
                }
                else if (cond.kind === "op_unary" && cond.operand.kind === "id") {
                    // e.g.: while(!a)
                    add(cond.operand);
                }
                else if (cond.kind === "op_binary" &&
                    cond.left.kind === "id" &&
                    (0, imports_1.isLiteral)(cond.right)) {
                    // e.g.: while(a < 10)
                    add(cond.left);
                }
                else if (cond.kind === "op_binary" &&
                    cond.right.kind === "id" &&
                    (0, imports_1.isLiteral)(cond.left)) {
                    // e.g.: while(10 > a)
                    add(cond.right);
                }
                (0, tact_1.forEachStatement)(stmt, (s) => {
                    if (s.kind === "statement_assign" ||
                        s.kind === "statement_augmentedassign") {
                        ctx.addFact("loopVarUse", [(0, tact_1.extractPath)(s.path), loopId, funName], s.loc);
                    }
                    else if (s.kind === "statement_expression") {
                        const callExpr = s.expression;
                        if (callExpr.kind === "method_call" ||
                            callExpr.kind === "static_call") {
                            callExpr.args.forEach((a) => {
                                (0, tact_1.forEachExpression)(a, (expr) => {
                                    if (expr.kind === "id" && usedInCond.has(expr.text)) {
                                        ctx.addFact("loopVarUse", [expr.text, loopId, funName], s.loc);
                                    }
                                });
                            });
                        }
                    }
                });
            }
        });
    }
}
exports.UnboundLoop = UnboundLoop;
