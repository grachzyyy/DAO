"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnusedExpressionResult = void 0;
const tact_1 = require("../../internals/tact");
const imports_1 = require("../../internals/tact/imports");
const imports_2 = require("../../internals/tact/imports");
const util_1 = require("../../internals/util");
const warnings_1 = require("../../internals/warnings");
const detector_1 = require("../detector");
/**
 * Suppressed functions which result typically could be ignored.
 */
const IGNORED_FUNCTIONS = new Set(["send"]);
/**
 * A detector that identifies expression statements whose result is unused.
 *
 * ## Why is it bad?
 * Expression statements that don't alter the contract's state and whose results are not used
 * can lead to inefficiency, dead code, and potential confusion. They add unnecessary complexity
 * without contributing to the logic or state of the contract.
 *
 * ## Example
 * ```tact
 * self.foo == 3; // Warning: unused boolean expression
 * inc(a); // Warning: unused return value
 * ```
 *
 * Use instead:
 * ```tact
 * self.foo = 3; // Fixed: corrected assignment
 * newValue = inc(a); // OK: result is now used
 * let _ = inc(a); // OK: explicitly ignored
 * ```
 */
class UnusedExpressionResult extends detector_1.AstDetector {
    severity = warnings_1.Severity.MEDIUM;
    category = warnings_1.Category.SECURITY;
    /**
     * Return types that the available free functions have.
     */
    freeFunctionReturnTypes = new Map();
    async check(cu) {
        this.freeFunctionReturnTypes = cu.ast.getReturnTypes();
        return cu.ast.getProgramEntries().reduce((acc, node) => {
            if (node.kind === "trait" || node.kind === "contract") {
                const methodReturnTypes = cu.ast.getMethodReturnTypes(node.id);
                acc = acc.concat(this.checkFunction(node, methodReturnTypes));
            }
            else if (node.kind === "function_def") {
                acc = acc.concat(this.checkFunction(node, undefined));
            }
            return acc;
        }, []);
    }
    /**
     * @param methodReturnTypes Return types of methods of the current trait/contract.
     */
    checkFunction(node, methodReturnTypes) {
        const warnings = [];
        (0, tact_1.forEachStatement)(node, (stmt) => {
            if (stmt.kind === "statement_expression") {
                this.checkExpressionStatement(stmt, methodReturnTypes).forEach((w) => warnings.push(w));
            }
        });
        return warnings;
    }
    /**
     * Generates warnings if `stmt` contains expressions which result is unused.
     * @param methodReturnTypes Return types of methods of the current trait/contract.
     */
    checkExpressionStatement(stmt, methodReturnTypes) {
        return this.checkExpression(stmt.expression, methodReturnTypes);
    }
    /**
     * @param methodReturnTypes Return types of methods of the current trait/contract.
     */
    checkExpression(expr, methodReturnTypes) {
        const warnings = [];
        const warn = () => this.makeWarning(`Result of evaluation of ${(0, imports_2.prettyPrint)(expr)} is unused`, expr.loc, {
            suggestion: "Remove the expression or assign its result",
        });
        switch (expr.kind) {
            case "struct_instance":
            case "struct_value":
            case "init_of":
            case "code_of":
                break; // do nothing
            case "op_binary":
            case "op_unary":
            case "field_access":
            case "number":
            case "id":
            case "boolean":
            case "null":
            case "string":
            case "simplified_string":
            case "address":
            case "cell":
            case "slice":
                warnings.push(warn());
                break;
            case "method_call":
                if (methodReturnTypes &&
                    (0, tact_1.isSelf)(expr.self) &&
                    methodReturnTypes.get((0, imports_1.idText)(expr.method))) {
                    warnings.push(warn());
                }
                break;
            case "static_call": {
                const funName = (0, imports_1.idText)(expr.function);
                if (!IGNORED_FUNCTIONS.has(funName) &&
                    this.freeFunctionReturnTypes.get(funName)) {
                    warnings.push(warn());
                }
                break;
            }
            case "conditional":
                warnings.push(...this.checkExpression(expr.thenBranch, methodReturnTypes));
                warnings.push(...this.checkExpression(expr.elseBranch, methodReturnTypes));
                break;
            default:
                (0, util_1.unreachable)(expr);
        }
        return warnings;
    }
}
exports.UnusedExpressionResult = UnusedExpressionResult;
