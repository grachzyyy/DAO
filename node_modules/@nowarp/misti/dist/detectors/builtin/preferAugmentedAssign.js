"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PreferAugmentedAssign = void 0;
const tact_1 = require("../../internals/tact");
const imports_1 = require("../../internals/tact/imports");
const warnings_1 = require("../../internals/warnings");
const detector_1 = require("../detector");
const AstAugmentedAssignOperations = new Set([
    "+",
    "-",
    "*",
    "/",
    "%",
    "|",
    "&",
    "^",
]);
/**
 * If the left-hand side (lhs) or right-hand side (rhs) of the binary expression
 * in assignment expressions has any of these kinds, the detector won't suggest
 * replacing it with an augmented assignment to improve readability.
 */
const DontSuggestKinds = new Set([
    "conditional",
    "init_of",
    "struct_instance",
    "op_unary",
    "op_binary",
]);
/**
 * Detects non-idiomatic statements that can be written using augmented assignment
 * operators like `+=`, `-=`, etc.
 *
 * ## Why is it bad?
 * Using augmented assignment operations improves the readability of the source code
 * and reduces the risk of mistakes, such as those that occur during copy-pasting
 * and refactoring code.
 *
 * ## Example
 * ```tact
 * msgValue = (msgValue - ctx.readForwardFee());
 * ```
 *
 * Use instead:
 * ```tact
 * msgValue -= ctx.readForwardFee());
 * ```
 */
class PreferAugmentedAssign extends detector_1.AstDetector {
    severity = warnings_1.Severity.INFO;
    category = warnings_1.Category.BEST_PRACTICES;
    async check(cu) {
        return cu.ast.getProgramEntries().reduce((acc, node) => {
            return acc.concat((0, tact_1.foldStatements)(node, (acc, expr) => {
                return this.findAugmentedAssignReplacements(acc, expr);
            }, []));
        }, []);
    }
    /**
     * Looks for assignment statements with a binary operation in rhs that could be
     * replaced with the augmented assignment.
     */
    findAugmentedAssignReplacements(acc, stmt) {
        if (stmt.kind === "statement_assign" &&
            stmt.expression.kind === "op_binary" &&
            (this.pathsAreEqual(stmt.path, stmt.expression.left) ||
                this.pathsAreEqual(stmt.path, stmt.expression.right)) &&
            AstAugmentedAssignOperations.has(stmt.expression.op) &&
            !DontSuggestKinds.has(stmt.expression.left.kind) &&
            !DontSuggestKinds.has(stmt.expression.right.kind)) {
            const suggestedRhs = this.pathsAreEqual(stmt.path, stmt.expression.left)
                ? (0, imports_1.prettyPrint)(stmt.expression.right)
                : (0, imports_1.prettyPrint)(stmt.expression.left);
            const suggestedChange = `${(0, imports_1.prettyPrint)(stmt.path)} ${stmt.expression.op}= ${suggestedRhs}`;
            acc.push(this.makeWarning(`Prefer augmented assignment: ${suggestedChange}`, stmt.loc, {
                suggestion: `Consider using augmented assignment instead: ${suggestedChange}`,
            }));
        }
        return acc;
    }
    pathsAreEqual(expr1, expr2) {
        const path1 = (0, imports_1.tryExtractPath)(expr1);
        if (path1 === null) {
            return false;
        }
        const path2 = (0, imports_1.tryExtractPath)(expr2);
        if (path2 === null) {
            return false;
        }
        return path1.every((p1) => path2.find((p2) => p2.text === p1.text) !== undefined);
    }
}
exports.PreferAugmentedAssign = PreferAugmentedAssign;
