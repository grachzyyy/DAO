"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArgCopyMutation = void 0;
const exceptions_1 = require("../../internals/exceptions");
const tact_1 = require("../../internals/tact");
const imports_1 = require("../../internals/tact/imports");
const util_1 = require("../../internals/util");
const warnings_1 = require("../../internals/warnings");
const detector_1 = require("../detector");
/**
 * A detector that highlights cases where function argument mutations are ineffective
 * due to [call-by-value semantics](https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_value) in Tact.
 *
 * ## Why is it bad?
 * In Tact, function arguments are passed by value, meaning that any mutations applied
 * to these arguments will only affect the local copy of the variable within the function.
 * Such mutations are unobservable outside the function, except for potentially
 * increasing gas consumption or causing exceptions.
 *
 * ## Example
 * ```tact
 * fun addEntry(m: map<Int,Int>) {
 *   m.set(1, 10); // Bad: Mutating the copy
 * }
 * ```
 *
 * Use instead:
 * ```tact
 * fun addEntry() {
 *   self.m.set(1, 10); // OK: Changing contract's state
 * }
 * ```
 *
 * Alternatively, you could redesign the method:
 * ```tact
 * fun generateNewValue(): Int {
 *   // ... produce new value for the map
 *   return self.nextValue + 1;
 * }
 *
 * m.set(self.nextKey, self.generateNewValue()); // OK
 * ```
 */
class ArgCopyMutation extends detector_1.AstDetector {
    severity = warnings_1.Severity.HIGH;
    category = warnings_1.Category.SECURITY;
    async check(cu) {
        const returnStatements = this.collectReturnStatements(cu);
        return Array.from(cu.ast.getFunctions()).reduce((acc, fun) => {
            if (fun.kind === "contract_init" || fun.kind === "function_def") {
                this.collectMutations(fun).forEach((argMutationStatements, argName) => {
                    // If all the return statements use the modified argument, it won't be reported
                    if (fun.kind === "function_def") {
                        const funReturns = returnStatements.get((0, imports_1.idText)(fun.name));
                        if (funReturns === undefined) {
                            this.ctx.logger.error(`Cannot find return statements: ${(0, imports_1.idText)(fun.name)}`);
                            return;
                        }
                        if (this.usedInAllReturns(argName, funReturns)) {
                            return; // OK
                        }
                    }
                    const occurrencesStr = argMutationStatements.length > 1
                        ? ` (${argMutationStatements.length - 1} more times)`
                        : "";
                    acc.push(this.makeWarning(`Function ${(0, tact_1.funName)(fun)} argument ${argName} is mutated${occurrencesStr}`, argMutationStatements[0].loc, {
                        extraDescription: "Mutating function arguments has no effect outside the function due to call-by-value semantics",
                        suggestion: "Return the modified value or use the contract's state to avoid unnecessary mutations",
                    }));
                });
            }
            return acc;
        }, []);
    }
    /**
     * Checks if the argument is used in all return statements.
     * @param argName The name of the argument to check.
     * @param returnStatements The return statements to check.
     * @returns `true` if the argument is used in all return statements, `false` otherwise.
     */
    usedInAllReturns(argName, returnStatements) {
        if (returnStatements.length === 0) {
            return false;
        }
        return returnStatements.every((stmt) => {
            if (stmt.kind !== "statement_return" || !stmt.expression) {
                return false;
            }
            return (0, tact_1.hasInExpressions)(stmt.expression, (expr) => expr.kind === "id" && expr.text === argName);
        });
    }
    /**
     * Collects all return statements from the given compilation unit.
     * @param cu The compilation unit to analyze.
     * @returns A map of function names to their return statements.
     */
    collectReturnStatements(cu) {
        return cu.foldCFGs(new Map(), (acc, cfg) => {
            acc.set(cfg.name, cfg.getExitNodes().reduce((acc, bb) => {
                const stmt = cu.ast.getStatement(bb.stmtID);
                if (!stmt) {
                    throw exceptions_1.InternalException.make(`Cannot find a statement for BB #${bb.idx}`);
                }
                // Filter out throw statements
                if (stmt.kind === "statement_return") {
                    acc.push(stmt);
                }
                return acc;
            }, []));
            return acc;
        }, { includeStdlib: false });
    }
    /**
     * Collects mutations of function arguments within a given statement.
     * @param fun The function to analyze.
     * @returns A map of argument names to the statements where they are mutated.
     */
    collectMutations(fun) {
        return (0, tact_1.foldStatements)(fun, (acc, stmt) => {
            const interestingArgs = this.collectInterestingArgs(fun);
            if (interestingArgs.length === 0) {
                return acc;
            }
            const stmtMutations = this.findArgCopyMutations(stmt, interestingArgs);
            return Array.from(stmtMutations.entries()).reduce((newAcc, [argName, mutationStmts]) => {
                const existingStmts = newAcc.get(argName) || [];
                return newAcc.set(argName, [...existingStmts, ...mutationStmts]);
            }, new Map(acc));
        }, new Map());
    }
    /**
     * Collects names of function argument that should be handled by this detector.
     */
    collectInterestingArgs(fun) {
        return fun.params.reduce((acc, p) => {
            // TODO: Should be improved when we have types in AST
            // Sort out integral types. It is unlikely that the user will expect they change inside the function.
            // See: tact:src/types/resolveExpression.ts
            const skipTypes = ["Int", "Bool"];
            if (p.type.kind === "type_id" && skipTypes.includes(p.type.text)) {
                return acc;
            }
            acc.push((0, imports_1.idText)(p.name));
            return acc;
        }, []);
    }
    /**
     * Identifies mutations of function arguments within a given statement.
     * @param argNames Names of function arguments to check for mutations.
     * @returns A map of argument names to the statements where they are mutated.
     */
    findArgCopyMutations(stmt, argNames) {
        const mutations = (0, tact_1.collectMutations)(stmt, { flatStmts: true });
        const foundMutations = mutations
            ? (0, util_1.intersectLists)(argNames, (0, tact_1.mutationNames)(mutations.mutatedLocals))
            : [];
        return foundMutations.reduce((mutationMap, argName) => {
            const existingStatements = mutationMap.get(argName) || [];
            return mutationMap.set(argName, [...existingStatements, stmt]);
        }, new Map());
    }
}
exports.ArgCopyMutation = ArgCopyMutation;
