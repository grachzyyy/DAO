"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OptimalMathFunction = void 0;
const tact_1 = require("../../internals/tact");
const imports_1 = require("../../internals/tact/imports");
const warnings_1 = require("../../internals/warnings");
const detector_1 = require("../detector");
const REPLACEMENTS = {
    log: "log2",
    pow: "pow2",
};
/**
 * A detector that highlights standard library math function calls that have more gas-efficient alternatives.
 *
 * ## Why is it bad?
 * Tact supports `log2`/`pow2` functions, which are more gas-efficient than `log(x, 2)`/`pow(x, 2)`.
 *
 * ## Example
 * ```tact
 * log(x, 2);
 * ```
 *
 * Use instead:
 * ```tact
 * log2(x)
 * ```
 */
class OptimalMathFunction extends detector_1.AstDetector {
    severity = warnings_1.Severity.LOW;
    category = warnings_1.Category.OPTIMIZATION;
    async check(cu) {
        return cu.ast.getProgramEntries().reduce((acc, node) => {
            return acc.concat((0, tact_1.foldExpressions)(node, (acc, expr) => {
                return this.findSuboptimalCall(acc, expr);
            }, []));
        }, []);
    }
    findSuboptimalCall(acc, expr) {
        if (expr.kind === "static_call") {
            const funName = (0, imports_1.idText)(expr.function);
            const suggestedFun = REPLACEMENTS[funName] || undefined;
            if (suggestedFun &&
                expr.args.length === 2 &&
                (0, tact_1.evalsToLiteral)(expr.args[1], tact_1.MakeLiteral.number(2n))) {
                const firstArg = expr.args[0];
                acc.push(this.makeWarning(`Use more gas-efficient function: ${suggestedFun}(${(0, imports_1.prettyPrint)(firstArg)})`, expr.loc, {
                    suggestion: "Choose more gas-efficient function",
                }));
            }
        }
        return acc;
    }
}
exports.OptimalMathFunction = OptimalMathFunction;
