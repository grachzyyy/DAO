"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FalseCondition = void 0;
const quickfix_1 = require("../../internals/quickfix");
const tact_1 = require("../../internals/tact");
const warnings_1 = require("../../internals/warnings");
const detector_1 = require("../detector");
/**
 * A detector that highlights conditions that evaluate to a constant `true` or `false`
 * in `if`, `while`, or `until` statements, and zero iterations in `repeat` statements.
 *
 * ## Why is it bad?
 * Conditions that always evaluate to a constant `true` or `false` are likely the result of a typo
 * or logic error. Such conditions can lead to unintended behavior, dead code, or incorrect control flow.
 * This detector helps identify these cases so they can be corrected, improving the code's reliability.
 *
 * ## Example
 * ```tact
 * const FALSE: Bool = false;
 * // Bad: Always false because of operator precedence
 * if ((param | value) & FALSE) {
 *  // ... never executed
 * }
 * ```
 *
 * Use instead:
 * ```tact
 * const FALSE: Bool = false;
 * // OK: Fixed after the analyzer highlighted this
 * if (param) {}
 * ```
 */
class FalseCondition extends detector_1.AstDetector {
    severity = warnings_1.Severity.MEDIUM;
    category = warnings_1.Category.SECURITY;
    async check(cu) {
        return Array.from(cu.ast.getFunctions()).reduce((acc, fun) => acc.concat(this.checkFunction(fun)), []);
    }
    /**
     * Checks if the given function contains any false conditions.
     */
    checkFunction(fun) {
        return (0, tact_1.foldStatements)(fun, (acc, stmt) => {
            (0, tact_1.forEachExpression)(stmt, (expr) => {
                if (expr.kind === "conditional" &&
                    this.constEvalToFalse(expr.condition)) {
                    acc.push(this.warnCondition(stmt));
                }
            });
            if (stmt.kind === "statement_condition") {
                (0, tact_1.collectConditions)(stmt, { nonEmpty: true }).forEach((cond) => {
                    if (this.constEvalToFalse(cond))
                        acc.push(this.warnCondition(stmt));
                });
            }
            if ((stmt.kind === "statement_while" ||
                stmt.kind === "statement_until") &&
                stmt.statements.length > 0 &&
                this.constEvalToFalse(stmt.condition)) {
                acc.push(this.warnCondition(stmt));
            }
            if (stmt.kind === "statement_repeat" &&
                stmt.statements.length > 0 &&
                this.constEvalToZero(stmt.iterations)) {
                acc.push(this.warnCondition(stmt, true));
            }
            return acc;
        }, []);
    }
    warnCondition(stmt, isZero = false) {
        const message = isZero
            ? "Condition always evaluates to zero"
            : "Condition always evaluates to false";
        return this.makeWarning(message, stmt.loc, {
            quickfixes: [
                (0, quickfix_1.makeDelete)("Remove the condition", true, (0, quickfix_1.makeRange)(stmt.loc)),
            ],
        });
    }
    constEvalToZero = (expr) => (0, tact_1.evalsToLiteral)(expr, tact_1.MakeLiteral.number(0n));
    constEvalToFalse = (expr) => (0, tact_1.evalsToLiteral)(expr, tact_1.MakeLiteral.boolean(false));
}
exports.FalseCondition = FalseCondition;
