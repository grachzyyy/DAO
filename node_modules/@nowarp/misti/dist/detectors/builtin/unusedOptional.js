"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnusedOptional = void 0;
const tact_1 = require("../../internals/tact");
const imports_1 = require("../../internals/tact/imports");
const imports_2 = require("../../internals/tact/imports");
const warnings_1 = require("../../internals/warnings");
const detector_1 = require("../detector");
/**
 * A detector variables and fields with unused optional modifier.
 *
 * ## Why is it bad?
 * `Optional` is a nullable value that has a special `null` value indicating the absence
 * of a value. If a developer creates an optional variable or field, he should leverage
 * its functionality by accessing the `null` value somewhere in his code. Otherwise,
 * the optional type should be removed to simplify and optimize the code.
 *
 * ## Example
 * ```tact
 * contract Test {
 *   a: Int?; // Bad: null value is never accessed
 *   init() { self.a = 42; }
 *   get fun getA(): Int { return self.a!!; }
 * }
 * ```
 *
 * Use instead:
 * ```tact
 * contract Test {
 *   a: Int = 42; // OK: Removed optional
 *   get fun getA(): Int { return self.a; }
 * }
 * ```
 */
class UnusedOptional extends detector_1.AstDetector {
    severity = warnings_1.Severity.LOW;
    category = warnings_1.Category.OPTIMIZATION;
    async check(cu) {
        const freeFunctionWarnings = Array.from(cu.ast.getProgramEntries()).reduce((acc, entry) => {
            if (entry.kind === "function_def") {
                return [...acc, ...this.checkFunction(entry)];
            }
            return acc;
        }, []);
        const contractWarnings = Array.from(cu.ast.getContracts()).reduce((acc, contract) => [...acc, ...this.checkContract(contract)], []);
        return [...freeFunctionWarnings, ...contractWarnings];
    }
    /**
     * Checks for unused optional variables in local variables of a free function.
     * @param unusedOptionalFields Optional fields which use has not been found yet.
     */
    checkFunction(fun, unusedOptionalFields = new Set()) {
        return Array.from((0, tact_1.foldStatements)(fun, (unusedOptionalVars, stmt) => {
            if (stmt.kind === "statement_let" &&
                stmt.type !== undefined &&
                stmt.type.kind === "optional_type" &&
                // Filter out variables resulted of expressions that return optionals
                !this.returnsOptional(stmt.expression)) {
                unusedOptionalVars.set((0, imports_1.idText)(stmt.name), {
                    name: stmt.name,
                    originalType: stmt.type.typeArg,
                });
            }
            this.removeUsedOptionals(stmt, unusedOptionalVars, unusedOptionalFields);
            return unusedOptionalVars;
        }, new Map()).values()).map(({ name, originalType }) => this.makeWarning(`Unused optional modifier: ${(0, imports_1.idText)(name)}`, name.loc, {
            suggestion: `Remove optional modifier: \`let ${(0, imports_1.idText)(name)}: ${(0, imports_2.prettyPrint)(originalType)}\``,
        }));
    }
    /**
     * Remove previously found variables which optional modifier is used.
     */
    removeUsedOptionals(stmt, unusedOptionalVars, unusedOptionalFields) {
        // Assignments to field access operations
        if (stmt.kind === "statement_assign" ||
            stmt.kind === "statement_augmentedassign") {
            const found = (0, tact_1.hasInExpressions)(stmt.path, (expr) => {
                return expr.kind === "id" || expr.kind === "field_access";
            });
            if (found) {
                if (stmt.path.kind === "id") {
                    unusedOptionalVars.delete((0, imports_1.idText)(stmt.path));
                }
                else if (stmt.path.kind === "field_access" &&
                    stmt.path.aggregate.kind === "id" &&
                    stmt.path.aggregate.text === "self") {
                    unusedOptionalFields.delete(stmt.path.field.text);
                }
            }
        }
        (0, tact_1.forEachExpression)(stmt, (expr) => {
            // null comparisons
            if (expr.kind === "op_binary") {
                [
                    { id: expr.left, null: expr.right },
                    { id: expr.right, null: expr.left },
                ].forEach(({ id, null: nullSide }) => {
                    if (id.kind === "id" && nullSide.kind === "null") {
                        unusedOptionalVars.delete((0, imports_1.idText)(id));
                    }
                    else if (id.kind === "field_access" &&
                        id.aggregate.kind === "id" &&
                        id.aggregate.text === "self" &&
                        nullSide.kind === "null") {
                        unusedOptionalFields.delete(id.field.text);
                    }
                });
            }
            // Variables and fields involved in function calls
            if (expr.kind === "static_call" || expr.kind === "method_call") {
                expr.args.forEach((arg) => {
                    if (arg.kind === "id") {
                        unusedOptionalVars.delete((0, imports_1.idText)(arg));
                    }
                    else if (arg.kind === "field_access" &&
                        arg.aggregate.kind === "id" &&
                        arg.aggregate.text === "self") {
                        unusedOptionalFields.delete(arg.field.text);
                    }
                });
            }
        });
    }
    /**
     * Checks for unused optional variables in fields and method local variables of contracts.
     */
    checkContract(contract) {
        const fields = (0, tact_1.collectFields)(contract);
        const optionalFields = new Map(Array.from(fields.entries()).filter(([_, decl]) => decl.type.kind === "optional_type"));
        const optionalFieldNames = new Set(optionalFields.keys());
        const localVariablesWarnings = contract.declarations.reduce((acc, decl) => {
            if (decl.kind === "function_def" ||
                decl.kind === "contract_init" ||
                decl.kind === "receiver") {
                return [...acc, ...this.checkFunction(decl, optionalFieldNames)];
            }
            return acc;
        }, []);
        const fieldWarnings = Array.from(optionalFields.keys()).reduce((acc, fieldName) => {
            if (optionalFieldNames.has(fieldName)) {
                const decl = optionalFields.get(fieldName);
                const originalType = decl.type.typeArg;
                acc.push(this.makeWarning(`Unused optional modifier: ${fieldName}`, decl.loc, {
                    suggestion: `Remove optional modifier: \`${fieldName}: ${(0, imports_2.prettyPrint)(originalType)}\``,
                }));
            }
            return acc;
        }, []);
        return [...fieldWarnings, ...localVariablesWarnings];
    }
    /**
     * Indicates if the given expression has to return an optional, therefore if it is used as the rhs in an
     * assignment, the lhs should not be reported.
     */
    returnsOptional(expr) {
        // XXX: We consider all the values returning from functions as those that might be optional.
        //      We need types in the AST to be more precise here.
        const isCall = expr.kind === "static_call" || expr.kind === "method_call";
        // XXX: We cannot handle field access for the reason.
        const isFieldAccess = expr.kind === "field_access";
        return isCall || isFieldAccess;
    }
}
exports.UnusedOptional = UnusedOptional;
