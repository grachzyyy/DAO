"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DivideBeforeMultiply = void 0;
const exceptions_1 = require("../../internals/exceptions");
const tact_1 = require("../../internals/tact");
const warnings_1 = require("../../internals/warnings");
const detector_1 = require("../detector");
const souffle_1 = require("@nowarp/souffle");
/**
 * A detector that identifies and corrects instances of division before multiplication to
 * ensure accurate mathematical operations.
 *
 * ## Why is it bad?
 * Performing division before multiplication can lead to unexpected results due to precision loss and rounding errors:
 * * **Precision Loss:** Dividing first can result in significant precision loss, especially when dealing with integers or fixed-point numbers.
 * * **Rounding Errors:** Early division might cause rounding errors that propagate through subsequent calculations.
 * * **Unexpected Behavior:** Incorrectly ordered operations can lead to incorrect outcomes, making debugging and maintenance more challenging.
 *
 * ## Example
 * ```tact
 * let a: Int = 10;
 * let b: Int = 3;
 * let c: Int = 2;
 * // Bad: Division before multiplication
 * let result: Int = a / b * c;
 * ```
 *
 * Use instead:
 * ```tact
 * let a: Int = 10;
 * let b: Int = 3;
 * let c: Int = 2;
 * // Correct: Multiplication before division
 * let result: Int = a * c / b;
 * ```
 */
class DivideBeforeMultiply extends detector_1.SouffleDetector {
    severity = warnings_1.Severity.HIGH;
    category = warnings_1.Category.SECURITY;
    async check(cu) {
        const program = this.createSouffleContext(cu);
        this.addDecls(program);
        this.addRules(program);
        this.addConstraints(cu, program);
        return await this.executeSouffle(program, (fact) => {
            if (fact.data === undefined) {
                throw exceptions_1.InternalException.make(`AST position for fact ${fact} is not available`);
            }
            return this.makeWarning("Division operation comes before multiplication", fact.data, {
                extraDescription: "Performing division before multiplication can lead to unexpected results due to precision loss and rounding errors",
                suggestion: "Consider rearranging the operations: division should follow multiplication",
            });
        });
    }
    addDecls(ctx) {
        ctx.add((0, souffle_1.relation)("divDef", [
            ["divId", "Number"],
            ["func", "Symbol"],
        ], undefined, "Division expression definition."));
        ctx.add((0, souffle_1.relation)("divUsedInMul", [
            ["mulId", "Number"],
            ["divId", "Number"],
            ["func", "Symbol"],
        ], undefined, "Division expressions defined within the multiplication expression (both lhs or rhs)."));
        ctx.add((0, souffle_1.relation)("varDef", [
            ["var", "Symbol"],
            ["func", "Symbol"],
        ], undefined, "Local variable definition."));
        ctx.add((0, souffle_1.relation)("varTaintedWithDiv", [
            ["var", "Symbol"],
            ["divId", "Number"],
            ["func", "Symbol"],
        ], undefined, [
            "Describes variables appearing in the division expression or assigning to a result of the division.",
            "Examples:",
            "* `10 / a` or `a / 10` will create a fact `varTaintedWithDiv(a, <id>)`",
            "* `let a: Int = 10 / 3;` will create a fact `varTaintedWithDiv(a, <id>)` as well",
        ]));
        ctx.add((0, souffle_1.relation)("varUsedInMul", [
            ["mulId", "Number"],
            ["var", "Symbol"],
            ["func", "Symbol"],
        ], undefined, [
            "Describes variables appearing in the multiply expression.",
            "For example: `a * 3` or `3 + (a * 4)` will create a fact `varUsedInMul(a, <id>)`.",
        ]));
        ctx.add((0, souffle_1.relation)("varAssign", [
            ["assigned", "Symbol"],
            ["assignee", "Symbol"],
            ["func", "Symbol"],
        ], undefined, [
            "Variable assignment to any expression containing another variable used for taint propagation.",
            "For example: `a = (b + 42) - 2` will create a fact: `varAssign(a, b)`.",
        ]));
        ctx.add((0, souffle_1.relation)("taintedWithDiv", [
            ["var", "Symbol"],
            ["divId", "Number"],
            ["func", "Symbol"],
        ], undefined, "Recursive rule that expresses taint propagation for local variables involved in the division operation."));
        ctx.add((0, souffle_1.relation)("divBeforeMul", [
            ["divId", "Number"],
            ["mulId", "Number"],
            ["func", "Symbol"],
        ], undefined, "Main rule: simple case."));
        ctx.add((0, souffle_1.relation)("taintedVarInMul", [
            ["var", "Symbol"],
            ["divId", "Number"],
            ["func", "Symbol"],
        ], undefined, "Main rule: tainted case."));
        ctx.add((0, souffle_1.relation)("violated", [
            ["divId", "Number"],
            ["func", "Symbol"],
        ], "output", "Projection rule to refer the appropriate division operations in the output"));
    }
    addRules(ctx) {
        ctx.add((0, souffle_1.rule)([(0, souffle_1.atom)("taintedWithDiv", ["var", "divId", "func"])], [
            (0, souffle_1.body)((0, souffle_1.atom)("varDef", ["var", "func"])),
            (0, souffle_1.body)((0, souffle_1.atom)("divDef", ["divId", "func"])),
            (0, souffle_1.body)((0, souffle_1.atom)("varTaintedWithDiv", ["var", "divId", "func"])),
        ], [
            "Base case: direct tainting with division. For example:",
            "```",
            "let a: Int = 10 / 3;",
            "a * 5;",
            "```",
        ]));
        ctx.add((0, souffle_1.rule)([(0, souffle_1.atom)("taintedWithDiv", ["var", "divId", "func"])], [
            (0, souffle_1.body)((0, souffle_1.atom)("varDef", ["var", "func"])),
            (0, souffle_1.body)((0, souffle_1.atom)("varDef", ["intermediateVar", "func"])),
            (0, souffle_1.body)((0, souffle_1.atom)("varAssign", ["var", "intermediateVar", "func"])),
            (0, souffle_1.body)((0, souffle_1.atom)("taintedWithDiv", ["intermediateVar", "divId", "func"])),
        ], "Indirect tainting through another tainted variable."));
        ctx.add((0, souffle_1.rule)([(0, souffle_1.atom)("divBeforeMul", ["mulId", "divId", "func"])], [
            (0, souffle_1.body)((0, souffle_1.atom)("divDef", ["divId", "func"])),
            (0, souffle_1.body)((0, souffle_1.atom)("divUsedInMul", ["mulId", "divId", "func"])),
        ], "Simple case: Division expression appears inside the multiply expression."));
        ctx.add((0, souffle_1.rule)([(0, souffle_1.atom)("taintedVarInMul", ["var", "divId", "func"])], [
            (0, souffle_1.body)((0, souffle_1.atom)("taintedWithDiv", ["var", "divId", "func"])),
            (0, souffle_1.body)((0, souffle_1.atom)("varUsedInMul", ["_", "var", "func"])),
        ], "Tainted case: Using a variable tainted with division in the multiply expression."));
        ctx.add((0, souffle_1.rule)([(0, souffle_1.atom)("violated", ["divId", "func"])], [(0, souffle_1.body)((0, souffle_1.atom)("taintedVarInMul", ["_", "divId", "func"]))], "The projection rule used to parse output"));
        ctx.add((0, souffle_1.rule)([(0, souffle_1.atom)("violated", ["divId", "func"])], [(0, souffle_1.body)((0, souffle_1.atom)("divBeforeMul", ["_", "divId", "func"]))], "The projection rule used to parse output"));
    }
    /**
     * Iterates for each binary operation within the node.
     */
    forEachBinop(node, callback) {
        (0, tact_1.forEachExpression)(node, (expr) => {
            if (expr.kind === "op_binary") {
                callback(expr);
            }
        });
    }
    /**
     * Collects all the identifiers used within the node.
     */
    collectIdentifiers(node) {
        const isId = (acc, expr) => {
            if (expr.kind === "id") {
                acc.push(expr.text);
            }
            return acc;
        };
        return (0, tact_1.foldExpressions)(node, isId, []);
    }
    /**
     * Collects facts based on the IR to populate the Souffle program.
     * @param cu The compilation unit containing the CFGs and AST information.
     * @param ctx The Souffle program to which the facts are added.
     */
    addConstraints(cu, ctx) {
        cu.forEachBasicBlock(cu.ast, (cfg, _, stmt) => {
            if (cfg.origin === "stdlib") {
                return;
            }
            const funName = cfg.name;
            // Collect information about variables definitions and tainted divisions in initializers
            (0, tact_1.forEachStatement)(stmt, (s) => {
                if (s.kind === "statement_let") {
                    const varName = s.name.text;
                    ctx.addFact("varDef", [varName, funName], s.loc);
                    this.collectIdentifiers(s.expression).forEach((rhsName) => {
                        ctx.addFact("varAssign", [varName, rhsName, funName], s.loc);
                    });
                    // Collect taints in the initializers, e.g.: `a = 10 / 3`
                    this.forEachBinop(s.expression, (binopExpr) => {
                        if (binopExpr.op === "/") {
                            const divId = binopExpr.id;
                            ctx.addFact("varTaintedWithDiv", [varName, divId, funName], binopExpr.loc);
                        }
                    });
                }
            });
            // Collect information about expressions
            this.forEachBinop(stmt, (binopExpr) => {
                if (binopExpr.op === "/") {
                    ctx.addFact("divDef", [binopExpr.id, funName], binopExpr.loc);
                }
                if (binopExpr.op === "*") {
                    const mulId = binopExpr.id;
                    this.collectIdentifiers(binopExpr).forEach((usedVar) => {
                        ctx.addFact("varUsedInMul", [mulId, usedVar, funName], binopExpr.loc);
                    });
                    const processBinop = (binOpExpr) => {
                        if (binOpExpr.op === "/") {
                            const divId = binOpExpr.id;
                            ctx.addFact("divUsedInMul", [mulId, divId, funName], binOpExpr.loc);
                            this.collectIdentifiers(binOpExpr).forEach((usedVar) => {
                                ctx.addFact("varTaintedWithDiv", [usedVar, divId, funName], binOpExpr.loc);
                            });
                        }
                    };
                    this.forEachBinop(binopExpr.left, processBinop);
                    this.forEachBinop(binopExpr.right, processBinop);
                }
            });
        });
    }
}
exports.DivideBeforeMultiply = DivideBeforeMultiply;
