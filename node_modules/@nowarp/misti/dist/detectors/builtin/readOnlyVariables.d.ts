import { CompilationUnit } from "../../internals/ir";
import { SrcInfo } from "../../internals/tact/imports";
import { Category, Warning, Severity } from "../../internals/warnings";
import { SouffleDetector, WarningsBehavior } from "../detector";
import { SouffleContext } from "@nowarp/souffle";
/**
 * A detector that identifies read-only variables and fields.
 *
 * ## Why is it bad?
 * These variables could typically be replaced with constants to optimize performance.
 * Alternatively, identifying read-only variables may reveal issues where unused values are being replaced unintentionally.
 *
 * ## Example
 * ```tact
 * fun calculateFinalPrice(price: Int): Int {
 *   // Warning: the developer uses a read-only variable that could be a constant
 *   let DISCOUNT_AMOUNT: Int = 10;
 *   return price - DISCOUNT_AMOUNT;
 * }
 * ```
 *
 * Use instead:
 * ```tact
 * const DISCOUNT_AMOUNT: Int = 10;
 *
 * fun calculateFinalPrice(price: Int): Int {
 *   // OK: Fixed after the analyzer highlighted this warning
 *   return price - DISCOUNT_AMOUNT;
 * }
 * ```
 */
export declare class ReadOnlyVariables extends SouffleDetector {
    severity: Severity;
    category: Category;
    get shareImportedWarnings(): WarningsBehavior;
    check(cu: CompilationUnit): Promise<Warning[]>;
    /**
     * Adds declarations to the Souffle program to represent the properties of variables.
     * @param ctx The Souffle program where the relations are to be added.
     */
    addDecls(ctx: SouffleContext<SrcInfo>): void;
    /**
     * Collects facts based on the IR to populate the Souffle program.
     * @param cu The compilation unit containing the CFGs and AST information.
     * @param ctx The Souffle program to which the facts are added.
     */
    addConstraints(cu: CompilationUnit, ctx: SouffleContext<SrcInfo>): void;
    addRules(ctx: SouffleContext<SrcInfo>): void;
}
