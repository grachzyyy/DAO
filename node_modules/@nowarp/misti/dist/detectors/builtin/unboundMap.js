"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnboundMap = void 0;
const tact_1 = require("../../internals/tact");
const imports_1 = require("../../internals/tact/imports");
const warnings_1 = require("../../internals/warnings");
const detector_1 = require("../detector");
const MAP_ADD_OPERATIONS = new Set(["set"]);
const MAP_DEL_OPERATIONS = new Set(["del"]);
/**
 * An optional detector that highlights cases where a map field allows inserting
 * values (e.g., via `.set`) but lacks functionality for removing entries (e.g., via `.del`).
 *
 * ## Why is it bad?
 * A map without a method to remove elements can lead to storage overflow, particularly
 * in long-term contract usage. Failing to provide a way to clear or delete entries
 * can result in uncontrolled storage growth, which not only wastes resources but
 * may also increase the cost of contract execution and maintenance over time.
 *
 * ## Example
 * ```tact
 * contract Test {
 *     map: Map<Int, String>;
 *
 *     setEntry(key: Int, value: String) {
 *         self.map.set(key, value); // Bad
 *     }
 * }
 * ```
 *
 * Use instead:
 * ```tact
 * contract Test {
 *     map: Map<Int, String>;
 *
 *     setEntry(key: Int, value: String) {
 *         self.map.set(key, value);
 *     }
 *
 *     delEntry(key: Int) {
 *         self.map.del(key); // Fixed: Added a new API method
 *     }
 * }
 * ```
 */
class UnboundMap extends detector_1.AstDetector {
    severity = warnings_1.Severity.LOW;
    category = warnings_1.Category.SECURITY;
    async check(cu) {
        return Array.from(cu.ast.getContracts()).reduce((acc, contract) => acc.concat(this.checkContract(contract)), []);
    }
    checkContract(contract) {
        const mapFields = Array.from((0, tact_1.collectFields)(contract).values()).reduce((acc, field) => {
            if (field.type.kind === "map_type")
                acc.set((0, imports_1.idText)(field.name), field);
            return acc;
        }, new Map());
        const { added, removed } = this.findUses(contract, mapFields);
        return Array.from(added)
            .filter((name) => !removed.has(name))
            .map((notRemovedName) => {
            const decl = mapFields.get(notRemovedName);
            return this.makeWarning(`Map self.${notRemovedName} could be unbound`, decl.loc, {
                extraDescription: "There are operations adding elements to this map, but there is no API to remove them",
                suggestion: "Consider adding a method to remove elements or suppress this warning",
            });
        });
    }
    /**
     * Finds which map fields has the operation adding elements to it (`added`)
     * and to remove them (`removed`).
     */
    findUses(contract, mapFields) {
        return contract.declarations.reduce(({ added, removed }, decl) => {
            (0, tact_1.forEachExpression)(decl, (expr) => {
                if (expr.kind === "method_call" &&
                    expr.self.kind === "field_access" &&
                    (0, tact_1.isSelf)(expr.self.aggregate) &&
                    mapFields.has((0, imports_1.idText)(expr.self.field))) {
                    if (MAP_ADD_OPERATIONS.has((0, imports_1.idText)(expr.method)))
                        added.add((0, imports_1.idText)(expr.self.field));
                    else if (MAP_DEL_OPERATIONS.has((0, imports_1.idText)(expr.method)))
                        removed.add((0, imports_1.idText)(expr.self.field));
                }
            });
            return { added, removed };
        }, { added: new Set(), removed: new Set() });
    }
}
exports.UnboundMap = UnboundMap;
