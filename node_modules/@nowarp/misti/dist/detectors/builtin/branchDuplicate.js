"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BranchDuplicate = void 0;
const tact_1 = require("../../internals/tact");
const warnings_1 = require("../../internals/warnings");
const detector_1 = require("../detector");
/**
 * Detector that reports duplicated code in conditional branches.
 *
 * ## Why is it bad?
 * Duplicated code in branches is bad because it:
 * 1. **Reduces Readability**: Repetition makes the code harder to understand.
 * 2. **Increases Maintenance**: Changes must be made in multiple places, risking errors.
 * 3. **Signals Poor Design**: It suggests missed opportunities for cleaner, more abstract code.
 *
 * ## Example
 * ```tact
 * if (a > 42) {
 *   a = 43; // bad: duplicated code
 * } else {
 *   a = 43;
 * }
 * ```
 *
 * Use instead:
 * ```tact
 * if (a > 42) {
 *   a = inc(b); // ok
 * } else {
 *   a = 43;
 * }
 * ```
 */
class BranchDuplicate extends detector_1.AstDetector {
    severity = warnings_1.Severity.HIGH;
    category = warnings_1.Category.SECURITY;
    async check(cu) {
        return cu.ast.getProgramEntries().reduce((acc, node) => {
            const ternaryWarnings = (0, tact_1.foldExpressions)(node, (acc, expr) => {
                return this.checkTernary(acc, expr);
            }, []);
            const conditionWarnings = (0, tact_1.foldStatements)(node, (acc, stmt) => {
                return this.checkConditional(acc, stmt);
            }, []);
            return acc.concat([...conditionWarnings, ...ternaryWarnings]);
        }, []);
    }
    /**
     * Looks for duplicates in ternary expressions.
     */
    checkTernary(acc, expr) {
        if (expr.kind === "conditional" &&
            (0, tact_1.nodesAreEqual)(expr.thenBranch, expr.elseBranch)) {
            acc.push(this.createWarning(expr.thenBranch.loc, expr.elseBranch.loc));
        }
        return acc;
    }
    /**
     * Checks for duplicated conditions within an if-elseif-else chain.
     * If duplicates are found, a warning is added to the accumulator.
     */
    checkConditional(acc, stmt) {
        if (stmt.kind === "statement_condition") {
            const allBranches = this.collectAllBranches(stmt);
            for (let i = 0; i < allBranches.length; i++) {
                for (let j = i; j < allBranches.length; j++) {
                    const lhs = allBranches[i];
                    const rhs = allBranches[j];
                    if (i != j && (0, tact_1.statementsAreEqual)(lhs, rhs)) {
                        acc.push(this.createWarning(lhs[0].loc, rhs[0].loc));
                        break;
                    }
                }
            }
        }
        return acc;
    }
    collectAllBranches(cond) {
        const branches = [];
        let current = cond;
        while (current !== null) {
            if (current.trueStatements.length > 0) {
                branches.push(current.trueStatements);
            }
            if (current.falseStatements && current.falseStatements.length > 0) {
                if (current.falseStatements.length === 1 &&
                    current.falseStatements[0].kind === "statement_condition") {
                    // else if
                    current = current.falseStatements[0];
                }
                else {
                    // else
                    branches.push(current.falseStatements);
                    current = null;
                }
            }
            else {
                current = null;
            }
        }
        return branches;
    }
    createWarning(loc, dupLoc) {
        return this.makeWarning("Duplicated code in conditional branches is detected", loc, {
            extraDescription: `Identical code block was detected at line ${dupLoc.interval.getLineAndColumn().lineNum}`,
            suggestion: "Consider refactoring to eliminate this duplication",
        });
    }
}
exports.BranchDuplicate = BranchDuplicate;
