"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StateMutationInGetter = void 0;
const callGraph_1 = require("../../internals/ir/callGraph");
const callGraph_2 = require("../../internals/ir/callGraph");
const tact_1 = require("../../internals/tact");
const imports_1 = require("../../internals/tact/imports");
const warnings_1 = require("../../internals/warnings");
const detector_1 = require("../detector");
/**
 * An optional detector that identifies cases where a state-mutating function is called within a getter method.
 *
 * ## Why is it important?
 * While getter methods are generally expected to be pure functions that donâ€™t modify state,
 * they sometimes contain state-modifying logic (directly or indirectly). This can lead to
 * misunderstandings for developers who assume getters are read-only. This detector is intended
 * for auditors to highlight such cases as potential design concerns.
 *
 * ## Example
 * ```tact
 * contract Example {
 *   value: Int = 0;
 *
 *   get fun getValue(): Int {
 *     self.updateCounter(); // Suspicious: calls a function that modifies state
 *     return self.value;
 *   }
 *
 *   fun updateCounter() {
 *     self.value = self.value + 1; // Modifies state
 *   }
 * }
 * ```
 *
 * Use instead:
 * ```tact
 * contract Example {
 *   value: Int = 0;
 *   get fun getValue(): Int {
 *     return self.value; // OK: Pure getter
 *   }
 *
 *   fun getAndIncrement(): Int {
 *     let current = self.value;
 *     self.value = self.value + 1;
 *     return current;
 *   }
 * }
 * ```
 */
class StateMutationInGetter extends detector_1.AstDetector {
    severity = warnings_1.Severity.INFO;
    category = warnings_1.Category.SECURITY;
    async check(cu) {
        const warnings = [];
        for (const contract of cu.ast.getContracts()) {
            for (const decl of contract.declarations) {
                if (decl.kind === "function_def" &&
                    decl.attributes.some((attr) => attr.type === "get")) {
                    this.checkGetterForStateMutations(cu, decl, contract.name.text, warnings);
                }
            }
        }
        return warnings;
    }
    /**
     * Checks if a getter function contains state-mutating function calls or direct mutations
     */
    checkGetterForStateMutations(cu, getter, contractName, warnings) {
        // Direct state mutations
        this.checkDirectStateMutations(getter, warnings);
        // Indirect state mutations through function calls
        (0, tact_1.forEachExpression)(getter, (expr) => {
            if (expr.kind === "static_call") {
                this.checkStaticCall(cu, expr, contractName, warnings);
            }
            else if (expr.kind === "method_call") {
                this.checkMethodCall(cu, expr, contractName, warnings);
            }
        });
    }
    /**
     * Direct state mutations in statements
     */
    checkDirectStateMutations(getter, warnings) {
        (0, tact_1.foldStatements)(getter, (acc, stmt) => {
            const mutations = (0, tact_1.collectMutations)(stmt);
            if (mutations && mutations.mutatedFields.length > 0) {
                acc.push(this.makeWarning("Getter contains direct state mutation logic", stmt.loc, {
                    suggestion: "Consider moving state-modifying logic to a non-getter function for clarity.",
                }));
            }
            return acc;
        }, warnings);
    }
    /**
     * Checks if a static function call might modify state
     */
    checkStaticCall(cu, call, contractName, warnings) {
        const calleeName = (0, imports_1.idText)(call.function);
        const calleeNodeId = cu.callGraph.getNodeIdByName(calleeName);
        if (calleeNodeId !== undefined) {
            const calleeNode = cu.callGraph.getNode(calleeNodeId);
            if (calleeNode && calleeNode.hasEffect(callGraph_1.Effect.StateWrite)) {
                warnings.push(this.makeWarning(`Getter calls state-mutating function: ${calleeName}`, call.loc, {
                    suggestion: "Consider moving state-modifying logic to a non-getter function for clarity.",
                }));
            }
        }
    }
    /**
     * Checks if a method call might modify state
     */
    checkMethodCall(cu, call, contractName, warnings) {
        if ((0, tact_1.isSelf)(call.self)) {
            const methodName = (0, imports_1.idText)(call.method);
            const calleeName = callGraph_2.CallGraph.getFunctionCallName(call, contractName);
            if (calleeName !== undefined) {
                const calleeNodeId = cu.callGraph.getNodeIdByName(calleeName);
                if (calleeNodeId !== undefined) {
                    const calleeNode = cu.callGraph.getNode(calleeNodeId);
                    if (calleeNode && calleeNode.hasEffect(callGraph_1.Effect.StateWrite)) {
                        warnings.push(this.makeWarning(`Getter calls state-mutating method: ${methodName}`, call.loc, {
                            suggestion: "Consider moving state-modifying logic to a non-getter function for clarity.",
                        }));
                    }
                }
            }
        }
    }
}
exports.StateMutationInGetter = StateMutationInGetter;
