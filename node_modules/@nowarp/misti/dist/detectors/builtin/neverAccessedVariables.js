"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NeverAccessedVariables = void 0;
const solver_1 = require("../../internals/solver/");
const tact_1 = require("../../internals/tact");
const imports_1 = require("../../internals/tact/imports");
const util_1 = require("../../internals/util");
const util_2 = require("../../internals/util");
const warnings_1 = require("../../internals/warnings");
const detector_1 = require("../detector");
/**
 * A powerset lattice that keeps state of local variables within control flow.
 */
class VariableUsageLattice {
    bottom() {
        return {
            declared: new tact_1.SrcInfoSet(),
            accessed: new Set(),
            written: new Set(),
        };
    }
    join(a, b) {
        const declared = new tact_1.SrcInfoSet([
            ...a.declared.extract(),
            ...b.declared.extract(),
        ]);
        const accessed = (0, util_1.mergeSets)(a.accessed, b.accessed);
        const written = (0, util_1.mergeSets)(a.written, b.written);
        return { declared, accessed, written };
    }
    leq(a, b) {
        return ([...a.declared.extract()].every((x) => b.declared.has(x)) &&
            (0, util_1.isSetSubsetOf)(a.accessed, b.accessed) &&
            (0, util_1.isSetSubsetOf)(a.written, b.written));
    }
}
class NeverAccessedTransfer {
    transfer(inState, _node, stmt) {
        const outState = {
            declared: inState.declared,
            accessed: inState.accessed,
            written: inState.written,
        };
        this.processStatements(outState, stmt);
        return outState;
    }
    processStatements(outState, stmt) {
        const trackAccess = (node) => {
            (0, tact_1.forEachExpression)(node, (expr) => {
                if (expr.kind === "id") {
                    outState.accessed.add((0, imports_1.idText)(expr));
                }
            });
        };
        switch (stmt.kind) {
            case "statement_let":
                outState.declared.add([stmt.name.text, stmt.loc]);
                trackAccess(stmt.expression);
                break;
            case "statement_destruct":
                for (const [, ids] of stmt.identifiers) {
                    outState.declared.add([(0, imports_1.idText)(ids[1]), stmt.loc]);
                }
                trackAccess(stmt.expression);
                break;
            case "statement_return":
                if (stmt.expression)
                    trackAccess(stmt.expression);
                break;
            case "statement_expression":
                trackAccess(stmt.expression);
                break;
            case "statement_assign":
            case "statement_augmentedassign":
                const name = (0, tact_1.extractPath)(stmt.path);
                outState.written.add(name);
                trackAccess(stmt.expression);
                break;
            case "statement_condition":
                trackAccess(stmt.condition);
                stmt.trueStatements.forEach((s) => this.processStatements(outState, s));
                if (stmt.falseStatements !== undefined)
                    stmt.falseStatements.forEach((s) => this.processStatements(outState, s));
                break;
            case "statement_while":
            case "statement_until":
                trackAccess(stmt.condition);
                stmt.statements.forEach((s) => this.processStatements(outState, s));
                break;
            case "statement_repeat":
                trackAccess(stmt.iterations);
                stmt.statements.forEach((s) => this.processStatements(outState, s));
                break;
            case "statement_try":
                stmt.statements.forEach((s) => this.processStatements(outState, s));
                if (stmt.catchBlock) {
                    stmt.catchBlock.catchStatements.forEach((s) => this.processStatements(outState, s));
                }
                break;
            case "statement_foreach":
                trackAccess(stmt.map);
                stmt.statements.forEach((s) => this.processStatements(outState, s));
                break;
            case "statement_block":
                // TODO: https://github.com/nowarp/misti/issues/41
                break;
            default:
                (0, util_2.unreachable)(stmt);
        }
    }
}
/**
 * A detector that identifies write-only or unused variables, fields and constants.
 *
 * ## Why is it bad?
 * These variables are either assigned but never used in any meaningful computation,
 * or they are declared and never used at all, which may indicate redundant code
 * or an incomplete implementation of the intended logic.
 *
 * ## Example
 * ```tact
 * // Error: the developer forgot to use the constant
 * const MAX_SUPPLY: Int = 1000;
 *
 * fun mint(to: Address, amount: Int) {
 *   balances.set(to, balances.get(to)!! + amount);
 *   totalSupply += amount;
 * }
 * ```
 *
 * Use instead:
 * ```tact
 * const MAX_SUPPLY: Int = 1000;
 *
 * fun mint(to: Address, amount: Int) {
 *   // OK: Fixed after the analyzer highlighted this warning
 *   require(totalSupply + amount <= MAX_SUPPLY, "Exceeds max supply");
 *   balances.set(to, balances.get(to)!! + amount);
 *   totalSupply += amount;
 * }
 * ```
 */
class NeverAccessedVariables extends detector_1.DataflowDetector {
    severity = warnings_1.Severity.MEDIUM;
    category = warnings_1.Category.SECURITY;
    async check(cu) {
        return [
            ...this.checkFields(cu),
            ...this.checkConstants(cu),
            ...this.checkVariables(cu),
        ];
    }
    get shareImportedWarnings() {
        // Never accessed constants/fields from imported files will be reported iff
        // they are reported in each of the projects (CompilationUnit).
        return "intersect";
    }
    checkFields(cu) {
        const defined = this.collectDefinedFields(cu);
        const used = this.collectUsedFields(cu);
        return Array.from(new Set([...defined].filter(([name, _ref]) => !used.has(name)))).reduce((acc, [name, ref]) => {
            if (this.skipUnused(name)) {
                return acc;
            }
            const err = this.makeWarning(`Field ${name} is never used`, ref, {
                suggestion: "Consider removing the field",
            });
            acc.push(err);
            return acc;
        }, []);
    }
    collectDefinedFields(cu) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const getFields = (declarations) => declarations
            .filter((decl) => decl.kind === "field_decl")
            .map((decl) => [decl.name.text, decl.loc]);
        return Array.from(cu.ast.getContracts()).reduce((acc, contract) => {
            const contractFields = getFields(contract.declarations);
            acc = new Set([...acc, ...contractFields]);
            this.forEachTrait(this.ctx, cu, contract.traits, (trait) => {
                const traitFields = getFields(trait.declarations);
                acc = new Set([...acc, ...traitFields]);
            });
            return acc;
        }, new Set());
    }
    /**
     * Executes `callback` for each trait available within the compilation unit `cu`.
     */
    forEachTrait(ctx, cu, traitIds, callback, visited = new Set()) {
        traitIds.forEach((traitId) => {
            const traitName = traitId.text;
            const trait = cu.ast.findTrait(traitName);
            if (trait === undefined) {
                ctx.logger.error(`Cannot access trait ${traitName}`);
                return;
            }
            if (visited.has(trait.id))
                return;
            visited.add(trait.id);
            callback(trait);
            this.forEachTrait(ctx, cu, trait.traits, callback, visited);
        });
    }
    collectUsedFields(cu) {
        const processExpressions = (fun, acc) => {
            (0, tact_1.forEachExpression)(fun, (expr) => {
                if (expr.kind === "field_access" &&
                    expr.aggregate.kind === "id" &&
                    (0, imports_1.isSelfId)(expr.aggregate)) {
                    acc.add(expr.field.text);
                }
            });
            return acc;
        };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const processDeclarations = (declarations, acc) => {
            declarations.forEach((decl) => {
                if (decl.kind === "function_def" ||
                    decl.kind === "receiver" ||
                    decl.kind === "contract_init") {
                    acc = processExpressions(decl, acc);
                }
            });
            return acc;
        };
        return Array.from(cu.ast.getContracts()).reduce((acc, contract) => {
            acc = processDeclarations(contract.declarations, acc);
            this.forEachTrait(this.ctx, cu, contract.traits, (trait) => {
                acc = processDeclarations(trait.declarations, acc);
            });
            return acc;
        }, new Set());
    }
    checkConstants(cu) {
        const definedConstants = this.collectDefinedConstants(cu);
        const usedConstants = this.collectUsedNames(cu);
        return Array.from(new Set([...definedConstants].filter(([name, _ref]) => !usedConstants.has(name)))).reduce((acc, [name, ref]) => {
            if (this.skipUnused(name)) {
                return acc;
            }
            const err = this.makeWarning(`Constant ${name} is never used`, ref, {
                suggestion: "Consider removing the constant",
            });
            acc.push(err);
            return acc;
        }, []);
    }
    collectDefinedConstants(cu) {
        return Array.from(cu.ast.getConstants({ includeContract: false })).reduce((acc, constant) => {
            acc.add([constant.name.text, constant.loc]);
            return acc;
        }, new Set());
    }
    /**
     * Collects all the identifiers using withing all the statements.
     */
    collectUsedNames(cu) {
        return Array.from(cu.ast.getStatements()).reduce((acc, stmt) => {
            (0, tact_1.forEachExpression)(stmt, (expr) => {
                if (expr.kind === "id") {
                    acc.add(expr.text);
                }
            });
            return acc;
        }, new Set());
    }
    /**
     * Checks never accessed local variables in all the functions leveraging the
     * monotonic framework and the fixpoint dataflow solver.
     */
    checkVariables(cu) {
        const warnings = [];
        const traversedFunctions = new Set();
        cu.forEachCFG((cfg) => {
            if (cfg.origin === "stdlib" || traversedFunctions.has(cfg.name)) {
                return;
            }
            traversedFunctions.add(cfg.name);
            const lattice = new VariableUsageLattice();
            const transfer = new NeverAccessedTransfer();
            const solver = new solver_1.WorklistSolver(cu, cfg, transfer, lattice, "forward");
            const results = solver.solve();
            const declaredVariables = new Map();
            const accessedVariables = new Set();
            const writtenVariables = new Set();
            results.getStates().forEach((state, nodeIdx) => {
                if (!cfg.getBasicBlock(nodeIdx).isExit()) {
                    return;
                }
                state.declared
                    .extract()
                    .forEach(([name, ref]) => declaredVariables.set(name, ref));
                state.accessed.forEach((name) => accessedVariables.add(name));
                state.written.forEach((name) => writtenVariables.add(name));
            });
            Array.from(declaredVariables.keys()).forEach((name) => {
                if (this.skipUnused(name)) {
                    return;
                }
                const isWritten = writtenVariables.has(name);
                const isAccessed = accessedVariables.has(name);
                if (!isAccessed) {
                    const msg = isWritten
                        ? `Write-only variable: ${name}`
                        : `Variable ${name} is never accessed`;
                    const suggestion = isWritten
                        ? "The variable value should be accessed"
                        : "Consider removing the variable";
                    warnings.push(this.makeWarning(msg, declaredVariables.get(name), {
                        suggestion,
                    }));
                }
            });
        });
        return warnings;
    }
}
exports.NeverAccessedVariables = NeverAccessedVariables;
