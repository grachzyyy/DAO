"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FieldDoubleInit = void 0;
const tact_1 = require("../../internals/tact");
const warnings_1 = require("../../internals/warnings");
const detector_1 = require("../detector");
/**
 * A detector that highlights cases where a field is initialized both in the
 * `init` function and at the point of definition.
 *
 * ## Why is it bad?
 * Double initialization of fields can either be a programmer's mistake or simply
 * a waste of gas. It is always preferred to initialize values in the field declaration
 * if they have a compile-time evaluatable default value, or in the `init` function if
 * they must be initialized dynamically.
 *
 * ## Example
 * ```tact
 * contract Test {
 *     a: Int = 0; // Bad
 *     init(x: Int) { self.a = x }
 * }
 * ```
 *
 * Use instead:
 * ```tact
 * contract Test {
 *     a: Int; // Fixed
 *     init(x: Int) { self.a = x }
 * }
 * ```
 */
class FieldDoubleInit extends detector_1.AstDetector {
    severity = warnings_1.Severity.MEDIUM;
    category = warnings_1.Category.OPTIMIZATION;
    async check(cu) {
        return Array.from(cu.ast.getContracts()).reduce((acc, contract) => acc.concat(this.checkContract(contract)), []);
    }
    /**
     * Looks for double-initialized fields in the given contract.
     */
    checkContract(contract) {
        const init = contract.declarations.find((decl) => decl.kind === "contract_init");
        if (init === undefined) {
            return [];
        }
        // Fields initialized in their declarations.
        const initializedInDecl = new Set((0, tact_1.collectFields)(contract, {
            initialized: true,
        }).keys());
        if (initializedInDecl.size === 0) {
            return [];
        }
        // Check if they are used in `init`.
        return init.statements.reduce((acc, stmt) => {
            if (stmt.kind === "statement_assign" &&
                stmt.path.kind === "field_access" &&
                stmt.path.aggregate.kind === "id" &&
                stmt.path.aggregate.text === "self" &&
                initializedInDecl.has(stmt.path.field.text)) {
                acc.push(this.makeWarning(`Field ${stmt.path.field.text} is initialized twice`, stmt.loc, {
                    suggestion: "Consider initializing the field only in its declaration or in the `init` function",
                }));
            }
            return acc;
        }, []);
    }
}
exports.FieldDoubleInit = FieldDoubleInit;
