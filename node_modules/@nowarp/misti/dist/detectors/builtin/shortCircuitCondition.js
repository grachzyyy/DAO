"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShortCircuitCondition = void 0;
const tact_1 = require("../../internals/tact");
const imports_1 = require("../../internals/tact/imports");
const warnings_1 = require("../../internals/warnings");
const detector_1 = require("../detector");
/**
 * A detector that suggests optimizing boolean expressions to leverage short-circuit evaluation.
 *
 * ## Why is it bad?
 * TVM supports short-circuit operations. When using logical AND (`&&`) or logical OR (`||`) operations,
 * placing constant or cheaper conditions first can prevent unnecessary execution
 * of expensive operations when the result is already determined.
 *
 * ## Example
 * ```tact
 * // Bad: Expensive operation is always executed
 * if (expensive_function() && constant_false) {
 *   // ...
 * }
 * ```
 *
 * Use instead:
 * ```tact
 * // Good: Expensive operation is skipped when constant_false is false
 * if (constant_false && expensive_function()) {
 *   // ...
 * }
 * ```
 */
class ShortCircuitCondition extends detector_1.AstDetector {
    severity = warnings_1.Severity.LOW;
    category = warnings_1.Category.OPTIMIZATION;
    async check(cu) {
        return Array.from(cu.ast.getFunctions()).reduce((acc, fun) => acc.concat(this.checkFunction(fun)), []);
    }
    checkFunction(fun) {
        return (0, tact_1.foldStatements)(fun, (acc, stmt) => {
            (0, tact_1.forEachExpression)(stmt, (expr) => {
                if (expr.kind === "op_binary" &&
                    (expr.op === "&&" || expr.op === "||")) {
                    const leftExpensive = this.containsExpensiveCall(expr.left);
                    const rightExpensive = this.containsExpensiveCall(expr.right);
                    const leftIsConstant = this.isConstantExpression(expr.left);
                    const rightIsConstant = this.isConstantExpression(expr.right);
                    if (leftExpensive &&
                        !rightExpensive &&
                        !this.containsInitOf(expr.right)) {
                        acc.push(this.makeWarning(`Consider reordering: Move expensive function call to the end`, expr.loc, {
                            suggestion: `Place cheaper conditions on the left to leverage short-circuiting: ${(0, imports_1.prettyPrint)(expr.right)} ${expr.op} ${(0, imports_1.prettyPrint)(expr.left)}`,
                        }));
                    }
                    if (!leftIsConstant &&
                        rightIsConstant &&
                        !this.containsInitOf(expr.left)) {
                        acc.push(this.makeWarning(`Consider reordering: Move constant to the left`, expr.loc, {
                            suggestion: `Reorder to optimize ${expr.op} condition short-circuiting: ${(0, imports_1.prettyPrint)(expr.right)} ${expr.op} ${(0, imports_1.prettyPrint)(expr.left)}`,
                        }));
                    }
                }
            });
            return acc;
        }, []);
    }
    containsExpensiveCall(expr) {
        if (!expr)
            return false;
        return ((0, tact_1.findInExpressions)(expr, (e) => (e.kind === "method_call" || e.kind === "static_call") &&
            !this.containsInitOf(e)) !== null);
    }
    isConstantExpression(expr) {
        if (!expr)
            return false;
        return ((0, tact_1.evalsToLiteral)(expr, tact_1.MakeLiteral.boolean(true)) ||
            (0, tact_1.evalsToLiteral)(expr, tact_1.MakeLiteral.boolean(false)) ||
            expr.kind === "boolean" ||
            expr.kind === "number" ||
            expr.kind === "string" ||
            expr.kind === "null");
    }
    containsInitOf(expr) {
        if (!expr)
            return false;
        return (0, tact_1.findInExpressions)(expr, (e) => e.kind === "init_of") !== null;
    }
}
exports.ShortCircuitCondition = ShortCircuitCondition;
