"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EtaLikeSimplifications = void 0;
const quickfix_1 = require("../../internals/quickfix");
const tact_1 = require("../../internals/tact");
const tact_2 = require("../../internals/tact/");
const imports_1 = require("../../internals/tact/imports");
const warnings_1 = require("../../internals/warnings");
const detector_1 = require("../detector");
/**
 * Detects opportunities for simplifying code by eliminating redundant boolean expressions and statements.
 *
 * ## Why is it bad?
 * Redundant code can make programs less efficient and harder to read. Simplifying such code improves readability,
 * maintainability, and can prevent potential logical errors.
 *
 * **What it checks:**
 * - `if` statements that return boolean literals directly based on a condition.
 * - Comparisons of boolean expressions with boolean literals (`true` or `false`).
 * - Conditional expressions (ternary operators) that return boolean literals.
 *
 * ## Example
 *
 * ```tact
 * // Redundant 'if' statement:
 * if (condition) {
 *     return true;
 * } else {
 *     return false;
 * }
 * // Simplify to:
 * return condition;
 *
 * // Redundant comparison:
 * return a == true;
 * // Simplify to:
 * return a;
 *
 * // Redundant conditional expression:
 * return b ? true : false;
 * // Simplify to:
 * return b;
 * ```
 */
class EtaLikeSimplifications extends detector_1.AstDetector {
    severity = warnings_1.Severity.LOW;
    category = warnings_1.Category.OPTIMIZATION;
    async check(cu) {
        const warnings = [];
        const entries = cu.ast.getProgramEntries();
        for (const node of entries) {
            this.analyzeNode(node, warnings);
        }
        return warnings;
    }
    analyzeNode(node, warnings) {
        (0, tact_1.forEachStatement)(node, (stmt) => {
            this.checkStatement(stmt, warnings);
        });
        (0, tact_1.forEachExpression)(node, (expr) => {
            this.checkExpression(expr, warnings);
        });
    }
    checkStatement(stmt, warnings) {
        if (stmt.kind === "statement_condition" &&
            stmt.trueStatements.length === 1 &&
            stmt.falseStatements &&
            stmt.falseStatements.length === 1 &&
            stmt.trueStatements[0].kind === "statement_return" &&
            stmt.falseStatements[0].kind === "statement_return" &&
            this.isBooleanLiteral(stmt.trueStatements[0].expression, true) &&
            this.isBooleanLiteral(stmt.falseStatements[0].expression, false)) {
            const desc = "Return the condition directly";
            warnings.push(this.makeWarning(desc, stmt.loc, {
                quickfixes: [
                    (0, quickfix_1.makeReplace)(desc, true, (0, quickfix_1.makeReplacement)((0, quickfix_1.makeRange)(stmt.loc), `return ${(0, imports_1.prettyPrint)(stmt.condition)};`)),
                ],
            }));
        }
    }
    checkExpression(expr, warnings) {
        if (expr.kind === "op_binary") {
            const binaryExpr = expr;
            if (binaryExpr.op === "==" || binaryExpr.op === "!=") {
                const { right } = binaryExpr;
                if (this.isBooleanLiteral(right)) {
                    const simplified = this.getSimplifiedBooleanExpression(binaryExpr);
                    warnings.push(this.makeWarning("Redundant comparison with boolean literal", expr.loc, {
                        suggestion: (0, imports_1.prettyPrint)(simplified),
                    }));
                }
            }
        }
        if (expr.kind === "conditional") {
            if (this.isBooleanLiteral(expr.thenBranch, true) &&
                this.isBooleanLiteral(expr.elseBranch, false)) {
                warnings.push(this.makeWarning("Simplify conditional expression by using the condition directly", expr.loc, {
                    suggestion: (0, imports_1.prettyPrint)(expr.condition),
                }));
            }
        }
    }
    isBooleanLiteral(expr, value) {
        if (expr == undefined)
            return false;
        return value === undefined
            ? (0, tact_2.evalToType)(expr, "boolean") !== undefined
            : (0, tact_2.evalsToLiteral)(expr, tact_1.MakeLiteral.boolean(value));
    }
    getSimplifiedBooleanExpression(binaryExpr) {
        const negated = binaryExpr.op === "!=";
        if (this.isBooleanLiteral(binaryExpr.right, true)) {
            return negated
                ? {
                    kind: "op_unary",
                    op: "!",
                    operand: binaryExpr.left,
                    id: binaryExpr.id,
                    loc: binaryExpr.loc,
                }
                : binaryExpr.left;
        }
        else if (this.isBooleanLiteral(binaryExpr.right, false)) {
            return negated
                ? binaryExpr.left
                : {
                    kind: "op_unary",
                    op: "!",
                    operand: binaryExpr.left,
                    id: binaryExpr.id,
                    loc: binaryExpr.loc,
                };
        }
        return binaryExpr;
    }
}
exports.EtaLikeSimplifications = EtaLikeSimplifications;
