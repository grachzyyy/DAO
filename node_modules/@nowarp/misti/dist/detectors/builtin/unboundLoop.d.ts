import { CompilationUnit } from "../../internals/ir";
import { Category, Warning, Severity } from "../../internals/warnings";
import { SouffleDetector } from "../detector";
/**
 * A detector that analyzes loop conditions and control flow to ensure loops have proper termination criteria.
 *
 * ## Why is it bad?
 * An unbounded loop can be problematic for several reasons:
 * * **Unexpected Behavior:** Without a defined termination, loops can lead to unpredictable contract behavior and make debugging difficult.
 * * **Out-of-gas Attacks:** Continuous looping without termination can lead to out-of-gas attacks.
 * * **DoS Attacks:** Malicious actors can exploit unbounded loops to create denial-of-service attacks, impacting contract's availability.
 *
 * ## Example
 * ```tact
 * let x: Int = 10;
 * while (x > 0) {
 *   // Bad: x is not changed due looping
 *   send(SendParameters{ to: sender(), ... });
 * }
 * ```
 *
 * Use instead:
 * ```tact
 * let x: Int = 10;
 * while (x > 0) {
 *   send(SendParameters{ to: sender(), ... });
 *   x = x - 1;
 * }
 * ```
 */
export declare class UnboundLoop extends SouffleDetector {
    severity: Severity;
    category: Category;
    check(cu: CompilationUnit): Promise<Warning[]>;
    private addDecls;
    private addRules;
    /**
     * Generates Souffle facts for constant definitions which should not be reported if used in the loop.
     */
    private addConstantConstraints;
    /**
     * Collects facts based on the IR to populate the Souffle program.
     * @param cu The compilation unit containing the CFGs and AST information.
     * @param ctx The Souffle program to which the facts are added.
     */
    private addConstraints;
}
