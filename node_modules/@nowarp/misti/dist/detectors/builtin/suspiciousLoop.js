"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SuspiciousLoop = void 0;
const tact_1 = require("../../internals/tact");
const warnings_1 = require("../../internals/warnings");
const detector_1 = require("../detector");
/**
 * An optional detector that identifies potentially problematic loops, such as those
 * with unbounded conditions or excessive iteration counts.
 *
 * ## Why is it bad?
 * Loops with always-true conditions or massive iteration limits can lead to high
 * gas consumption and even denial of service (DoS) issues. By flagging these loops,
 * this detector aids auditors in catching potential performance or security risks.
 *
 * ## Example
 * ```tact
 * repeat (10_001) { // Bad: High iteration count
 *     // ...
 * }
 *
 * while (true) { // Bad: Unbounded condition
 *     // ...
 * }
 * ```
 */
class SuspiciousLoop extends detector_1.AstDetector {
    severity = warnings_1.Severity.MEDIUM;
    category = warnings_1.Category.SECURITY;
    async check(cu) {
        return Array.from(cu.ast.getProgramEntries()).reduce((acc, node) => {
            return acc.concat(...(0, tact_1.foldStatements)(node, (acc, stmt) => {
                return acc.concat(this.analyzeLoopStatement(stmt));
            }, acc));
        }, []);
    }
    /**
     * Analyzes a loop statement to determine if it contains a suspicious condition.
     */
    analyzeLoopStatement(stmt) {
        if (stmt.kind === "statement_repeat" &&
            (0, tact_1.evalsToPredicate)(stmt.iterations, (v) => v && "kind" in v && v.kind === "number" && v.value > 10000n)) {
            return [
                this.makeWarning("Potential high-cost loop", stmt.iterations.loc, {
                    suggestion: "Avoid excessive iterations in loops",
                }),
            ];
        }
        if (stmt.kind === "statement_while") {
            let warnings = [];
            warnings = warnings.concat(this.checkTrueCondition(stmt.condition));
            if (warnings.length === 0 && stmt.statements.length > 0) {
                warnings = warnings.concat(this.checkFalseCondition(stmt.condition));
            }
            return warnings;
        }
        if (stmt.kind === "statement_until") {
            let warnings = [];
            warnings = warnings.concat(this.checkTrueCondition(stmt.condition));
            return warnings;
        }
        return [];
    }
    checkFalseCondition(expr) {
        if ((0, tact_1.evalsToLiteral)(expr, tact_1.MakeLiteral.boolean(false))) {
            return [
                this.makeWarning("Loop condition is always false", expr.loc, {
                    suggestion: "The condition is always false; the body will never execute",
                }),
            ];
        }
        return [];
    }
    checkTrueCondition(expr) {
        return (0, tact_1.evalsToLiteral)(expr, tact_1.MakeLiteral.boolean(true))
            ? [
                this.makeWarning("Infinite loop detected", expr.loc, {
                    suggestion: "Avoid unbounded conditions in loops",
                }),
            ]
            : [];
    }
}
exports.SuspiciousLoop = SuspiciousLoop;
