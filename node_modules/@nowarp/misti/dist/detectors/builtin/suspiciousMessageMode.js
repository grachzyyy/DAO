"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SuspiciousMessageMode = void 0;
const tact_1 = require("../../internals/tact");
const imports_1 = require("../../internals/tact/imports");
const warnings_1 = require("../../internals/warnings");
const detector_1 = require("../detector");
/**
 * Detects suspicious usage of the `mode` field in `SendParameters` struct instances.
 *
 * ## Why is it bad?
 * Incorrect usage of the `mode` field in `SendParameters` can lead to unintended behavior when sending messages,
 * such as incorrect flags being set, which can cause security vulnerabilities or unexpected contract behavior.
 *
 * **What it checks:**
 * - Ensures that the `mode` expression only uses the bitwise OR operator `|`.
 * - Warns if integer literals are used instead of symbolic constants.
 * - Warns if the same flag is used multiple times in the `mode` expression.
 *
 * ## Example
 *
 * ```tact
 * // Suspicious usage:
 * send(SendParameters{
 *     to: recipient,
 *     value: amount,
 *     mode: SendRemainingBalance | SendRemainingBalance // Bad: Duplicate flag
 * });
 *
 * // Correct usage:
 * send(SendParameters{
 *     to: recipient,
 *     value: amount,
 *     mode: SendRemainingBalance | SendDestroyIfZero // Ok
 * });
 * ```
 */
class SuspiciousMessageMode extends detector_1.AstDetector {
    severity = { min: warnings_1.Severity.LOW, max: warnings_1.Severity.MEDIUM };
    category = warnings_1.Category.SECURITY;
    async check(cu) {
        const warnings = [];
        Array.from(cu.ast.getProgramEntries()).forEach((node) => {
            (0, tact_1.forEachExpression)(node, (expr) => {
                if (expr.kind === "struct_instance" &&
                    (0, imports_1.idText)(expr.type) === "SendParameters") {
                    this.checkSendParameters(expr, warnings);
                }
            });
        });
        return warnings;
    }
    checkSendParameters(expr, warnings) {
        const args = expr.args;
        const modeField = args.find((arg) => (0, imports_1.idText)(arg.field) === "mode");
        if (modeField) {
            this.checkModeExpression(modeField.initializer, warnings);
        }
    }
    checkModeExpression(expr, warnings) {
        if (expr.kind === "number" && expr.value === 0n) {
            warnings.push(this.makeWarning("Setting `mode` to `0` is redundant as it has no effect", expr.loc, {
                severity: warnings_1.Severity.LOW,
                suggestion: "Use `SendDefaultMode` instead of `0`, or remove the `mode` field",
            }));
            return;
        }
        const flagsUsed = new Set();
        (0, tact_1.forEachExpression)(expr, (e) => {
            switch (e.kind) {
                case "op_binary":
                    const opBinary = e;
                    if (opBinary.op === "+") {
                        warnings.push(this.makeWarning("The `+` operator in mode expressions is deprecated", e.loc, {
                            severity: warnings_1.Severity.LOW,
                            suggestion: "Use the `|` operator (bitwise OR) to combine flags",
                        }));
                    }
                    else if (opBinary.op !== "|") {
                        warnings.push(this.makeWarning("Mode expression should only contain the `|` operator", e.loc, {
                            severity: warnings_1.Severity.MEDIUM,
                            suggestion: "Use the `|` operator (bitwise OR) to combine flags",
                        }));
                    }
                    break;
                case "id":
                    const flagName = (0, imports_1.idText)(e);
                    if (flagsUsed.has(flagName)) {
                        warnings.push(this.makeWarning(`Flag \`${flagName}\` is used multiple times in the \`mode\` expression`, e.loc, {
                            severity: warnings_1.Severity.MEDIUM,
                            suggestion: "Use each flag at most once in the mode expression",
                        }));
                    }
                    flagsUsed.add(flagName);
                    break;
                case "number":
                    let suggestion = `Replace integer literal \`${e.value}\` with symbolic flag constants`;
                    if (e.value === 64n) {
                        suggestion = "Replace `64` with `SendRemainingValue`";
                    }
                    else if (e.value === 128n) {
                        suggestion = "Replace `128` with `SendRemainingBalance`";
                    }
                    warnings.push(this.makeWarning("Integer literals should not be used in mode expression", e.loc, {
                        severity: warnings_1.Severity.MEDIUM,
                        suggestion,
                    }));
                    break;
                default:
                    break;
            }
        });
    }
}
exports.SuspiciousMessageMode = SuspiciousMessageMode;
