"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImplicitOpcode = void 0;
const warnings_1 = require("../../internals/warnings");
const detector_1 = require("../detector");
const compiler_1 = require("@tact-lang/compiler");
/**
 * An optional detector that highlights messages with implicitly defined opcode.
 *
 * ## Why is it bad?
 * Tact automatically generates these unique IDs (opcodes) for every received
 * message, but developers can specify a message opcode explicitly. This enables
 * handling of specific opcodes in the receiver explicitly, which may be
 * convenient when interacting with FunC contracts.
 *
 * See:
 * * https://docs.tact-lang.org/book/structs-and-messages/#message-opcodes
 *
 * ## Example
 * ```tact
 * message TokenNotification {
 *   forwardPayload: Slice as remaining;
 * }
 * ```
 *
 * Use instead:
 * ```tact
 * message(0x7362d09c) TokenNotification {
 *   forwardPayload: Slice as remaining;
 * }
 * ```
 */
class ImplicitOpcode extends detector_1.AstDetector {
    severity = warnings_1.Severity.INFO;
    category = warnings_1.Category.BEST_PRACTICES;
    async check(cu) {
        return Array.from(cu.ast.getMessages()).reduce((acc, msg) => {
            if (msg.kind === "message_decl" && msg.opcode === undefined) {
                acc.push(this.makeWarning(`Message \`${(0, compiler_1.idText)(msg.name)}\` has an implicit opcode`, msg.loc, {
                    suggestion: "Prefer explicitly defined message opcodes",
                }));
            }
            return acc;
        }, []);
    }
}
exports.ImplicitOpcode = ImplicitOpcode;
