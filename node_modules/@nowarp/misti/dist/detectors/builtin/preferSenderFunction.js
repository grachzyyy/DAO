"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PreferSenderFunction = void 0;
const solver_1 = require("../../internals/solver");
const tact_1 = require("../../internals/tact");
const imports_1 = require("../../internals/tact/imports");
const util_1 = require("../../internals/util");
const warnings_1 = require("../../internals/warnings");
const detector_1 = require("../detector");
class ContextVariablesLattice {
    bottom() {
        return {
            vars: new Map(),
        };
    }
    join(a, b) {
        const vars = (0, util_1.mergeMaps)(a.vars, b.vars);
        return {
            vars,
        };
    }
    leq(a, b) {
        return (0, util_1.isMapSubsetOf)(a.vars, b.vars);
    }
}
class ContextVariablesTransfer {
    transfer(inState, _node, stmt) {
        const outState = {
            // The Set values of maps *won't* be copied and are mutating across
            // transfer function invocations. That's the expected behavior, as we
            // need to have all the usage information at the point of definition of
            // the context variable.
            vars: inState.vars,
        };
        this.processLetStatement(outState, stmt);
        this.processContextAccess(outState, stmt);
        return outState;
    }
    findContextVariable(state, expr) {
        if (expr.kind === "id") {
            const varName = (0, imports_1.idText)(expr);
            return state.vars.has(varName) ? varName : undefined;
        }
        else {
            const result = (0, tact_1.findInExpressions)(expr, (e) => e.kind === "id" && state.vars.has((0, imports_1.idText)(e)));
            return result ? (0, imports_1.idText)(result) : undefined;
        }
    }
    processContextAccess(state, stmt) {
        (0, tact_1.forEachExpression)(stmt, (e) => {
            if (e.kind === "method_call") {
                const chain = (0, tact_1.getMethodCallsChain)(e);
                if (chain && chain.self.kind === "id") {
                    const cv = this.findContextVariable(state, chain.self);
                    if (cv) {
                        chain.calls.forEach((c) => {
                            const methods = state.vars.get(cv) || new Set();
                            methods.add((0, imports_1.idText)(c.method));
                            state.vars.set(cv, methods);
                        });
                    }
                }
            }
            else if (e.kind === "field_access" && e.aggregate.kind === "id") {
                const cv = this.findContextVariable(state, e.aggregate);
                if (cv) {
                    // We support only `ctx.field` here; skipping `ctx.field1.field2` as
                    // it is impossible.
                    const fields = state.vars.get(cv) || new Set();
                    fields.add((0, imports_1.idText)(e.field));
                    state.vars.set(cv, fields);
                }
            }
        });
    }
    processLetStatement(outState, stmt) {
        if (stmt.kind === "statement_let") {
            if (stmt.expression.kind === "static_call" &&
                (0, imports_1.idText)(stmt.expression.function) === "context") {
                // New variable: `let a = context();`
                outState.vars.set((0, imports_1.idText)(stmt.name), new Set());
            }
            else if (stmt.expression.kind !== "method_call" &&
                stmt.expression.kind !== "field_access") {
                // Taint assignment: `let a = context(); let b = a;`
                const taint = this.findContextVariable(outState, stmt.expression);
                if (taint) {
                    outState.vars.set((0, imports_1.idText)(stmt.name), new Set(outState.vars.get(taint)));
                }
            }
        }
    }
}
/**
 * A detector that finds `context().sender` calls that could be replaced with
 * more gas-effective `sender()` call.
 *
 * ## Why is it bad?
 * You can obtain the address of the message sender using either the `Context`
 * struct or the `sender` function. If you only need the address and no
 * additional context on the incoming message , you should prefer less
 * gas-expensive `sender()`.
 *
 * See: https://docs.tact-lang.org/book/gas-best-practices/#use-sender-over-contextsender
 *
 * ## Example
 * ```tact
 * let ctx = context(); // Bad: only .sender is accessed
 * message(MessageParameters{
 *   to: ctx.sender,
 *   value: ton("0.05"),
 * });
 * ```
 *
 * Use instead:
 * ```tact
 * message(MessageParameters{
 *   to: sender(),
 *   value: ton("0.05"),
 * });
 * ```
 */
class PreferSenderFunction extends detector_1.DataflowDetector {
    severity = warnings_1.Severity.LOW;
    category = warnings_1.Category.OPTIMIZATION;
    async check(cu) {
        const warnings = [];
        cu.forEachCFG((cfg) => {
            const node = cu.ast.getFunction(cfg.id);
            if (node === undefined) {
                return;
            }
            warnings.push(...this.findDirectContextSender(node));
            warnings.push(...this.findUnusedContext(cu, cfg));
        }, { includeStdlib: false });
        return warnings;
    }
    /**
     * Warns about direct uses of `context().sender`.
     */
    findDirectContextSender(node) {
        const isContextSender = (expr) => expr.kind === "field_access" &&
            expr.aggregate.kind === "static_call" &&
            (0, imports_1.idText)(expr.aggregate.function) === "context" &&
            expr.field.kind === "id" &&
            (0, imports_1.idText)(expr.field) === "sender";
        return (0, tact_1.foldExpressions)(node, (acc, expr) => {
            if (isContextSender(expr)) {
                acc.push(this.makeWarning("Using gas-expensive `context().sender`", expr.loc, {
                    suggestion: "Consider replacing it with less gas-expensive `sender()` call",
                }));
            }
            return acc;
        }, []);
    }
    /**
     * Warns about local variables assigned to `context()` when only `.sender`
     * is accessed.
     */
    findUnusedContext(cu, cfg) {
        const warnings = [];
        const lattice = new ContextVariablesLattice();
        const transfer = new ContextVariablesTransfer();
        const solver = new solver_1.WorklistSolver(cu, cfg, transfer, lattice, "forward");
        const results = solver.solve();
        cfg.forEachBasicBlock(cu.ast, (stmt, bb) => {
            if (stmt.kind !== "statement_let")
                return;
            const state = results.getState(bb.idx);
            if (state === undefined) {
                this.ctx.logger.warn(`${this.id}: Cannot find BB #${bb.idx}`);
                return;
            }
            const definedVar = (0, imports_1.idText)(stmt.name);
            const cv = state.vars.get(definedVar);
            if (cv && cv.size === 1 && cv.has("sender")) {
                warnings.push(this.makeWarning("Code can be optimized by using `sender()` instead of accessing context", stmt.name.loc, {
                    extraDescription: `The \`${definedVar}\` variable is only used to get the sender`,
                    suggestion: `Consider replacing \`${definedVar}.sender\` with the less gas-expensive \`sender()\` call`,
                }));
            }
        });
        return warnings;
    }
}
exports.PreferSenderFunction = PreferSenderFunction;
