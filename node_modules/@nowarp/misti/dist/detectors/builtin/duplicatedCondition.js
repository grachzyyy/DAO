"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DuplicatedCondition = void 0;
const tact_1 = require("../../internals/tact");
const imports_1 = require("../../internals/tact/imports");
const warnings_1 = require("../../internals/warnings");
const detector_1 = require("../detector");
/**
 * A detector that finds duplicated conditions appearing in conditional expressions.
 *
 * ## Why is it bad?
 * Typically, these cases are developer errors caused by copy-pasting code, leading
 * to unreachable code.
 *
 * ## Example
 * ```tact
 * fun test(a: Int): Int {
 *   if (a < 1) { return 1; }
 *   else if (a > 4) { return 2; }
 *   // Bad: A developer copy-pasted the condition
 *   else if (a > 4) { return 3; }
 *   return 4;
 * }
 * ```
 *
 * Use instead:
 * ```tact
 * fun test(a: Int): Int {
 *   if (a < 1) { return 1; }
 *   else if (a > 4) { return 2; }
 *   // OK: Fixed
 *   else if (a < x) { return 3; }
 *   return 4;
 * }
 * ```
 */
class DuplicatedCondition extends detector_1.AstDetector {
    severity = warnings_1.Severity.HIGH;
    category = warnings_1.Category.SECURITY;
    async check(cu) {
        return cu.ast.getProgramEntries().reduce((acc, node) => {
            const exprWarnings = (0, tact_1.foldExpressions)(node, (acc, expr) => {
                return expr.kind === "conditional"
                    ? this.checkConditionalExpression(acc, expr)
                    : acc;
            }, []);
            const stmtWarnings = (0, tact_1.foldStatements)(node, (acc, stmt) => {
                return stmt.kind === "statement_condition"
                    ? this.checkConditionalStatement(acc, stmt)
                    : acc;
            }, []);
            return acc.concat(...stmtWarnings, ...exprWarnings);
        }, []);
    }
    checkConditionalExpression(acc, expr) {
        const allConditions = this.collectConditionalExpressions(expr);
        return this.checkConditions(acc, allConditions);
    }
    checkConditionalStatement(acc, stmt) {
        const allConditions = (0, tact_1.collectConditions)(stmt);
        return this.checkConditions(acc, allConditions);
    }
    checkConditions(acc, allConditions) {
        allConditions.forEach((lhs, index) => {
            allConditions.slice(index + 1).forEach((rhs) => {
                if ((0, tact_1.nodesAreEqual)(lhs, rhs)) {
                    const lhsStr = (0, imports_1.prettyPrint)(lhs);
                    const rhsStr = (0, imports_1.prettyPrint)(rhs);
                    let desc = "";
                    if (lhsStr === rhsStr) {
                        const lhsLc = lhs.loc.interval.getLineAndColumn();
                        const rhsLc = rhs.loc.interval.getLineAndColumn();
                        desc = `Condition ${lhsStr} appears at ${lhsLc.lineNum}:${lhsLc.colNum} and ${rhsLc.lineNum}:${rhsLc.colNum}`;
                    }
                    else {
                        desc = `Conditions ${lhsStr} and ${rhsStr} are equal`;
                    }
                    acc.push(this.makeWarning(desc, lhs.loc, {
                        suggestion: "Consider removing an extra condition or changing it.",
                    }));
                }
            });
        });
        return acc;
    }
    /**
     * Collects all the conditions from the ternary conditional expression, including
     * nested "else-if" operations.
     */
    collectConditionalExpressions(node) {
        const conditions = [node.condition];
        if (node.thenBranch && node.thenBranch.kind === "conditional") {
            conditions.push(...this.collectConditionalExpressions(node.thenBranch));
        }
        if (node.elseBranch && node.elseBranch.kind === "conditional") {
            conditions.push(...this.collectConditionalExpressions(node.elseBranch));
        }
        return conditions;
    }
}
exports.DuplicatedCondition = DuplicatedCondition;
