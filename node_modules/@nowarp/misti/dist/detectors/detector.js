"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasBuiltInDetector = exports.getEnabledDetectors = exports.getAllDetectors = exports.findBuiltInDetector = exports.BuiltInDetectors = exports.SouffleDetector = exports.DataflowDetector = exports.AstDetector = exports.Detector = void 0;
const exceptions_1 = require("../internals/exceptions");
const warnings_1 = require("../internals/warnings");
const souffle_1 = require("@nowarp/souffle");
const json_bigint_1 = __importDefault(require("json-bigint"));
/**
 * Abstract base class for a detector module, providing an interface for defining various types of detectors.
 */
class Detector {
    ctx;
    category = undefined;
    constructor(ctx) {
        this.ctx = ctx;
    }
    /**
     * Gets the short identifier of the detector, used in analyzer warnings.
     * @returns The unique identifier of the detector.
     */
    get id() {
        return this.constructor.name;
    }
    /**
     * Returns minimum and maximum severities of generated warnings.
     */
    getSeverity() {
        return typeof this.severity === "object"
            ? this.severity
            : { min: this.severity, max: this.severity };
    }
    /**
     * Returns the category of generated warnings if specified.
     */
    getCategory() {
        if (this.category === undefined)
            return undefined;
        return Array.isArray(this.category) ? this.category : [this.category];
    }
    /**
     * Defines the behavior of warnings generated by this detector when working with
     * multiple projects within a single Tact configuration.
     *
     * Here are the available options:
     * 1. `"union"`
     * Leave this value if you don't care about warnings generated in other projects.
     * 2. `"intersect"`
     * If the warning is generated for some source location of the imported file,
     * it should be generated by each of the projects. Example: Constants from an
     * imported file should not be reported iff they are unused in all the projects,
     * so you need "intersect".
     */
    get shareImportedWarnings() {
        return "union";
    }
    /**
     * Checks whether this detector needs the Soufflé binary to be executed.
     */
    get usesSouffle() {
        return this.kind === "souffle";
    }
    /**
     * Returns `true` if the identifier with the given name should not be reported
     * by unused variables detectors.
     */
    skipUnused(name) {
        return name.startsWith(this.ctx.config.unusedPrefix);
    }
    /**
     * A wrapper method that creates Misti warnings with additional context about
     * the detector generated it.
     */
    makeWarning(description, loc, data = {}) {
        if (data.severity &&
            (data.severity < this.getSeverity().min ||
                data.severity > this.getSeverity().max)) {
            const current = (0, warnings_1.severityToString)(data.severity);
            const interval = `[${(0, warnings_1.severityToString)(this.getSeverity().min)},${(0, warnings_1.severityToString)(this.getSeverity().max)}]`;
            throw exceptions_1.InternalException.make(`${this.id}: Cannot raise ${current} warning with defined severities ${interval}`);
        }
        const category = ((c = data.category) => {
            if (c === undefined) {
                const detectorCategory = this.getCategory();
                if (!Array.isArray(detectorCategory))
                    return detectorCategory;
            }
            return c;
        })();
        return (0, warnings_1.makeWarning)(this.id, description, data.severity ? data.severity : this.getSeverity().max, category, loc, {
            ...data,
            docURL: hasBuiltInDetector(this.id) ? (0, warnings_1.makeDocURL)(this.id) : undefined,
        });
    }
}
exports.Detector = Detector;
/**
 * Abstract class for detectors that identify specific patterns in the AST.
 */
class AstDetector extends Detector {
    get kind() {
        return "ast";
    }
}
exports.AstDetector = AstDetector;
/**
 * Abstract class for dataflow detectors that leverage the Monotone framework and a worklist solver.
 */
class DataflowDetector extends Detector {
    get kind() {
        return "dataflow";
    }
}
exports.DataflowDetector = DataflowDetector;
/**
 * Abstract class for Souffle-based detectors that implement Datalog-based analyses.
 */
class SouffleDetector extends Detector {
    get kind() {
        return "souffle";
    }
    /**
     * Creates a Soufflé context with unique name.
     * @param docstring A comment introduced on the top of the generated program if `ctx.config.souffleVerbose` is set.
     *
     * It should be used to avoid name clashes in the Soufflé directory when working with multiple projects.
     */
    createSouffleContext(cu, docstring = `Generated by ${this.id} detector`) {
        return new souffle_1.SouffleContext(`${this.id}_${cu.projectName}`, {
            addComments: this.ctx.config.souffleVerbose,
            comment: docstring ? (0, souffle_1.comment)(docstring, "/*") : undefined,
        });
    }
    /**
     * Executes Souffle program for this detector converting output facts to warnings.
     * @param ctx Souffle context with all the declarations, rules and facts added.
     * @param callback A function that creates warnings from output facts.
     */
    async executeSouffle(ctx, callback) {
        const executor = new souffle_1.SouffleAsyncExecutor({
            inputDir: this.ctx.config.soufflePath,
            outputDir: this.ctx.config.soufflePath,
        });
        const result = await executor.execute(ctx);
        if (result.kind !== "structured") {
            const error = result.kind === "error"
                ? result.stderr
                : "Cannot unmarshal raw output:\n" +
                    json_bigint_1.default.stringify(result.results, null, 2);
            throw exceptions_1.InternalException.make(`Error executing Soufflé for ${this.id}:\n${error}`);
        }
        return Array.from(result.results.entries.values()).reduce((acc, facts) => {
            return acc.concat(facts.reduce((innerAcc, fact) => {
                const warning = callback(fact);
                if (warning) {
                    innerAcc.push(warning);
                }
                return innerAcc;
            }, []));
        }, []);
    }
}
exports.SouffleDetector = SouffleDetector;
/**
 * A mapping of detector names to their respective loader functions and default enablement status.
 */
exports.BuiltInDetectors = {
    DivideBeforeMultiply: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/divideBeforeMultiply"))).then((module) => new module.DivideBeforeMultiply(ctx)),
        enabledByDefault: true,
    },
    ReadOnlyVariables: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/readOnlyVariables"))).then((module) => new module.ReadOnlyVariables(ctx)),
        enabledByDefault: true,
    },
    NeverAccessedVariables: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/neverAccessedVariables"))).then((module) => new module.NeverAccessedVariables(ctx)),
        enabledByDefault: true,
    },
    UnboundLoop: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/unboundLoop"))).then((module) => new module.UnboundLoop(ctx)),
        enabledByDefault: true,
    },
    ZeroAddress: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/zeroAddress"))).then((module) => new module.ZeroAddress(ctx)),
        enabledByDefault: true,
    },
    ConstantAddress: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/constantAddress"))).then((module) => new module.ConstantAddress(ctx)),
        enabledByDefault: false,
    },
    BranchDuplicate: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/branchDuplicate"))).then((module) => new module.BranchDuplicate(ctx)),
        enabledByDefault: true,
    },
    DumpIsUsed: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/dumpIsUsed"))).then((module) => new module.DumpIsUsed(ctx)),
        enabledByDefault: false,
    },
    FieldDoubleInit: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/fieldDoubleInit"))).then((module) => new module.FieldDoubleInit(ctx)),
        enabledByDefault: true,
    },
    PreferAugmentedAssign: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/preferAugmentedAssign"))).then((module) => new module.PreferAugmentedAssign(ctx)),
        enabledByDefault: true,
    },
    StringReceiversOverlap: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/stringReceiversOverlap"))).then((module) => new module.StringReceiversOverlap(ctx)),
        enabledByDefault: true,
    },
    AsmIsUsed: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/asmIsUsed"))).then((module) => new module.AsmIsUsed(ctx)),
        enabledByDefault: false,
    },
    PreferredStdlibApi: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/preferredStdlibApi"))).then((module) => new module.PreferredStdlibApi(ctx)),
        enabledByDefault: false,
    },
    InheritedStateMutation: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/inheritedStateMutation"))).then((module) => new module.InheritedStateMutation(ctx)),
        enabledByDefault: false,
    },
    ArgCopyMutation: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/argCopyMutation"))).then((module) => new module.ArgCopyMutation(ctx)),
        enabledByDefault: true,
    },
    OptimalMathFunction: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/optimalMathFunction"))).then((module) => new module.OptimalMathFunction(ctx)),
        enabledByDefault: true,
    },
    DuplicatedCondition: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/duplicatedCondition"))).then((module) => new module.DuplicatedCondition(ctx)),
        enabledByDefault: true,
    },
    UnusedOptional: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/unusedOptional"))).then((module) => new module.UnusedOptional(ctx)),
        enabledByDefault: true,
    },
    EnsurePrgSeed: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/ensurePrgSeed"))).then((module) => new module.EnsurePrgSeed(ctx)),
        enabledByDefault: true,
    },
    FalseCondition: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/falseCondition"))).then((module) => new module.FalseCondition(ctx)),
        enabledByDefault: true,
    },
    SendInLoop: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/sendInLoop"))).then((module) => new module.SendInLoop(ctx)),
        enabledByDefault: false,
    },
    UnboundMap: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/unboundMap"))).then((module) => new module.UnboundMap(ctx)),
        enabledByDefault: false,
    },
    StateMutationInGetter: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/stateMutationInGetter"))).then((module) => new module.StateMutationInGetter(ctx)),
        enabledByDefault: false,
    },
    UnusedExpressionResult: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/unusedExpressionResult"))).then((module) => new module.UnusedExpressionResult(ctx)),
        enabledByDefault: true,
    },
    SuspiciousMessageMode: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/suspiciousMessageMode"))).then((module) => new module.SuspiciousMessageMode(ctx)),
        enabledByDefault: true,
    },
    ShortCircuitCondition: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/shortCircuitCondition"))).then((module) => new module.ShortCircuitCondition(ctx)),
        enabledByDefault: true,
    },
    EtaLikeSimplifications: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/etaLikeSimplifications"))).then((module) => new module.EtaLikeSimplifications(ctx)),
        enabledByDefault: true,
    },
    ExitCodeUsage: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/exitCodeUsage"))).then((module) => new module.ExitCodeUsage(ctx)),
        enabledByDefault: true,
    },
    CellBounds: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/cellBounds"))).then((module) => new module.CellBounds(ctx)),
        enabledByDefault: true,
    },
    UnprotectedCall: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/unprotectedCall"))).then((module) => new module.UnprotectedCall(ctx)),
        enabledByDefault: true,
    },
    SuspiciousLoop: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/suspiciousLoop"))).then((module) => new module.SuspiciousLoop(ctx)),
        enabledByDefault: true,
    },
    SuboptimalSend: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/suboptimalSend"))).then((module) => new module.SuboptimalSend(ctx)),
        enabledByDefault: true,
    },
    PreferBinaryReceiver: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/preferBinaryReceiver"))).then((module) => new module.PreferBinaryReceiver(ctx)),
        enabledByDefault: true,
    },
    PreferSenderFunction: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/preferSenderFunction"))).then((module) => new module.PreferSenderFunction(ctx)),
        enabledByDefault: true,
    },
    ImplicitOpcode: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/implicitOpcode"))).then((module) => new module.ImplicitOpcode(ctx)),
        enabledByDefault: false,
    },
    SuboptimalCellOperation: {
        loader: (ctx) => Promise.resolve().then(() => __importStar(require("./builtin/suboptimalCellOperation"))).then((module) => new module.SuboptimalCellOperation(ctx)),
        enabledByDefault: true,
    },
};
/**
 * Asynchronously retrieves a built-in detector by its name.
 * If the detector is found in the BuiltInDetectors registry, it is loaded and returned;
 * otherwise, a warning is logged and `undefined` is returned.
 *
 * @param ctx Misti context.
 * @param name The name of the detector to retrieve. This name must match a key in the BuiltInDetectors object.
 * @returns A Promise that resolves to a Detector instance or `undefined` if the detector cannot be found or fails to load.
 */
async function findBuiltInDetector(ctx, name) {
    const detectorEntry = exports.BuiltInDetectors[name];
    if (!detectorEntry) {
        ctx.logger.warn(`Built-in detector ${name} not found.`);
        return undefined;
    }
    try {
        return await detectorEntry.loader(ctx);
    }
    catch (error) {
        ctx.logger.error(`Error loading built-in detector ${name}: ${error}`);
        return undefined;
    }
}
exports.findBuiltInDetector = findBuiltInDetector;
/**
 * Returns a list of all the available built-in detectors.
 * @returns An array of strings representing the names of detectors.
 */
function getAllDetectors() {
    return Object.keys(exports.BuiltInDetectors);
}
exports.getAllDetectors = getAllDetectors;
/**
 * Returns a list of detector names that are enabled by default.
 * @returns An array of strings representing the names of enabled detectors.
 */
function getEnabledDetectors() {
    return Object.keys(exports.BuiltInDetectors).filter((name) => exports.BuiltInDetectors[name].enabledByDefault);
}
exports.getEnabledDetectors = getEnabledDetectors;
/**
 * @returns True if there is a built-in detector with the given name.
 */
function hasBuiltInDetector(name) {
    return name in exports.BuiltInDetectors;
}
exports.hasBuiltInDetector = hasBuiltInDetector;
